{"version":3,"sources":["interact.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","getInteractionFromPointer","pointer","eventType","eventTarget","interaction","len","scope","interactions","mouseEvent","test","pointerType","id","utils","getPointerId","element","inertiaStatus","active","target","options","prepared","name","inertia","allowResume","mouse","pointers","removePointer","addPointer","parentElement","browser","supportsTouch","supportsPointerEvent","Interaction","contains","pointerIds","gesture","interacting","doOnInteractions","method","event","getActualElement","path","curEventTarget","currentTarget","type","prevTouchTime","Date","getTime","changedTouches","_updateEventTargets","pointerIsDown","preventOriginalDefault","this","originalEvent","preventDefault","checkResizeEdge","value","page","interactableElement","rect","margin","width","isNumber","right","left","height","bottom","top","x","y","isElement","matchesUpTo","defaultActionChecker","resizeEdges","getRect","shouldResize","action","resizeAxes","extend","curCoords","actionIsEnabled","resize","enabled","resizeOptions","isObject","edges","edge","_eventTarget","axis","drag","dragging","resizing","delegateListener","useCapture","fakeEvent","delegated","delegatedEvents","prop","selectors","selector","context","contexts","matchesSelector","nodeContains","listeners","j","delegateUseCapture","interact","interactables","get","Interactable","_element","_iEvents","_window","trySelector","getWindow","window","Node","document","_context","PointerEvent","events","add","pEventTypes","down","pointerDown","move","pointerHover","_doc","documents","listenToDocument","push","set","endAllInteractions","pointerEnd","doc","win","defaultView","parentWindow","MSPointerEvent","up","over","out","cancel","selectorDown","pointerMove","pointerOver","pointerOut","pointerUp","pointerCancel","autoScrollMove","frameElement","parentDoc","ownerDocument","error","windowParentError","useAttachEvent","currentAction","checkAndPreventDefault","dynamicDrop","defaultOptions","autoScroll","pointerMoveTolerance","maxInteractions","Infinity","actionCursors","isIe9OrOlder","resizex","resizey","resizexy","resizetop","resizeleft","resizebottom","resizeright","resizetopleft","resizebottomright","resizetopright","resizebottomleft","wheelEvent","eventTypes","globalEvents","prefixedMatchesSelector","Element","prototype","ie8MatchesSelector","interactionListeners","isString","querySelector","getScrollXY","scrollX","documentElement","scrollLeft","scrollY","scrollTop","SVGElementInstance","correspondingUseElement","getElementRect","scroll","isIOS7orLower","clientRect","SVGElement","getBoundingClientRect","getClientRects","heigh","getOriginXY","interactable","origin","closest","isFunction","_getQBezierValue","p1","p2","p3","iT","getQuadraticCurvePoint","startX","startY","cpX","cpY","endX","endY","position","easeOutQuad","b","c","d","parent","child","parentNode","node","isDocFrag","host","inContext","testIgnore","ignoreFrom","testAllow","allowFrom","checkAxis","thisAxis","checkSnap","snap","checkRestrict","restrict","checkAutoScroll","withinInteractionLimit","maxActions","max","maxPerElement","activeInteractions","targetCount","targetElementCount","otherAction","indexOfDeepestElement","elements","dropzone","deepestZone","index","deepestZoneParents","dropzoneParents","unshift","HTMLElement","SVGSVGElement","ownerSVGElement","parents","lastChild","previousSibling","nodeList","realWindow","replace","limit","elems","querySelectorAll","InteractEvent","listenerName","indexOfElement","forEachSelector","callback","ret","undefined","setOnEvents","phases","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","onstart","onmove","onend","oninertiastart","draggable","setPerAction","isBool","option","perAction","drop","accept","overlap","Math","min","dropCheck","draggableElement","dropElement","dropped","dropChecker","dropOverlap","horizontal","vertical","getPageXY","dragRect","cx","cy","overlapArea","overlapRatio","checker","newValue","resizable","square","squareResize","gesturable","actions","setOptions","isArray","thisOption","mode","targets","createSnapGrid","offset","gridOffset","grid","anchors","paths","relativePoints","elementOrigin","allActions","getAction","actionChecker","rectChecker","styleCursor","deltaSource","restriction","fire","iEvent","onEvent","funcName","immediatePropagationStopped","on","listener","search","trim","split","off","eventList","indexOf","splice","matchFound","fn","useCap","remove","base","methods","perActions","settings","setting","unset","style","cursor","warnOnce","isSet","enableDragging","enableResizing","enableGesturing","debug","gesturing","matches","matchElements","prevCoords","startCoords","recordPointer","snapStatus","restrictStatus","downTime","downTimes","downEvent","downPointer","prevEvent","dragMove","resizeMove","gestureMove","getTouchAverage","touchAverage","getTouchBBox","touchBBox","getTouchDistance","touchDistance","getTouchAngle","touchAngle","newvalue","stop","offsetX","offsetY","gridx","round","gridy","newX","newY","range","./InteractEvent","./Interaction","./autoScroll","./defaultOptions","./scope","./utils","./utils/events","./utils/window",2,"phase","related","client","sourceX","sourceY","starting","ending","coords","locked","snappedX","snappedY","realX","realY","dx","dy","elementRect","restricted","pageX","pageY","clientX","clientY","x0","y0","clientX0","clientY0","ctrlKey","altKey","shiftKey","metaKey","button","t0","detail","relatedTarget","zeroResumeDelta","resumeDx","resumeDy","axes","touches","distance","box","scale","ds","angle","da","startAngle","startDistance","prevAngle","prevScale","timeStamp","dt","duration","speed","velocityX","velocityY","hypot","pointerDelta","vx","vy","atan2","PI","swipe","velocity","blank","stopImmediatePropagation","propagationStopped","stopPropagation",3,"dropTarget","prevDropTarget","prevDropElement","smoothEnd","startEvent","upCoords","xe","ye","sx","sy","vx0","vys","lambda_v0","one_ve_v0","Function","bind","boundInertiaFrame","inertiaFrame","boundSmoothEndFrame","smoothEndFrame","that","activeDrops","dropzones","rects","downTargets","holdTimers","_curEventTarget","tapTime","prevTap","startOffset","restrictOffset","snapOffsets","start","prevDistance","changed","restrictedX","restrictedY","pointerWasMoved","validateAction","actionName","getActionCursor","cursorKey","edgeNames","animationFrame","raf","xy","getClientXY","setEventXY","ptr","pushCurMatches","curMatches","curMatchElements","prevTargetElement","elementInteractable","elementAction","validateSelector","pushMatches","eventCopy","pointerIndex","setTimeout","pointerHold","_holdDuration","collectEventTargets","copyCoords","forceAction","NaN","setModifications","preEnd","shouldMove","shouldSnap","endOnly","shouldRestrict","setSnapping","setRestriction","setStartOffsets","snapOffset","duplicateMove","clearTimeout","setEventDeltas","absX","abs","absY","targetAxis","manualStart","thisInteraction","getDraggable","selectorInteractable","dragStart","dragEvent","setActiveDrops","dropEvents","getDropEvents","activate","fireActiveDrops","getDrop","leave","enter","resizeStart","resizeEvent","startRect","squareEdges","_squareEdges","resizeRects","current","previous","delta","deltaRect","invert","invertible","originalEdges","swap","gestureStart","gestureEvent","isNaN","ie8Dblclick","endEvent","inertiaOptions","pointerSpeed","now","inertiaPossible","endSnap","endRestrict","minSpeed","endSpeed","snapRestrict","vy0","v0","calcInertia","statusObject","useStatusXY","modifiedXe","modifiedYe","request","deactivate","collectDrops","drops","dropElements","currentElement","prevElement","dragElement","possibleDrops","validDrops","dropIndex","pointerEvent","dragLeave","prevDropzone","dragEnter","dragmove","clearTargets","lambda","resistance","te","progress","exp","quadPoint","smoothEndDuration","collectSelectors","els","firePointers","interval","createNewDoubleTap","pointerId","doubleTap","match","matchElement","pageCoords","status","relIndex","relative","inRange","snapChanged","prevent","nodeName","inertiaDur","log","container","isWindow","innerWidth","innerHeight","isScrolling","./utils/browser",4,"prevTime","scrollBy","./utils/isType","./utils/raf",5,"offsets","./utils/domObjects",6,"./utils/arr.js","./utils/extend",7,"array",8,"domObjects","DocumentTouch","isOperaMobile","navigator","appName","userAgent","platform","appVersion","all","atob","./domObjects","./window",9,"DocumentFragment",10,"elementIndex","typeCount","attachedListeners","supplied","wrapped","useCount","listenerIndex","srcElement","preventDef","stopProp","stopImmProp","addEvent","removeEvent","hasOwnProperty","returnValue","cancelBubble","arr","_elements","_targets","_attachedListeners","./arr",11,"dest","source",12,"sqrt",13,"message","warned","console","warn","apply","arguments","./browser","./extend","./hypot","./isType","./pointerUtils","./raf",14,"isType","nodeType","thing","./isWindow",15,"Window",16,"pointerUtils","tmpXY","src","targetObj","prev","cur","getXY","identifier","../InteractEvent",17,"reqFrame","cancelFrame","lastTime","vendors","requestAnimationFrame","currTime","timeToCall",18,"isShadowDom","el","createTextNode","wrap","rootNode"],"mappings":"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","file":"interact.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * interact.js v1.2.4\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n\n    'use strict';\n\n    // return early if there's no window to work with (eg. Node.js)\n    if (!require('./utils/window').window) { return; }\n\n    var scope = require('./scope'),\n        utils = require('./utils'),\n        browser = utils.browser;\n\n    scope.pEventTypes = null;\n\n    scope.documents       = [];   // all documents being listened to\n\n    scope.interactables   = [];   // all set interactables\n    scope.interactions    = [];   // all interactions\n\n    scope.dynamicDrop     = false;\n\n    // {\n    //      type: {\n    //          selectors: ['selector', ...],\n    //          contexts : [document, ...],\n    //          listeners: [[listener, useCapture], ...]\n    //      }\n    //  }\n    scope.delegatedEvents = {};\n\n    scope.defaultOptions = require('./defaultOptions');\n\n    // Things related to autoScroll\n    scope.autoScroll = require('./autoScroll');\n\n    // Less Precision with touch input\n    scope.margin = browser.supportsTouch || browser.supportsPointerEvent? 20: 10;\n\n    scope.pointerMoveTolerance = 1;\n\n    // for ignoring browser's simulated mouse events\n    scope.prevTouchTime = 0;\n\n    // Allow this many interactions to happen simultaneously\n    scope.maxInteractions = Infinity;\n\n    scope.actionCursors = browser.isIe9OrOlder ? {\n        drag    : 'move',\n        resizex : 'e-resize',\n        resizey : 's-resize',\n        resizexy: 'se-resize',\n\n        resizetop        : 'n-resize',\n        resizeleft       : 'w-resize',\n        resizebottom     : 's-resize',\n        resizeright      : 'e-resize',\n        resizetopleft    : 'se-resize',\n        resizebottomright: 'se-resize',\n        resizetopright   : 'ne-resize',\n        resizebottomleft : 'ne-resize',\n\n        gesture : ''\n    } : {\n        drag    : 'move',\n        resizex : 'ew-resize',\n        resizey : 'ns-resize',\n        resizexy: 'nwse-resize',\n\n        resizetop        : 'ns-resize',\n        resizeleft       : 'ew-resize',\n        resizebottom     : 'ns-resize',\n        resizeright      : 'ew-resize',\n        resizetopleft    : 'nwse-resize',\n        resizebottomright: 'nwse-resize',\n        resizetopright   : 'nesw-resize',\n        resizebottomleft : 'nesw-resize',\n\n        gesture : ''\n    };\n\n    scope.actionIsEnabled = {\n        drag   : true,\n        resize : true,\n        gesture: true\n    };\n\n    // because Webkit and Opera still use 'mousewheel' event type\n    scope.wheelEvent = 'onmousewheel' in scope.document? 'mousewheel': 'wheel';\n\n    scope.eventTypes = [\n        'dragstart',\n        'dragmove',\n        'draginertiastart',\n        'dragend',\n        'dragenter',\n        'dragleave',\n        'dropactivate',\n        'dropdeactivate',\n        'dropmove',\n        'drop',\n        'resizestart',\n        'resizemove',\n        'resizeinertiastart',\n        'resizeend',\n        'gesturestart',\n        'gesturemove',\n        'gestureinertiastart',\n        'gestureend',\n\n        'down',\n        'move',\n        'up',\n        'cancel',\n        'tap',\n        'doubletap',\n        'hold'\n    ];\n\n    scope.globalEvents = {};\n\n    // prefix matchesSelector\n    browser.prefixedMatchesSelector = 'matches' in Element.prototype?\n            'matches': 'webkitMatchesSelector' in Element.prototype?\n                'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n                    'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n                        'oMatchesSelector': 'msMatchesSelector';\n\n    // will be polyfill function if browser is IE8\n    scope.ie8MatchesSelector = null;\n\n    // Events wrapper\n    var events = require('./utils/events');\n\n    scope.listeners = {};\n\n    var interactionListeners = [\n        'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',\n        'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n        'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n        'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'\n    ];\n\n    scope.trySelector = function (value) {\n        if (!scope.isString(value)) { return false; }\n\n        // an exception will be raised if it is invalid\n        scope.document.querySelector(value);\n        return true;\n    };\n\n    scope.getScrollXY = function (win) {\n        win = win || scope.window;\n        return {\n            x: win.scrollX || win.document.documentElement.scrollLeft,\n            y: win.scrollY || win.document.documentElement.scrollTop\n        };\n    };\n\n    scope.getActualElement = function (element) {\n        return (element instanceof scope.SVGElementInstance\n            ? element.correspondingUseElement\n            : element);\n    };\n\n    scope.getElementRect = function (element) {\n        var scroll = browser.isIOS7orLower\n                ? { x: 0, y: 0 }\n                : scope.getScrollXY(scope.getWindow(element)),\n            clientRect = (element instanceof scope.SVGElement)?\n                element.getBoundingClientRect():\n                element.getClientRects()[0];\n\n        return clientRect && {\n            left  : clientRect.left   + scroll.x,\n            right : clientRect.right  + scroll.x,\n            top   : clientRect.top    + scroll.y,\n            bottom: clientRect.bottom + scroll.y,\n            width : clientRect.width || clientRect.right - clientRect.left,\n            height: clientRect.heigh || clientRect.bottom - clientRect.top\n        };\n    };\n\n    scope.getOriginXY = function (interactable, element) {\n        var origin = interactable\n                ? interactable.options.origin\n                : scope.defaultOptions.origin;\n\n        if (origin === 'parent') {\n            origin = scope.parentElement(element);\n        }\n        else if (origin === 'self') {\n            origin = interactable.getRect(element);\n        }\n        else if (scope.trySelector(origin)) {\n            origin = scope.closest(element, origin) || { x: 0, y: 0 };\n        }\n\n        if (scope.isFunction(origin)) {\n            origin = origin(interactable && element);\n        }\n\n        if (utils.isElement(origin))  {\n            origin = scope.getElementRect(origin);\n        }\n\n        origin.x = ('x' in origin)? origin.x : origin.left;\n        origin.y = ('y' in origin)? origin.y : origin.top;\n\n        return origin;\n    };\n\n    // http://stackoverflow.com/a/5634528/2280888\n    scope._getQBezierValue = function (t, p1, p2, p3) {\n        var iT = 1 - t;\n        return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n    };\n\n    scope.getQuadraticCurvePoint = function (startX, startY, cpX, cpY, endX, endY, position) {\n        return {\n            x:  scope._getQBezierValue(position, startX, cpX, endX),\n            y:  scope._getQBezierValue(position, startY, cpY, endY)\n        };\n    };\n\n    // http://gizma.com/easing/\n    scope.easeOutQuad = function (t, b, c, d) {\n        t /= d;\n        return -c * t*(t-2) + b;\n    };\n\n    scope.nodeContains = function (parent, child) {\n        while (child) {\n            if (child === parent) {\n                return true;\n            }\n\n            child = child.parentNode;\n        }\n\n        return false;\n    };\n\n    scope.closest = function (child, selector) {\n        var parent = scope.parentElement(child);\n\n        while (utils.isElement(parent)) {\n            if (scope.matchesSelector(parent, selector)) { return parent; }\n\n            parent = scope.parentElement(parent);\n        }\n\n        return null;\n    };\n\n    scope.parentElement = function (node) {\n        var parent = node.parentNode;\n\n        if (scope.isDocFrag(parent)) {\n            // skip past #shado-root fragments\n            while ((parent = parent.host) && scope.isDocFrag(parent)) {}\n\n            return parent;\n        }\n\n        return parent;\n    };\n\n    scope.inContext = function (interactable, element) {\n        return interactable._context === element.ownerDocument\n                || scope.nodeContains(interactable._context, element);\n    };\n\n    scope.testIgnore = function (interactable, interactableElement, element) {\n        var ignoreFrom = interactable.options.ignoreFrom;\n\n        if (!ignoreFrom || !utils.isElement(element)) { return false; }\n\n        if (scope.isString(ignoreFrom)) {\n            return scope.matchesUpTo(element, ignoreFrom, interactableElement);\n        }\n        else if (utils.isElement(ignoreFrom)) {\n            return scope.nodeContains(ignoreFrom, element);\n        }\n\n        return false;\n    };\n\n    scope.testAllow = function (interactable, interactableElement, element) {\n        var allowFrom = interactable.options.allowFrom;\n\n        if (!allowFrom) { return true; }\n\n        if (!utils.isElement(element)) { return false; }\n\n        if (scope.isString(allowFrom)) {\n            return scope.matchesUpTo(element, allowFrom, interactableElement);\n        }\n        else if (utils.isElement(allowFrom)) {\n            return scope.nodeContains(allowFrom, element);\n        }\n\n        return false;\n    };\n\n    scope.checkAxis = function (axis, interactable) {\n        if (!interactable) { return false; }\n\n        var thisAxis = interactable.options.drag.axis;\n\n        return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n    };\n\n    scope.checkSnap = function (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return options[action].snap && options[action].snap.enabled;\n    };\n\n    scope.checkRestrict = function (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].restrict && options[action].restrict.enabled;\n    };\n\n    scope.checkAutoScroll = function (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].autoScroll && options[action].autoScroll.enabled;\n    };\n\n    scope.withinInteractionLimit = function (interactable, element, action) {\n        var options = interactable.options,\n            maxActions = options[action.name].max,\n            maxPerElement = options[action.name].maxPerElement,\n            activeInteractions = 0,\n            targetCount = 0,\n            targetElementCount = 0;\n\n        for (var i = 0, len = scope.interactions.length; i < len; i++) {\n            var interaction = scope.interactions[i],\n                otherAction = interaction.prepared.name,\n                active = interaction.interacting();\n\n            if (!active) { continue; }\n\n            activeInteractions++;\n\n            if (activeInteractions >= scope.maxInteractions) {\n                return false;\n            }\n\n            if (interaction.target !== interactable) { continue; }\n\n            targetCount += (otherAction === action.name)|0;\n\n            if (targetCount >= maxActions) {\n                return false;\n            }\n\n            if (interaction.element === element) {\n                targetElementCount++;\n\n                if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n                    return false;\n                }\n            }\n        }\n\n        return scope.maxInteractions > 0;\n    };\n\n    // Test for the element that's \"above\" all other qualifiers\n    scope.indexOfDeepestElement = function (elements) {\n        var dropzone,\n            deepestZone = elements[0],\n            index = deepestZone? 0: -1,\n            parent,\n            deepestZoneParents = [],\n            dropzoneParents = [],\n            child,\n            i,\n            n;\n\n        for (i = 1; i < elements.length; i++) {\n            dropzone = elements[i];\n\n            // an element might belong to multiple selector dropzones\n            if (!dropzone || dropzone === deepestZone) {\n                continue;\n            }\n\n            if (!deepestZone) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            // check if the deepest or current are document.documentElement or document.rootElement\n            // - if the current dropzone is, do nothing and continue\n            if (dropzone.parentNode === dropzone.ownerDocument) {\n                continue;\n            }\n            // - if deepest is, update with the current dropzone and continue to next\n            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            if (!deepestZoneParents.length) {\n                parent = deepestZone;\n                while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n                    deepestZoneParents.unshift(parent);\n                    parent = parent.parentNode;\n                }\n            }\n\n            // if this element is an svg element and the current deepest is\n            // an HTMLElement\n            if (deepestZone instanceof scope.HTMLElement\n                && dropzone instanceof scope.SVGElement\n                && !(dropzone instanceof scope.SVGSVGElement)) {\n\n                if (dropzone === deepestZone.parentNode) {\n                    continue;\n                }\n\n                parent = dropzone.ownerSVGElement;\n            }\n            else {\n                parent = dropzone;\n            }\n\n            dropzoneParents = [];\n\n            while (parent.parentNode !== parent.ownerDocument) {\n                dropzoneParents.unshift(parent);\n                parent = parent.parentNode;\n            }\n\n            n = 0;\n\n            // get (position of last common ancestor) + 1\n            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n                n++;\n            }\n\n            var parents = [\n                dropzoneParents[n - 1],\n                dropzoneParents[n],\n                deepestZoneParents[n]\n            ];\n\n            child = parents[0].lastChild;\n\n            while (child) {\n                if (child === parents[1]) {\n                    deepestZone = dropzone;\n                    index = i;\n                    deepestZoneParents = [];\n\n                    break;\n                }\n                else if (child === parents[2]) {\n                    break;\n                }\n\n                child = child.previousSibling;\n            }\n        }\n\n        return index;\n    };\n\n    scope.matchesSelector = function (element, selector, nodeList) {\n        if (scope.ie8MatchesSelector) {\n            return scope.ie8MatchesSelector(element, selector, nodeList);\n        }\n\n        // remove /deep/ from selectors if shadowDOM polyfill is used\n        if (scope.window !== scope.realWindow) {\n            selector = selector.replace(/\\/deep\\//g, ' ');\n        }\n\n        return element[browser.prefixedMatchesSelector](selector);\n    };\n\n    scope.matchesUpTo = function (element, selector, limit) {\n        while (utils.isElement(element)) {\n            if (scope.matchesSelector(element, selector)) {\n                return true;\n            }\n\n            element = scope.parentElement(element);\n\n            if (element === limit) {\n                return scope.matchesSelector(element, selector);\n            }\n        }\n\n        return false;\n    };\n\n    // For IE8's lack of an Element#matchesSelector\n    // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n    if (!(browser.prefixedMatchesSelector in Element.prototype) || !scope.isFunction(Element.prototype[browser.prefixedMatchesSelector])) {\n        scope.ie8MatchesSelector = function (element, selector, elems) {\n            elems = elems || element.parentNode.querySelectorAll(selector);\n\n            for (var i = 0, len = elems.length; i < len; i++) {\n                if (elems[i] === element) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    var Interaction = require('./Interaction');\n\n    function getInteractionFromPointer (pointer, eventType, eventTarget) {\n        var i = 0, len = scope.interactions.length,\n            mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n                          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                          || pointer.pointerType === 4),\n            interaction;\n\n        var id = utils.getPointerId(pointer);\n\n        // try to resume inertia with a new pointer\n        if (/down|start/i.test(eventType)) {\n            for (i = 0; i < len; i++) {\n                interaction = scope.interactions[i];\n\n                var element = eventTarget;\n\n                if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n                    && (interaction.mouse === mouseEvent)) {\n                    while (element) {\n                        // if the element is the interaction element\n                        if (element === interaction.element) {\n                            // update the interaction's pointer\n                            if (interaction.pointers[0]) {\n                                interaction.removePointer(interaction.pointers[0]);\n                            }\n                            interaction.addPointer(pointer);\n\n                            return interaction;\n                        }\n                        element = scope.parentElement(element);\n                    }\n                }\n            }\n        }\n\n        // if it's a mouse interaction\n        if (mouseEvent || !(browser.supportsTouch || browser.supportsPointerEvent)) {\n\n            // find a mouse interaction that's not in inertia phase\n            for (i = 0; i < len; i++) {\n                if (scope.interactions[i].mouse && !scope.interactions[i].inertiaStatus.active) {\n                    return scope.interactions[i];\n                }\n            }\n\n            // find any interaction specifically for mouse.\n            // if the eventType is a mousedown, and inertia is active\n            // ignore the interaction\n            for (i = 0; i < len; i++) {\n                if (scope.interactions[i].mouse && !(/down/.test(eventType) && scope.interactions[i].inertiaStatus.active)) {\n                    return interaction;\n                }\n            }\n\n            // create a new interaction for mouse\n            interaction = new Interaction();\n            interaction.mouse = true;\n\n            return interaction;\n        }\n\n        // get interaction that has this pointer\n        for (i = 0; i < len; i++) {\n            if (scope.contains(scope.interactions[i].pointerIds, id)) {\n                return scope.interactions[i];\n            }\n        }\n\n        // at this stage, a pointerUp should not return an interaction\n        if (/up|end|out/i.test(eventType)) {\n            return null;\n        }\n\n        // get first idle interaction\n        for (i = 0; i < len; i++) {\n            interaction = scope.interactions[i];\n\n            if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n                && !interaction.interacting()\n                && !(!mouseEvent && interaction.mouse)) {\n\n                interaction.addPointer(pointer);\n\n                return interaction;\n            }\n        }\n\n        return new Interaction();\n    }\n\n    function doOnInteractions (method) {\n        return (function (event) {\n            var interaction,\n                eventTarget = scope.getActualElement(event.path\n                                               ? event.path[0]\n                                               : event.target),\n                curEventTarget = scope.getActualElement(event.currentTarget),\n                i;\n\n            if (browser.supportsTouch && /touch/.test(event.type)) {\n                scope.prevTouchTime = new Date().getTime();\n\n                for (i = 0; i < event.changedTouches.length; i++) {\n                    var pointer = event.changedTouches[i];\n\n                    interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\n                    if (!interaction) { continue; }\n\n                    interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                    interaction[method](pointer, event, eventTarget, curEventTarget);\n                }\n            }\n            else {\n                if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n                    // ignore mouse events while touch interactions are active\n                    for (i = 0; i < scope.interactions.length; i++) {\n                        if (!scope.interactions[i].mouse && scope.interactions[i].pointerIsDown) {\n                            return;\n                        }\n                    }\n\n                    // try to ignore mouse events that are simulated by the browser\n                    // after a touch event\n                    if (new Date().getTime() - scope.prevTouchTime < 500) {\n                        return;\n                    }\n                }\n\n                interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\n                if (!interaction) { return; }\n\n                interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                interaction[method](event, event, eventTarget, curEventTarget);\n            }\n        });\n    }\n\n    function preventOriginalDefault () {\n        this.originalEvent.preventDefault();\n    }\n\n    function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n        // false, '', undefined, null\n        if (!value) { return false; }\n\n        // true value, use pointer coords and element rect\n        if (value === true) {\n            // if dimensions are negative, \"switch\" edges\n            var width = scope.isNumber(rect.width)? rect.width : rect.right - rect.left,\n                height = scope.isNumber(rect.height)? rect.height : rect.bottom - rect.top;\n\n            if (width < 0) {\n                if      (name === 'left' ) { name = 'right'; }\n                else if (name === 'right') { name = 'left' ; }\n            }\n            if (height < 0) {\n                if      (name === 'top'   ) { name = 'bottom'; }\n                else if (name === 'bottom') { name = 'top'   ; }\n            }\n\n            if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n            if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n            if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n            if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n        }\n\n        // the remaining checks require an element\n        if (!utils.isElement(element)) { return false; }\n\n        return utils.isElement(value)\n                    // the value is an element to use as a resize handle\n                    ? value === element\n                    // otherwise check if element matches value as selector\n                    : scope.matchesUpTo(element, value, interactableElement);\n    }\n\n    function defaultActionChecker (pointer, interaction, element) {\n        var rect = this.getRect(element),\n            shouldResize = false,\n            action = null,\n            resizeAxes = null,\n            resizeEdges,\n            page = utils.extend({}, interaction.curCoords.page),\n            options = this.options;\n\n        if (!rect) { return null; }\n\n        if (scope.actionIsEnabled.resize && options.resize.enabled) {\n            var resizeOptions = options.resize;\n\n            resizeEdges = {\n                left: false, right: false, top: false, bottom: false\n            };\n\n            // if using resize.edges\n            if (scope.isObject(resizeOptions.edges)) {\n                for (var edge in resizeEdges) {\n                    resizeEdges[edge] = checkResizeEdge(edge,\n                                                        resizeOptions.edges[edge],\n                                                        page,\n                                                        interaction._eventTarget,\n                                                        element,\n                                                        rect,\n                                                        resizeOptions.margin || scope.margin);\n                }\n\n                resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n                resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n                shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n            }\n            else {\n                var right  = options.resize.axis !== 'y' && page.x > (rect.right  - scope.margin),\n                    bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - scope.margin);\n\n                shouldResize = right || bottom;\n                resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');\n            }\n        }\n\n        action = shouldResize\n            ? 'resize'\n            : scope.actionIsEnabled.drag && options.drag.enabled\n                ? 'drag'\n                : null;\n\n        if (scope.actionIsEnabled.gesture\n            && interaction.pointerIds.length >=2\n            && !(interaction.dragging || interaction.resizing)) {\n            action = 'gesture';\n        }\n\n        if (action) {\n            return {\n                name: action,\n                axis: resizeAxes,\n                edges: resizeEdges\n            };\n        }\n\n        return null;\n    }\n\n    var InteractEvent = require('./InteractEvent');\n\n    for (var i = 0, len = interactionListeners.length; i < len; i++) {\n        var listenerName = interactionListeners[i];\n\n        scope.listeners[listenerName] = doOnInteractions(listenerName);\n    }\n\n    // bound to the interactable context when a DOM event\n    // listener is added to a selector interactable\n    function delegateListener (event, useCapture) {\n        var fakeEvent = {},\n            delegated = scope.delegatedEvents[event.type],\n            eventTarget = scope.getActualElement(event.path\n                                           ? event.path[0]\n                                           : event.target),\n            element = eventTarget;\n\n        useCapture = useCapture? true: false;\n\n        // duplicate the event so that currentTarget can be changed\n        for (var prop in event) {\n            fakeEvent[prop] = event[prop];\n        }\n\n        fakeEvent.originalEvent = event;\n        fakeEvent.preventDefault = preventOriginalDefault;\n\n        // climb up document tree looking for selector matches\n        while (utils.isElement(element)) {\n            for (var i = 0; i < delegated.selectors.length; i++) {\n                var selector = delegated.selectors[i],\n                    context = delegated.contexts[i];\n\n                if (scope.matchesSelector(element, selector)\n                    && scope.nodeContains(context, eventTarget)\n                    && scope.nodeContains(context, element)) {\n\n                    var listeners = delegated.listeners[i];\n\n                    fakeEvent.currentTarget = element;\n\n                    for (var j = 0; j < listeners.length; j++) {\n                        if (listeners[j][1] === useCapture) {\n                            listeners[j][0](fakeEvent);\n                        }\n                    }\n                }\n            }\n\n            element = scope.parentElement(element);\n        }\n    }\n\n    function delegateUseCapture (event) {\n        return delegateListener.call(this, event, true);\n    }\n\n    scope.interactables.indexOfElement = function indexOfElement (element, context) {\n        context = context || scope.document;\n\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if ((interactable.selector === element\n                && (interactable._context === context))\n                || (!interactable.selector && interactable._element === element)) {\n\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    scope.interactables.get = function interactableGet (element, options) {\n        return this[this.indexOfElement(element, options && options.context)];\n    };\n\n    scope.interactables.forEachSelector = function (callback) {\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if (!interactable.selector) {\n                continue;\n            }\n\n            var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n    };\n\n    /*\\\n     * interact\n     [ method ]\n     *\n     * The methods of this variable can be used to set elements as\n     * interactables and also to change various default settings.\n     *\n     * Calling it as a function and passing an element or a valid CSS selector\n     * string returns an Interactable object which has various methods to\n     * configure it.\n     *\n     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n     = (object) An @Interactable\n     *\n     > Usage\n     | interact(document.getElementById('draggable')).draggable(true);\n     |\n     | var rectables = interact('rect');\n     | rectables\n     |     .gesturable(true)\n     |     .on('gesturemove', function (event) {\n     |         // something cool...\n     |     })\n     |     .autoScroll(true);\n    \\*/\n    function interact (element, options) {\n        return scope.interactables.get(element, options) || new Interactable(element, options);\n    }\n\n    /*\\\n     * Interactable\n     [ property ]\n     **\n     * Object type returned by @interact\n    \\*/\n    function Interactable (element, options) {\n        this._element = element;\n        this._iEvents = this._iEvents || {};\n\n        var _window;\n\n        if (scope.trySelector(element)) {\n            this.selector = element;\n\n            var context = options && options.context;\n\n            _window = context? scope.getWindow(context) : scope.window;\n\n            if (context && (_window.Node\n                    ? context instanceof _window.Node\n                    : (utils.isElement(context) || context === _window.document))) {\n\n                this._context = context;\n            }\n        }\n        else {\n            _window = scope.getWindow(element);\n\n            if (utils.isElement(element, _window)) {\n\n                if (scope.PointerEvent) {\n                    events.add(this._element, scope.pEventTypes.down, scope.listeners.pointerDown );\n                    events.add(this._element, scope.pEventTypes.move, scope.listeners.pointerHover);\n                }\n                else {\n                    events.add(this._element, 'mousedown' , scope.listeners.pointerDown );\n                    events.add(this._element, 'mousemove' , scope.listeners.pointerHover);\n                    events.add(this._element, 'touchstart', scope.listeners.pointerDown );\n                    events.add(this._element, 'touchmove' , scope.listeners.pointerHover);\n                }\n            }\n        }\n\n        this._doc = _window.document;\n\n        if (!scope.contains(scope.documents, this._doc)) {\n            listenToDocument(this._doc);\n        }\n\n        scope.interactables.push(this);\n\n        this.set(options);\n    }\n\n    Interactable.prototype = {\n        setOnEvents: function (action, phases) {\n            if (action === 'drop') {\n                if (scope.isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }\n                if (scope.isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }\n                if (scope.isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }\n                if (scope.isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }\n                if (scope.isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }\n                if (scope.isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }\n            }\n            else {\n                action = 'on' + action;\n\n                if (scope.isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }\n                if (scope.isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }\n                if (scope.isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }\n                if (scope.isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.draggable\n         [ method ]\n         *\n         * Gets or sets whether drag actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of drag events\n         | var isDraggable = interact('ul li').draggable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n         = (object) This Interactable\n         | interact(element).draggable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // the axis in which the first movement must be\n         |     // for the drag sequence to start\n         |     // 'xy' by default - any direction\n         |     axis: 'x' || 'y' || 'xy',\n         |\n         |     // max number of drags that can happen concurrently\n         |     // with elements of this Interactable. Infinity by default\n         |     max: Infinity,\n         |\n         |     // max number of drags that can target the same element+Interactable\n         |     // 1 by default\n         |     maxPerElement: 2\n         | });\n        \\*/\n        draggable: function (options) {\n            if (scope.isObject(options)) {\n                this.options.drag.enabled = options.enabled === false? false: true;\n                this.setPerAction('drag', options);\n                this.setOnEvents('drag', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.drag.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    delete this.options.drag.axis;\n                }\n\n                return this;\n            }\n\n            if (scope.isBool(options)) {\n                this.options.drag.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drag;\n        },\n\n        setPerAction: function (action, options) {\n            // for all the default per-action options\n            for (var option in options) {\n                // if this option exists for this action\n                if (option in scope.defaultOptions[action]) {\n                    // if the option in the options arg is an object value\n                    if (scope.isObject(options[option])) {\n                        // duplicate the object\n                        this.options[action][option] = utils.extend(this.options[action][option] || {}, options[option]);\n\n                        if (scope.isObject(scope.defaultOptions.perAction[option]) && 'enabled' in scope.defaultOptions.perAction[option]) {\n                            this.options[action][option].enabled = options[option].enabled === false? false : true;\n                        }\n                    }\n                    else if (scope.isBool(options[option]) && scope.isObject(scope.defaultOptions.perAction[option])) {\n                        this.options[action][option].enabled = options[option];\n                    }\n                    else if (options[option] !== undefined) {\n                        // or if it's not undefined, do a plain assignment\n                        this.options[action][option] = options[option];\n                    }\n                }\n            }\n        },\n\n        /*\\\n         * Interactable.dropzone\n         [ method ]\n         *\n         * Returns or sets whether elements can be dropped onto this\n         * Interactable to trigger drop events\n         *\n         * Dropzones can receive the following events:\n         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n         *  - `dragmove` when a draggable that has entered the dropzone is moved\n         *  - `drop` when a draggable is dropped into this dropzone\n         *\n         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n         *\n         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n         *   - `'pointer'`, the pointer must be over the dropzone (default)\n         *   - `'center'`, the draggable element's center must be over the dropzone\n         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n         *       e.g. `0.5` for drop to happen when half of the area of the\n         *       draggable is over the dropzone\n         *\n         - options (boolean | object | null) #optional The new value to be set.\n         | interact('.drop').dropzone({\n         |   accept: '.can-drop' || document.getElementById('single-drop'),\n         |   overlap: 'pointer' || 'center' || zeroToOne\n         | }\n         = (boolean | object) The current setting or this Interactable\n        \\*/\n        dropzone: function (options) {\n            if (scope.isObject(options)) {\n                this.options.drop.enabled = options.enabled === false? false: true;\n                this.setOnEvents('drop', options);\n                this.accept(options.accept);\n\n                if (/^(pointer|center)$/.test(options.overlap)) {\n                    this.options.drop.overlap = options.overlap;\n                }\n                else if (scope.isNumber(options.overlap)) {\n                    this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n                }\n\n                return this;\n            }\n\n            if (scope.isBool(options)) {\n                this.options.drop.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drop;\n        },\n\n        dropCheck: function (pointer, event, draggable, draggableElement, dropElement, rect) {\n            var dropped = false;\n\n            // if the dropzone has no rect (eg. display: none)\n            // call the custom dropChecker or just return false\n            if (!(rect = rect || this.getRect(dropElement))) {\n                return (this.options.dropChecker\n                    ? this.options.dropChecker(pointer, event, dropped, this, dropElement, draggable, draggableElement)\n                    : false);\n            }\n\n            var dropOverlap = this.options.drop.overlap;\n\n            if (dropOverlap === 'pointer') {\n                var page = utils.getPageXY(pointer),\n                    origin = scope.getOriginXY(draggable, draggableElement),\n                    horizontal,\n                    vertical;\n\n                page.x += origin.x;\n                page.y += origin.y;\n\n                horizontal = (page.x > rect.left) && (page.x < rect.right);\n                vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n                dropped = horizontal && vertical;\n            }\n\n            var dragRect = draggable.getRect(draggableElement);\n\n            if (dropOverlap === 'center') {\n                var cx = dragRect.left + dragRect.width  / 2,\n                    cy = dragRect.top  + dragRect.height / 2;\n\n                dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n            }\n\n            if (scope.isNumber(dropOverlap)) {\n                var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                                  * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),\n                    overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n                dropped = overlapRatio >= dropOverlap;\n            }\n\n            if (this.options.dropChecker) {\n                dropped = this.options.dropChecker(pointer, dropped, this, dropElement, draggable, draggableElement);\n            }\n\n            return dropped;\n        },\n\n        /*\\\n         * Interactable.dropChecker\n         [ method ]\n         *\n         * Gets or sets the function used to check if a dragged element is\n         * over this Interactable.\n         *\n         - checker (function) #optional The function that will be called when checking for a drop\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         * The checker function takes the following arguments:\n         *\n         - pointer (Touch | PointerEvent | MouseEvent) The pointer/event that ends a drag\n         - event (TouchEvent | PointerEvent | MouseEvent) The event related to the pointer\n         - dropped (boolean) The value from the default drop check\n         - dropzone (Interactable) The dropzone interactable\n         - dropElement (Element) The dropzone element\n         - draggable (Interactable) The Interactable being dragged\n         - draggableElement (Element) The actual element that's being dragged\n         *\n         > Usage:\n         | interact(target)\n         | .dropChecker(function(pointer,           // Touch/PointerEvent/MouseEvent\n         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n         |                       dropped,           // result of the default checker\n         |                       dropzone,          // dropzone Interactable\n         |                       dropElement,       // dropzone elemnt\n         |                       draggable,         // draggable Interactable\n         |                       draggableElement) {// draggable element\n         |\n         |   return dropped && event.target.hasAttribute('allow-drop');\n         | }\n        \\*/\n        dropChecker: function (checker) {\n            if (scope.isFunction(checker)) {\n                this.options.dropChecker = checker;\n\n                return this;\n            }\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.options.dropChecker;\n        },\n\n        /*\\\n         * Interactable.accept\n         [ method ]\n         *\n         * Deprecated. add an `accept` property to the options object passed to\n         * @Interactable.dropzone instead.\n         *\n         * Gets or sets the Element or CSS selector match that this\n         * Interactable accepts if it is a dropzone.\n         *\n         - newValue (Element | string | null) #optional\n         * If it is an Element, then only that element can be dropped into this dropzone.\n         * If it is a string, the element being dragged must match it as a selector.\n         * If it is null, the accept options is cleared - it accepts any element.\n         *\n         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n        \\*/\n        accept: function (newValue) {\n            if (utils.isElement(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            // test if it is a valid CSS selector\n            if (scope.trySelector(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.drop.accept;\n\n                return this;\n            }\n\n            return this.options.drop.accept;\n        },\n\n        /*\\\n         * Interactable.resizable\n         [ method ]\n         *\n         * Gets or sets whether resize actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of resize elements\n         | var isResizeable = interact('input[type=text]').resizable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n         = (object) This Interactable\n         | interact(element).resizable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     edges: {\n         |       top   : true,       // Use pointer coords to check for resize.\n         |       left  : false,      // Disable resizing from left edge.\n         |       bottom: '.resize-s',// Resize if pointer target matches selector\n         |       right : handleEl    // Resize if pointer target is the given Element\n         |     },\n         |\n         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n         |     // 'negate' will allow the rect to have negative width/height\n         |     // 'reposition' will keep the width/height positive by swapping\n         |     // the top and bottom edges and/or swapping the left and right edges\n         |     invert: 'none' || 'negate' || 'reposition'\n         |\n         |     // limit multiple resizes.\n         |     // See the explanation in the @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        resizable: function (options) {\n            if (scope.isObject(options)) {\n                this.options.resize.enabled = options.enabled === false? false: true;\n                this.setPerAction('resize', options);\n                this.setOnEvents('resize', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.resize.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    this.options.resize.axis = scope.defaultOptions.resize.axis;\n                }\n\n                if (scope.isBool(options.square)) {\n                    this.options.resize.square = options.square;\n                }\n\n                return this;\n            }\n            if (scope.isBool(options)) {\n                this.options.resize.enabled = options;\n\n                return this;\n            }\n            return this.options.resize;\n        },\n\n        /*\\\n         * Interactable.squareResize\n         [ method ]\n         *\n         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n         *\n         * Gets or sets whether resizing is forced 1:1 aspect\n         *\n         = (boolean) Current setting\n         *\n         * or\n         *\n         - newValue (boolean) #optional\n         = (object) this Interactable\n        \\*/\n        squareResize: function (newValue) {\n            if (scope.isBool(newValue)) {\n                this.options.resize.square = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.resize.square;\n\n                return this;\n            }\n\n            return this.options.resize.square;\n        },\n\n        /*\\\n         * Interactable.gesturable\n         [ method ]\n         *\n         * Gets or sets whether multitouch gestures can be performed on the\n         * Interactable's element\n         *\n         = (boolean) Indicates if this can be the target of gesture events\n         | var isGestureable = interact(element).gesturable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n         = (object) this Interactable\n         | interact(element).gesturable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // limit multiple gestures.\n         |     // See the explanation in @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        gesturable: function (options) {\n            if (scope.isObject(options)) {\n                this.options.gesture.enabled = options.enabled === false? false: true;\n                this.setPerAction('gesture', options);\n                this.setOnEvents('gesture', options);\n\n                return this;\n            }\n\n            if (scope.isBool(options)) {\n                this.options.gesture.enabled = options;\n\n                return this;\n            }\n\n            return this.options.gesture;\n        },\n\n        /*\\\n         * Interactable.autoScroll\n         [ method ]\n         **\n         * Deprecated. Add an `autoscroll` property to the options object\n         * passed to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets whether dragging and resizing near the edges of the\n         * window/container trigger autoScroll for this Interactable\n         *\n         = (object) Object with autoScroll properties\n         *\n         * or\n         *\n         - options (object | boolean) #optional\n         * options can be:\n         * - an object with margin, distance and interval properties,\n         * - true or false to enable or disable autoScroll or\n         = (Interactable) this Interactable\n        \\*/\n        autoScroll: function (options) {\n            if (scope.isObject(options)) {\n                options = utils.extend({ actions: ['drag', 'resize']}, options);\n            }\n            else if (scope.isBool(options)) {\n                options = { actions: ['drag', 'resize'], enabled: options };\n            }\n\n            return this.setOptions('autoScroll', options);\n        },\n\n        /*\\\n         * Interactable.snap\n         [ method ]\n         **\n         * Deprecated. Add a `snap` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how action coordinates are snapped. By\n         * default, snapping is relative to the pointer coordinates. You can\n         * change this by setting the\n         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n         **\n         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | interact(document.querySelector('#thing')).snap({\n         |     targets: [\n         |         // snap to this specific point\n         |         {\n         |             x: 100,\n         |             y: 100,\n         |             range: 25\n         |         },\n         |         // give this function the x and y page coords and snap to the object returned\n         |         function (x, y) {\n         |             return {\n         |                 x: x,\n         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n         |                 range: 40\n         |             };\n         |         },\n         |         // create a function that snaps to a grid\n         |         interact.createSnapGrid({\n         |             x: 50,\n         |             y: 50,\n         |             range: 10,              // optional\n         |             offset: { x: 5, y: 10 } // optional\n         |         })\n         |     ],\n         |     // do not snap during normal movement.\n         |     // Instead, trigger only one snapped move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     relativePoints: [\n         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n         |         { x: 1, y: 1 },  // and also to the bottom right\n         |     ],  \n         |\n         |     // offset the snap target coordinates\n         |     // can be an object with x/y or 'startCoords'\n         |     offset: { x: 50, y: 50 }\n         |   }\n         | });\n        \\*/\n        snap: function (options) {\n            var ret = this.setOptions('snap', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        setOptions: function (option, options) {\n            var actions = options && scope.isArray(options.actions)\n                    ? options.actions\n                    : ['drag'];\n\n            var i;\n\n            if (scope.isObject(options) || scope.isBool(options)) {\n                for (i = 0; i < actions.length; i++) {\n                    var action = /resize/.test(actions[i])? 'resize' : actions[i];\n\n                    if (!scope.isObject(this.options[action])) { continue; }\n\n                    var thisOption = this.options[action][option];\n\n                    if (scope.isObject(options)) {\n                        utils.extend(thisOption, options);\n                        thisOption.enabled = options.enabled === false? false: true;\n\n                        if (option === 'snap') {\n                            if (thisOption.mode === 'grid') {\n                                thisOption.targets = [\n                                    interact.createSnapGrid(utils.extend({\n                                        offset: thisOption.gridOffset || { x: 0, y: 0 }\n                                    }, thisOption.grid || {}))\n                                ];\n                            }\n                            else if (thisOption.mode === 'anchor') {\n                                thisOption.targets = thisOption.anchors;\n                            }\n                            else if (thisOption.mode === 'path') {\n                                thisOption.targets = thisOption.paths;\n                            }\n\n                            if ('elementOrigin' in options) {\n                                thisOption.relativePoints = [options.elementOrigin];\n                            }\n                        }\n                    }\n                    else if (scope.isBool(options)) {\n                        thisOption.enabled = options;\n                    }\n                }\n\n                return this;\n            }\n\n            var ret = {},\n                allActions = ['drag', 'resize', 'gesture'];\n\n            for (i = 0; i < allActions.length; i++) {\n                if (option in scope.defaultOptions[allActions[i]]) {\n                    ret[allActions[i]] = this.options[allActions[i]][option];\n                }\n            }\n\n            return ret;\n        },\n\n\n        /*\\\n         * Interactable.inertia\n         [ method ]\n         **\n         * Deprecated. Add an `inertia` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how events continue to run after the pointer is released\n         **\n         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | // enable and use default settings\n         | interact(element).inertia(true);\n         |\n         | // enable and use custom settings\n         | interact(element).inertia({\n         |     // value greater than 0\n         |     // high values slow the object down more quickly\n         |     resistance     : 16,\n         |\n         |     // the minimum launch speed (pixels per second) that results in inertia start\n         |     minSpeed       : 200,\n         |\n         |     // inertia will stop when the object slows down to this speed\n         |     endSpeed       : 20,\n         |\n         |     // boolean; should actions be resumed when the pointer goes down during inertia\n         |     allowResume    : true,\n         |\n         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n         |     zeroResumeDelta: false,\n         |\n         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n         |     // the pointer without triggering inertia will animate from the release\n         |     // point to the snaped/restricted point in the given amount of time (ms)\n         |     smoothEndDuration: 300,\n         |\n         |     // an array of action types that can have inertia (no gesture)\n         |     actions        : ['drag', 'resize']\n         | });\n         |\n         | // reset custom settings and use all defaults\n         | interact(element).inertia(null);\n        \\*/\n        inertia: function (options) {\n            var ret = this.setOptions('inertia', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        getAction: function (pointer, event, interaction, element) {\n            var action = this.defaultActionChecker(pointer, interaction, element);\n\n            if (this.options.actionChecker) {\n                return this.options.actionChecker(pointer, event, action, this, element, interaction);\n            }\n\n            return action;\n        },\n\n        defaultActionChecker: defaultActionChecker,\n\n        /*\\\n         * Interactable.actionChecker\n         [ method ]\n         *\n         * Gets or sets the function used to check action to be performed on\n         * pointerDown\n         *\n         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         | interact('.resize-drag')\n         |   .resizable(true)\n         |   .draggable(true)\n         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n         |\n         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n         |     // force drag with handle target\n         |     action.name = drag;\n         |   }\n         |   else {\n         |     // resize from the top and right edges\n         |     action.name  = 'resize';\n         |     action.edges = { top: true, right: true };\n         |   }\n         |\n         |   return action;\n         | });\n        \\*/\n        actionChecker: function (checker) {\n            if (scope.isFunction(checker)) {\n                this.options.actionChecker = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.actionChecker;\n\n                return this;\n            }\n\n            return this.options.actionChecker;\n        },\n\n        /*\\\n         * Interactable.getRect\n         [ method ]\n         *\n         * The default function to get an Interactables bounding rect. Can be\n         * overridden using @Interactable.rectChecker.\n         *\n         - element (Element) #optional The element to measure.\n         = (object) The object's bounding rectangle.\n         o {\n         o     top   : 0,\n         o     left  : 0,\n         o     bottom: 0,\n         o     right : 0,\n         o     width : 0,\n         o     height: 0\n         o }\n        \\*/\n        getRect: function rectCheck (element) {\n            element = element || this._element;\n\n            if (this.selector && !(utils.isElement(element))) {\n                element = this._context.querySelector(this.selector);\n            }\n\n            return scope.getElementRect(element);\n        },\n\n        /*\\\n         * Interactable.rectChecker\n         [ method ]\n         *\n         * Returns or sets the function used to calculate the interactable's\n         * element's rectangle\n         *\n         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n         = (function | object) The checker function or this Interactable\n        \\*/\n        rectChecker: function (checker) {\n            if (scope.isFunction(checker)) {\n                this.getRect = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.getRect;\n        },\n\n        /*\\\n         * Interactable.styleCursor\n         [ method ]\n         *\n         * Returns or sets whether the action that would be performed when the\n         * mouse on the element are checked on `mousemove` so that the cursor\n         * may be styled appropriately\n         *\n         - newValue (boolean) #optional\n         = (boolean | Interactable) The current setting or this Interactable\n        \\*/\n        styleCursor: function (newValue) {\n            if (scope.isBool(newValue)) {\n                this.options.styleCursor = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.styleCursor;\n\n                return this;\n            }\n\n            return this.options.styleCursor;\n        },\n\n        /*\\\n         * Interactable.preventDefault\n         [ method ]\n         *\n         * Returns or sets whether to prevent the browser's default behaviour\n         * in response to pointer events. Can be set to:\n         *  - `'always'` to always prevent\n         *  - `'never'` to never prevent\n         *  - `'auto'` to let interact.js try to determine what would be best\n         *\n         - newValue (string) #optional `true`, `false` or `'auto'`\n         = (string | Interactable) The current setting or this Interactable\n        \\*/\n        preventDefault: function (newValue) {\n            if (/^(always|never|auto)$/.test(newValue)) {\n                this.options.preventDefault = newValue;\n                return this;\n            }\n\n            if (scope.isBool(newValue)) {\n                this.options.preventDefault = newValue? 'always' : 'never';\n                return this;\n            }\n\n            return this.options.preventDefault;\n        },\n\n        /*\\\n         * Interactable.origin\n         [ method ]\n         *\n         * Gets or sets the origin of the Interactable's element.  The x and y\n         * of the origin will be subtracted from action event coordinates.\n         *\n         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n         * OR\n         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n         **\n         = (object) The current origin or this Interactable\n        \\*/\n        origin: function (newValue) {\n            if (scope.trySelector(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n            else if (scope.isObject(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n\n            return this.options.origin;\n        },\n\n        /*\\\n         * Interactable.deltaSource\n         [ method ]\n         *\n         * Returns or sets the mouse coordinate types used to calculate the\n         * movement of the pointer.\n         *\n         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n         = (string | object) The current deltaSource or this Interactable\n        \\*/\n        deltaSource: function (newValue) {\n            if (newValue === 'page' || newValue === 'client') {\n                this.options.deltaSource = newValue;\n\n                return this;\n            }\n\n            return this.options.deltaSource;\n        },\n\n        /*\\\n         * Interactable.restrict\n         [ method ]\n         **\n         * Deprecated. Add a `restrict` property to the options object passed to\n         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n         *\n         * Returns or sets the rectangles within which actions on this\n         * interactable (after snap calculations) are restricted. By default,\n         * restricting is relative to the pointer coordinates. You can change\n         * this by setting the\n         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n         **\n         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n         = (object) The current restrictions object or this Interactable\n         **\n         | interact(element).restrict({\n         |     // the rect will be `interact.getElementRect(element.parentNode)`\n         |     drag: element.parentNode,\n         |\n         |     // x and y are relative to the the interactable's origin\n         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n         | })\n         |\n         | interact('.draggable').restrict({\n         |     // the rect will be the selected element's parent\n         |     drag: 'parent',\n         |\n         |     // do not restrict during normal movement.\n         |     // Instead, trigger only one restricted move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n         | });\n        \\*/\n        restrict: function (options) {\n            if (!scope.isObject(options)) {\n                return this.setOptions('restrict', options);\n            }\n\n            var actions = ['drag', 'resize', 'gesture'],\n                ret;\n\n            for (var i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                if (action in options) {\n                    var perAction = utils.extend({\n                            actions: [action],\n                            restriction: options[action]\n                        }, options);\n\n                    ret = this.setOptions('restrict', perAction);\n                }\n            }\n\n            return ret;\n        },\n\n        /*\\\n         * Interactable.context\n         [ method ]\n         *\n         * Gets the selector context Node of the Interactable. The default is `window.document`.\n         *\n         = (Node) The context Node of this Interactable\n         **\n        \\*/\n        context: function () {\n            return this._context;\n        },\n\n        _context: scope.document,\n\n        /*\\\n         * Interactable.ignoreFrom\n         [ method ]\n         *\n         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n         * event or any of it's parents match the given CSS selector or\n         * Element, no drag/resize/gesture is started.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n         = (string | Element | object) The current ignoreFrom value or this Interactable\n         **\n         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n         | // or\n         | interact(element).ignoreFrom('input, textarea, a');\n        \\*/\n        ignoreFrom: function (newValue) {\n            if (scope.trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            if (utils.isElement(newValue)) {              // specific element\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            return this.options.ignoreFrom;\n        },\n\n        /*\\\n         * Interactable.allowFrom\n         [ method ]\n         *\n         * A drag/resize/gesture is started only If the target of the\n         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n         * parents match the given CSS selector or Element.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n         = (string | Element | object) The current allowFrom value or this Interactable\n         **\n         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n         | // or\n         | interact(element).allowFrom('.handle');\n        \\*/\n        allowFrom: function (newValue) {\n            if (scope.trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            if (utils.isElement(newValue)) {              // specific element\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            return this.options.allowFrom;\n        },\n\n        /*\\\n         * Interactable.element\n         [ method ]\n         *\n         * If this is not a selector Interactable, it returns the element this\n         * interactable represents\n         *\n         = (Element) HTML / SVG Element\n        \\*/\n        element: function () {\n            return this._element;\n        },\n\n        /*\\\n         * Interactable.fire\n         [ method ]\n         *\n         * Calls listeners for the given InteractEvent type bound globally\n         * and directly to this Interactable\n         *\n         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n         = (Interactable) this Interactable\n        \\*/\n        fire: function (iEvent) {\n            if (!(iEvent && iEvent.type) || !scope.contains(scope.eventTypes, iEvent.type)) {\n                return this;\n            }\n\n            var listeners,\n                i,\n                len,\n                onEvent = 'on' + iEvent.type,\n                funcName = '';\n\n            // Interactable#on() listeners\n            if (iEvent.type in this._iEvents) {\n                listeners = this._iEvents[iEvent.type];\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            // interactable.onevent listener\n            if (scope.isFunction(this[onEvent])) {\n                funcName = this[onEvent].name;\n                this[onEvent](iEvent);\n            }\n\n            // interact.on() listeners\n            if (iEvent.type in scope.globalEvents && (listeners = scope.globalEvents[iEvent.type]))  {\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.on\n         [ method ]\n         *\n         * Binds a listener for an InteractEvent or DOM event.\n         *\n         - eventType  (string | array | object) The types of events to listen for\n         - listener   (function) The function to be called on the given event(s)\n         - useCapture (boolean) #optional useCapture flag for addEventListener\n         = (object) This Interactable\n        \\*/\n        on: function (eventType, listener, useCapture) {\n            var i;\n\n            if (scope.isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (scope.isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.on(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (scope.isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.on(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            if (eventType === 'wheel') {\n                eventType = scope.wheelEvent;\n            }\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (scope.contains(scope.eventTypes, eventType)) {\n                // if this type of event was never bound to this Interactable\n                if (!(eventType in this._iEvents)) {\n                    this._iEvents[eventType] = [listener];\n                }\n                else {\n                    this._iEvents[eventType].push(listener);\n                }\n            }\n            // delegated event for selector\n            else if (this.selector) {\n                if (!scope.delegatedEvents[eventType]) {\n                    scope.delegatedEvents[eventType] = {\n                        selectors: [],\n                        contexts : [],\n                        listeners: []\n                    };\n\n                    // add delegate listener functions\n                    for (i = 0; i < scope.documents.length; i++) {\n                        events.add(scope.documents[i], eventType, delegateListener);\n                        events.add(scope.documents[i], eventType, delegateUseCapture, true);\n                    }\n                }\n\n                var delegated = scope.delegatedEvents[eventType],\n                    index;\n\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n                        break;\n                    }\n                }\n\n                if (index === -1) {\n                    index = delegated.selectors.length;\n\n                    delegated.selectors.push(this.selector);\n                    delegated.contexts .push(this._context);\n                    delegated.listeners.push([]);\n                }\n\n                // keep listener and useCapture flag\n                delegated.listeners[index].push([listener, useCapture]);\n            }\n            else {\n                events.add(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.off\n         [ method ]\n         *\n         * Removes an InteractEvent or DOM event listener\n         *\n         - eventType  (string | array | object) The types of events that were listened for\n         - listener   (function) The listener function to be removed\n         - useCapture (boolean) #optional useCapture flag for removeEventListener\n         = (object) This Interactable\n        \\*/\n        off: function (eventType, listener, useCapture) {\n            var i;\n\n            if (scope.isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (scope.isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.off(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (scope.isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.off(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            var eventList,\n                index = -1;\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (eventType === 'wheel') {\n                eventType = scope.wheelEvent;\n            }\n\n            // if it is an action event type\n            if (scope.contains(scope.eventTypes, eventType)) {\n                eventList = this._iEvents[eventType];\n\n                if (eventList && (index = scope.indexOf(eventList, listener)) !== -1) {\n                    this._iEvents[eventType].splice(index, 1);\n                }\n            }\n            // delegated event\n            else if (this.selector) {\n                var delegated = scope.delegatedEvents[eventType],\n                    matchFound = false;\n\n                if (!delegated) { return this; }\n\n                // count from last index of delegated to 0\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    // look for matching selector and context Node\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n\n                        var listeners = delegated.listeners[index];\n\n                        // each item of the listeners array is an array: [function, useCaptureFlag]\n                        for (i = listeners.length - 1; i >= 0; i--) {\n                            var fn = listeners[i][0],\n                                useCap = listeners[i][1];\n\n                            // check if the listener functions and useCapture flags match\n                            if (fn === listener && useCap === useCapture) {\n                                // remove the listener from the array of listeners\n                                listeners.splice(i, 1);\n\n                                // if all listeners for this interactable have been removed\n                                // remove the interactable from the delegated arrays\n                                if (!listeners.length) {\n                                    delegated.selectors.splice(index, 1);\n                                    delegated.contexts .splice(index, 1);\n                                    delegated.listeners.splice(index, 1);\n\n                                    // remove delegate function from context\n                                    events.remove(this._context, eventType, delegateListener);\n                                    events.remove(this._context, eventType, delegateUseCapture, true);\n\n                                    // remove the arrays if they are empty\n                                    if (!delegated.selectors.length) {\n                                        scope.delegatedEvents[eventType] = null;\n                                    }\n                                }\n\n                                // only remove one listener\n                                matchFound = true;\n                                break;\n                            }\n                        }\n\n                        if (matchFound) { break; }\n                    }\n                }\n            }\n            // remove listener from this Interatable's element\n            else {\n                events.remove(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.set\n         [ method ]\n         *\n         * Reset the options of this Interactable\n         - options (object) The new settings to apply\n         = (object) This Interactablw\n        \\*/\n        set: function (options) {\n            if (!scope.isObject(options)) {\n                options = {};\n            }\n\n            this.options = utils.extend({}, scope.defaultOptions.base);\n\n            var i,\n                actions = ['drag', 'drop', 'resize', 'gesture'],\n                methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n                perActions = utils.extend(utils.extend({}, scope.defaultOptions.perAction), options[action] || {});\n\n            for (i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                this.options[action] = utils.extend({}, scope.defaultOptions[action]);\n\n                this.setPerAction(action, perActions);\n\n                this[methods[i]](options[action]);\n            }\n\n            var settings = [\n                    'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n                    'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n                    'rectChecker'\n                ];\n\n            for (i = 0, len = settings.length; i < len; i++) {\n                var setting = settings[i];\n\n                this.options[setting] = scope.defaultOptions.base[setting];\n\n                if (setting in options) {\n                    this[setting](options[setting]);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.unset\n         [ method ]\n         *\n         * Remove this interactable from the list of interactables and remove\n         * it's drag, drop, resize and gesture capabilities\n         *\n         = (object) @interact\n        \\*/\n        unset: function () {\n            events.remove(this._element, 'all');\n\n            if (!scope.isString(this.selector)) {\n                events.remove(this, 'all');\n                if (this.options.styleCursor) {\n                    this._element.style.cursor = '';\n                }\n            }\n            else {\n                // remove delegated events\n                for (var type in scope.delegatedEvents) {\n                    var delegated = scope.delegatedEvents[type];\n\n                    for (var i = 0; i < delegated.selectors.length; i++) {\n                        if (delegated.selectors[i] === this.selector\n                            && delegated.contexts[i] === this._context) {\n\n                            delegated.selectors.splice(i, 1);\n                            delegated.contexts .splice(i, 1);\n                            delegated.listeners.splice(i, 1);\n\n                            // remove the arrays if they are empty\n                            if (!delegated.selectors.length) {\n                                scope.delegatedEvents[type] = null;\n                            }\n                        }\n\n                        events.remove(this._context, type, delegateListener);\n                        events.remove(this._context, type, delegateUseCapture, true);\n\n                        break;\n                    }\n                }\n            }\n\n            this.dropzone(false);\n\n            scope.interactables.splice(scope.indexOf(scope.interactables, this), 1);\n\n            return interact;\n        }\n    };\n\n    Interactable.prototype.snap = utils.warnOnce(Interactable.prototype.snap,\n         'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n    Interactable.prototype.restrict = utils.warnOnce(Interactable.prototype.restrict,\n         'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n    Interactable.prototype.inertia = utils.warnOnce(Interactable.prototype.inertia,\n         'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n    Interactable.prototype.autoScroll = utils.warnOnce(Interactable.prototype.autoScroll,\n         'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n    Interactable.prototype.squareResize = utils.warnOnce(Interactable.prototype.squareResize,\n         'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\n    /*\\\n     * interact.isSet\n     [ method ]\n     *\n     * Check if an element has been set\n     - element (Element) The Element being searched for\n     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n    \\*/\n    interact.isSet = function(element, options) {\n        return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n    };\n\n    /*\\\n     * interact.on\n     [ method ]\n     *\n     * Adds a global listener for an InteractEvent or adds a DOM event to\n     * `document`\n     *\n     - type       (string | array | object) The types of events to listen for\n     - listener   (function) The function to be called on the given event(s)\n     - useCapture (boolean) #optional useCapture flag for addEventListener\n     = (object) interact\n    \\*/\n    interact.on = function (type, listener, useCapture) {\n        if (scope.isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (scope.isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.on(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (scope.isObject(type)) {\n            for (var prop in type) {\n                interact.on(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        // if it is an InteractEvent type, add listener to globalEvents\n        if (scope.contains(scope.eventTypes, type)) {\n            // if this type of event was never bound\n            if (!scope.globalEvents[type]) {\n                scope.globalEvents[type] = [listener];\n            }\n            else {\n                scope.globalEvents[type].push(listener);\n            }\n        }\n        // If non InteractEvent type, addEventListener to document\n        else {\n            events.add(scope.document, type, listener, useCapture);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.off\n     [ method ]\n     *\n     * Removes a global InteractEvent listener or DOM event from `document`\n     *\n     - type       (string | array | object) The types of events that were listened for\n     - listener   (function) The listener function to be removed\n     - useCapture (boolean) #optional useCapture flag for removeEventListener\n     = (object) interact\n     \\*/\n    interact.off = function (type, listener, useCapture) {\n        if (scope.isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (scope.isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.off(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (scope.isObject(type)) {\n            for (var prop in type) {\n                interact.off(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        if (!scope.contains(scope.eventTypes, type)) {\n            events.remove(scope.document, type, listener, useCapture);\n        }\n        else {\n            var index;\n\n            if (type in scope.globalEvents\n                && (index = scope.indexOf(scope.globalEvents[type], listener)) !== -1) {\n                scope.globalEvents[type].splice(index, 1);\n            }\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.enableDragging\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether dragging is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableDragging = utils.warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            scope.actionIsEnabled.drag = newValue;\n\n            return interact;\n        }\n        return scope.actionIsEnabled.drag;\n    }, 'interact.enableDragging is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableResizing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether resizing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableResizing = utils.warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            scope.actionIsEnabled.resize = newValue;\n\n            return interact;\n        }\n        return scope.actionIsEnabled.resize;\n    }, 'interact.enableResizing is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableGesturing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether gesturing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableGesturing = utils.warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            scope.actionIsEnabled.gesture = newValue;\n\n            return interact;\n        }\n        return scope.actionIsEnabled.gesture;\n    }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\n    interact.eventTypes = scope.eventTypes;\n\n    /*\\\n     * interact.debug\n     [ method ]\n     *\n     * Returns debugging data\n     = (object) An object with properties that outline the current state and expose internal functions and variables\n    \\*/\n    interact.debug = function () {\n        var interaction = scope.interactions[0] || new Interaction();\n\n        return {\n            interactions          : scope.interactions,\n            target                : interaction.target,\n            dragging              : interaction.dragging,\n            resizing              : interaction.resizing,\n            gesturing             : interaction.gesturing,\n            prepared              : interaction.prepared,\n            matches               : interaction.matches,\n            matchElements         : interaction.matchElements,\n\n            prevCoords            : interaction.prevCoords,\n            startCoords           : interaction.startCoords,\n\n            pointerIds            : interaction.pointerIds,\n            pointers              : interaction.pointers,\n            addPointer            : scope.listeners.addPointer,\n            removePointer         : scope.listeners.removePointer,\n            recordPointer         : scope.listeners.recordPointer,\n\n            snap                  : interaction.snapStatus,\n            restrict              : interaction.restrictStatus,\n            inertia               : interaction.inertiaStatus,\n\n            downTime              : interaction.downTimes[0],\n            downEvent             : interaction.downEvent,\n            downPointer           : interaction.downPointer,\n            prevEvent             : interaction.prevEvent,\n\n            Interactable          : Interactable,\n            interactables         : scope.interactables,\n            pointerIsDown         : interaction.pointerIsDown,\n            defaultOptions        : scope.defaultOptions,\n            defaultActionChecker  : defaultActionChecker,\n\n            actionCursors         : scope.actionCursors,\n            dragMove              : scope.listeners.dragMove,\n            resizeMove            : scope.listeners.resizeMove,\n            gestureMove           : scope.listeners.gestureMove,\n            pointerUp             : scope.listeners.pointerUp,\n            pointerDown           : scope.listeners.pointerDown,\n            pointerMove           : scope.listeners.pointerMove,\n            pointerHover          : scope.listeners.pointerHover,\n\n            eventTypes            : scope.eventTypes,\n\n            events                : events,\n            globalEvents          : scope.globalEvents,\n            delegatedEvents       : scope.delegatedEvents\n        };\n    };\n\n    // expose the functions used to calculate multi-touch properties\n    interact.getTouchAverage  = utils.touchAverage;\n    interact.getTouchBBox     = utils.touchBBox;\n    interact.getTouchDistance = utils.touchDistance;\n    interact.getTouchAngle    = utils.touchAngle;\n\n    interact.getElementRect   = scope.getElementRect;\n    interact.matchesSelector  = scope.matchesSelector;\n    interact.closest          = scope.closest;\n\n    /*\\\n     * interact.margin\n     [ method ]\n     *\n     * Returns or sets the margin for autocheck resizing used in\n     * @Interactable.getAction. That is the distance from the bottom and right\n     * edges of an element clicking in which will start resizing\n     *\n     - newValue (number) #optional\n     = (number | interact) The current margin value or interact\n    \\*/\n    interact.margin = function (newvalue) {\n        if (scope.isNumber(newvalue)) {\n            scope.margin = newvalue;\n\n            return interact;\n        }\n        return scope.margin;\n    };\n\n    /*\\\n     * interact.supportsTouch\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports touch input\n    \\*/\n    interact.supportsTouch = function () {\n        return browser.supportsTouch;\n    };\n\n    /*\\\n     * interact.supportsPointerEvent\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports PointerEvents\n    \\*/\n    interact.supportsPointerEvent = function () {\n        return browser.supportsPointerEvent;\n    };\n\n    /*\\\n     * interact.stop\n     [ method ]\n     *\n     * Cancels all interactions (end events are not fired)\n     *\n     - event (Event) An event on which to call preventDefault()\n     = (object) interact\n    \\*/\n    interact.stop = function (event) {\n        for (var i = scope.interactions.length - 1; i > 0; i--) {\n            scope.interactions[i].stop(event);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.dynamicDrop\n     [ method ]\n     *\n     * Returns or sets whether the dimensions of dropzone elements are\n     * calculated on every dragmove or only on dragstart for the default\n     * dropChecker\n     *\n     - newValue (boolean) #optional True to check on each move. False to check only before start\n     = (boolean | interact) The current setting or interact\n    \\*/\n    interact.dynamicDrop = function (newValue) {\n        if (scope.isBool(newValue)) {\n            //if (dragging && dynamicDrop !== newValue && !newValue) {\n                //calcRects(dropzones);\n            //}\n\n            scope.dynamicDrop = newValue;\n\n            return interact;\n        }\n        return scope.dynamicDrop;\n    };\n\n    /*\\\n     * interact.pointerMoveTolerance\n     [ method ]\n     * Returns or sets the distance the pointer must be moved before an action\n     * sequence occurs. This also affects tolerance for tap events.\n     *\n     - newValue (number) #optional The movement from the start position must be greater than this value\n     = (number | Interactable) The current setting or interact\n    \\*/\n    interact.pointerMoveTolerance = function (newValue) {\n        if (scope.isNumber(newValue)) {\n            scope.pointerMoveTolerance = newValue;\n\n            return this;\n        }\n\n        return scope.pointerMoveTolerance;\n    };\n\n    /*\\\n     * interact.maxInteractions\n     [ method ]\n     **\n     * Returns or sets the maximum number of concurrent interactions allowed.\n     * By default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables\n     * and elements, you need to enable it in the draggable, resizable and\n     * gesturable `'max'` and `'maxPerElement'` options.\n     **\n     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n    \\*/\n    interact.maxInteractions = function (newValue) {\n        if (scope.isNumber(newValue)) {\n            scope.maxInteractions = newValue;\n\n            return this;\n        }\n\n        return scope.maxInteractions;\n    };\n\n    interact.createSnapGrid = function (grid) {\n        return function (x, y) {\n            var offsetX = 0,\n                offsetY = 0;\n\n            if (scope.isObject(grid.offset)) {\n                offsetX = grid.offset.x;\n                offsetY = grid.offset.y;\n            }\n\n            var gridx = Math.round((x - offsetX) / grid.x),\n                gridy = Math.round((y - offsetY) / grid.y),\n\n                newX = gridx * grid.x + offsetX,\n                newY = gridy * grid.y + offsetY;\n\n            return {\n                x: newX,\n                y: newY,\n                range: grid.range\n            };\n        };\n    };\n\n    function endAllInteractions (event) {\n        for (var i = 0; i < scope.interactions.length; i++) {\n            scope.interactions[i].pointerEnd(event, event);\n        }\n    }\n\n    function listenToDocument (doc) {\n        if (scope.contains(scope.documents, doc)) { return; }\n\n        var win = doc.defaultView || doc.parentWindow;\n\n        // add delegate event listener\n        for (var eventType in scope.delegatedEvents) {\n            events.add(doc, eventType, delegateListener);\n            events.add(doc, eventType, delegateUseCapture, true);\n        }\n\n        if (scope.PointerEvent) {\n            if (scope.PointerEvent === win.MSPointerEvent) {\n                scope.pEventTypes = {\n                    up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n                    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n            }\n            else {\n                scope.pEventTypes = {\n                    up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n                    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n            }\n\n            events.add(doc, scope.pEventTypes.down  , scope.listeners.selectorDown );\n            events.add(doc, scope.pEventTypes.move  , scope.listeners.pointerMove  );\n            events.add(doc, scope.pEventTypes.over  , scope.listeners.pointerOver  );\n            events.add(doc, scope.pEventTypes.out   , scope.listeners.pointerOut   );\n            events.add(doc, scope.pEventTypes.up    , scope.listeners.pointerUp    );\n            events.add(doc, scope.pEventTypes.cancel, scope.listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, scope.pEventTypes.move, scope.listeners.autoScrollMove);\n        }\n        else {\n            events.add(doc, 'mousedown', scope.listeners.selectorDown);\n            events.add(doc, 'mousemove', scope.listeners.pointerMove );\n            events.add(doc, 'mouseup'  , scope.listeners.pointerUp   );\n            events.add(doc, 'mouseover', scope.listeners.pointerOver );\n            events.add(doc, 'mouseout' , scope.listeners.pointerOut  );\n\n            events.add(doc, 'touchstart' , scope.listeners.selectorDown );\n            events.add(doc, 'touchmove'  , scope.listeners.pointerMove  );\n            events.add(doc, 'touchend'   , scope.listeners.pointerUp    );\n            events.add(doc, 'touchcancel', scope.listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, 'mousemove', scope.listeners.autoScrollMove);\n            events.add(doc, 'touchmove', scope.listeners.autoScrollMove);\n        }\n\n        events.add(win, 'blur', endAllInteractions);\n\n        try {\n            if (win.frameElement) {\n                var parentDoc = win.frameElement.ownerDocument,\n                    parentWindow = parentDoc.defaultView;\n\n                events.add(parentDoc   , 'mouseup'      , scope.listeners.pointerEnd);\n                events.add(parentDoc   , 'touchend'     , scope.listeners.pointerEnd);\n                events.add(parentDoc   , 'touchcancel'  , scope.listeners.pointerEnd);\n                events.add(parentDoc   , 'pointerup'    , scope.listeners.pointerEnd);\n                events.add(parentDoc   , 'MSPointerUp'  , scope.listeners.pointerEnd);\n                events.add(parentWindow, 'blur'         , endAllInteractions );\n            }\n        }\n        catch (error) {\n            interact.windowParentError = error;\n        }\n\n        if (events.useAttachEvent) {\n            // For IE's lack of Event#preventDefault\n            events.add(doc, 'selectstart', function (event) {\n                var interaction = scope.interactions[0];\n\n                if (interaction.currentAction()) {\n                    interaction.checkAndPreventDefault(event);\n                }\n            });\n\n            // For IE's bad dblclick event sequence\n            events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n        }\n\n        scope.documents.push(doc);\n    }\n\n    listenToDocument(scope.document);\n\n    scope.interact = interact;\n    scope.Interactable = Interactable;\n    scope.Interaction = Interaction;\n    scope.InteractEvent = InteractEvent;\n\n    module.exports = interact;\n\n},{\"./InteractEvent\":2,\"./Interaction\":3,\"./autoScroll\":4,\"./defaultOptions\":5,\"./scope\":6,\"./utils\":13,\"./utils/events\":10,\"./utils/window\":18}],2:[function(require,module,exports){\n'use strict';\n\nvar scope = require('./scope');\nvar utils = require('./utils');\n\nfunction InteractEvent (interaction, event, action, phase, element, related) {\n    var client,\n        page,\n        target      = interaction.target,\n        snapStatus  = interaction.snapStatus,\n        restrictStatus  = interaction.restrictStatus,\n        pointers    = interaction.pointers,\n        deltaSource = (target && target.options || scope.defaultOptions).deltaSource,\n        sourceX     = deltaSource + 'X',\n        sourceY     = deltaSource + 'Y',\n        options     = target? target.options: scope.defaultOptions,\n        origin      = scope.getOriginXY(target, element),\n        starting    = phase === 'start',\n        ending      = phase === 'end',\n        coords      = starting? interaction.startCoords : interaction.curCoords;\n\n    element = element || interaction.element;\n\n    page   = utils.extend({}, coords.page);\n    client = utils.extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    var relativePoints = options[action].snap && options[action].snap.relativePoints ;\n\n    if (scope.checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n        this.snap = {\n            range  : snapStatus.range,\n            locked : snapStatus.locked,\n            x      : snapStatus.snappedX,\n            y      : snapStatus.snappedY,\n            realX  : snapStatus.realX,\n            realY  : snapStatus.realY,\n            dx     : snapStatus.dx,\n            dy     : snapStatus.dy\n        };\n\n        if (snapStatus.locked) {\n            page.x += snapStatus.dx;\n            page.y += snapStatus.dy;\n            client.x += snapStatus.dx;\n            client.y += snapStatus.dy;\n        }\n    }\n\n    if (scope.checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n        page.x += restrictStatus.dx;\n        page.y += restrictStatus.dy;\n        client.x += restrictStatus.dx;\n        client.y += restrictStatus.dy;\n\n        this.restrict = {\n            dx: restrictStatus.dx,\n            dy: restrictStatus.dy\n        };\n    }\n\n    this.pageX     = page.x;\n    this.pageY     = page.y;\n    this.clientX   = client.x;\n    this.clientY   = client.y;\n\n    this.x0        = interaction.startCoords.page.x - origin.x;\n    this.y0        = interaction.startCoords.page.y - origin.y;\n    this.clientX0  = interaction.startCoords.client.x - origin.x;\n    this.clientY0  = interaction.startCoords.client.y - origin.y;\n    this.ctrlKey   = event.ctrlKey;\n    this.altKey    = event.altKey;\n    this.shiftKey  = event.shiftKey;\n    this.metaKey   = event.metaKey;\n    this.button    = event.button;\n    this.target    = element;\n    this.t0        = interaction.downTimes[0];\n    this.type      = action + (phase || '');\n\n    this.interaction = interaction;\n    this.interactable = target;\n\n    var inertiaStatus = interaction.inertiaStatus;\n\n    if (inertiaStatus.active) {\n        this.detail = 'inertia';\n    }\n\n    if (related) {\n        this.relatedTarget = related;\n    }\n\n    // end event dx, dy is difference between start and end points\n    if (ending) {\n        if (deltaSource === 'client') {\n            this.dx = client.x - interaction.startCoords.client.x;\n            this.dy = client.y - interaction.startCoords.client.y;\n        }\n        else {\n            this.dx = page.x - interaction.startCoords.page.x;\n            this.dy = page.y - interaction.startCoords.page.y;\n        }\n    }\n    else if (starting) {\n        this.dx = 0;\n        this.dy = 0;\n    }\n    // copy properties from previousmove if starting inertia\n    else if (phase === 'inertiastart') {\n        this.dx = interaction.prevEvent.dx;\n        this.dy = interaction.prevEvent.dy;\n    }\n    else {\n        if (deltaSource === 'client') {\n            this.dx = client.x - interaction.prevEvent.clientX;\n            this.dy = client.y - interaction.prevEvent.clientY;\n        }\n        else {\n            this.dx = page.x - interaction.prevEvent.pageX;\n            this.dy = page.y - interaction.prevEvent.pageY;\n        }\n    }\n    if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n        && !inertiaStatus.active\n        && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\n        inertiaStatus.resumeDx += this.dx;\n        inertiaStatus.resumeDy += this.dy;\n\n        this.dx = this.dy = 0;\n    }\n\n    if (action === 'resize' && interaction.resizeAxes) {\n        if (options.resize.square) {\n            if (interaction.resizeAxes === 'y') {\n                this.dx = this.dy;\n            }\n            else {\n                this.dy = this.dx;\n            }\n            this.axes = 'xy';\n        }\n        else {\n            this.axes = interaction.resizeAxes;\n\n            if (interaction.resizeAxes === 'x') {\n                this.dy = 0;\n            }\n            else if (interaction.resizeAxes === 'y') {\n                this.dx = 0;\n            }\n        }\n    }\n    else if (action === 'gesture') {\n        this.touches = [pointers[0], pointers[1]];\n\n        if (starting) {\n            this.distance = utils.touchDistance(pointers, deltaSource);\n            this.box      = utils.touchBBox(pointers);\n            this.scale    = 1;\n            this.ds       = 0;\n            this.angle    = utils.touchAngle(pointers, undefined, deltaSource);\n            this.da       = 0;\n        }\n        else if (ending || event instanceof InteractEvent) {\n            this.distance = interaction.prevEvent.distance;\n            this.box      = interaction.prevEvent.box;\n            this.scale    = interaction.prevEvent.scale;\n            this.ds       = this.scale - 1;\n            this.angle    = interaction.prevEvent.angle;\n            this.da       = this.angle - interaction.gesture.startAngle;\n        }\n        else {\n            this.distance = utils.touchDistance(pointers, deltaSource);\n            this.box      = utils.touchBBox(pointers);\n            this.scale    = this.distance / interaction.gesture.startDistance;\n            this.angle    = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n            this.ds = this.scale - interaction.gesture.prevScale;\n            this.da = this.angle - interaction.gesture.prevAngle;\n        }\n    }\n\n    if (starting) {\n        this.timeStamp = interaction.downTimes[0];\n        this.dt        = 0;\n        this.duration  = 0;\n        this.speed     = 0;\n        this.velocityX = 0;\n        this.velocityY = 0;\n    }\n    else if (phase === 'inertiastart') {\n        this.timeStamp = interaction.prevEvent.timeStamp;\n        this.dt        = interaction.prevEvent.dt;\n        this.duration  = interaction.prevEvent.duration;\n        this.speed     = interaction.prevEvent.speed;\n        this.velocityX = interaction.prevEvent.velocityX;\n        this.velocityY = interaction.prevEvent.velocityY;\n    }\n    else {\n        this.timeStamp = new Date().getTime();\n        this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n        this.duration  = this.timeStamp - interaction.downTimes[0];\n\n        if (event instanceof InteractEvent) {\n            var dx = this[sourceX] - interaction.prevEvent[sourceX],\n                dy = this[sourceY] - interaction.prevEvent[sourceY],\n                dt = this.dt / 1000;\n\n            this.speed = utils.hypot(dx, dy) / dt;\n            this.velocityX = dx / dt;\n            this.velocityY = dy / dt;\n        }\n        // if normal move or end event, use previous user event coords\n        else {\n            // speed and velocity in pixels per second\n            this.speed = interaction.pointerDelta[deltaSource].speed;\n            this.velocityX = interaction.pointerDelta[deltaSource].vx;\n            this.velocityY = interaction.pointerDelta[deltaSource].vy;\n        }\n    }\n\n    if ((ending || phase === 'inertiastart')\n        && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n        var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n            overlap = 22.5;\n\n        if (angle < 0) {\n            angle += 360;\n        }\n\n        var left = 135 - overlap <= angle && angle < 225 + overlap,\n            up   = 225 - overlap <= angle && angle < 315 + overlap,\n\n            right = !left && (315 - overlap <= angle || angle <  45 + overlap),\n            down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n        this.swipe = {\n            up   : up,\n            down : down,\n            left : left,\n            right: right,\n            angle: angle,\n            speed: interaction.prevEvent.speed,\n            velocity: {\n                x: interaction.prevEvent.velocityX,\n                y: interaction.prevEvent.velocityY\n            }\n        };\n    }\n}\n\nInteractEvent.prototype = {\n    preventDefault: utils.blank,\n    stopImmediatePropagation: function () {\n        this.immediatePropagationStopped = this.propagationStopped = true;\n    },\n    stopPropagation: function () {\n        this.propagationStopped = true;\n    }\n};\n\nmodule.exports = InteractEvent;\n\n},{\"./scope\":6,\"./utils\":13}],3:[function(require,module,exports){\n'use strict';\n\nvar scope = require('./scope');\nvar utils = require('./utils');\nvar animationFrame = utils.raf;\nvar InteractEvent = require('./InteractEvent');\nvar events = require('./utils/events');\nvar browser = require('./utils/browser');\n\nfunction Interaction () {\n    this.target          = null; // current interactable being interacted with\n    this.element         = null; // the target element of the interactable\n    this.dropTarget      = null; // the dropzone a drag target might be dropped into\n    this.dropElement     = null; // the element at the time of checking\n    this.prevDropTarget  = null; // the dropzone that was recently dragged away from\n    this.prevDropElement = null; // the element at the time of checking\n\n    this.prepared        = {     // action that's ready to be fired on next move event\n        name : null,\n        axis : null,\n        edges: null\n    };\n\n    this.matches         = [];   // all selectors that are matched by target element\n    this.matchElements   = [];   // corresponding elements\n\n    this.inertiaStatus = {\n        active       : false,\n        smoothEnd    : false,\n\n        startEvent: null,\n        upCoords: {},\n\n        xe: 0, ye: 0,\n        sx: 0, sy: 0,\n\n        t0: 0,\n        vx0: 0, vys: 0,\n        duration: 0,\n\n        resumeDx: 0,\n        resumeDy: 0,\n\n        lambda_v0: 0,\n        one_ve_v0: 0,\n        i  : null\n    };\n\n    if (scope.isFunction(Function.prototype.bind)) {\n        this.boundInertiaFrame = this.inertiaFrame.bind(this);\n        this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n    }\n    else {\n        var that = this;\n\n        this.boundInertiaFrame = function () { return that.inertiaFrame(); };\n        this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };\n    }\n\n    this.activeDrops = {\n        dropzones: [],      // the dropzones that are mentioned below\n        elements : [],      // elements of dropzones that accept the target draggable\n        rects    : []       // the rects of the elements mentioned above\n    };\n\n    // keep track of added pointers\n    this.pointers    = [];\n    this.pointerIds  = [];\n    this.downTargets = [];\n    this.downTimes   = [];\n    this.holdTimers  = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n        page     : { x: 0, y: 0 },\n        client   : { x: 0, y: 0 },\n        timeStamp: 0\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n        page     : { x: 0, y: 0 },\n        client   : { x: 0, y: 0 },\n        timeStamp: 0\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n        page     : { x: 0, y: 0 },\n        client   : { x: 0, y: 0 },\n        timeStamp: 0\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n        page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n        client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n        timeStamp: 0\n    };\n\n    this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget    = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null;      // previous action event\n    this.tapTime   = 0;         // time of the most recent tap event\n    this.prevTap   = null;\n\n    this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };\n    this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n    this.snapOffsets    = [];\n\n    this.gesture = {\n        start: { x: 0, y: 0 },\n\n        startDistance: 0,   // distance between two touches of touchStart\n        prevDistance : 0,\n        distance     : 0,\n\n        scale: 1,           // gesture.distance / gesture.startDistance\n\n        startAngle: 0,      // angle of line joining two touches\n        prevAngle : 0       // angle of the previous gesture event\n    };\n\n    this.snapStatus = {\n        x       : 0, y       : 0,\n        dx      : 0, dy      : 0,\n        realX   : 0, realY   : 0,\n        snappedX: 0, snappedY: 0,\n        targets : [],\n        locked  : false,\n        changed : false\n    };\n\n    this.restrictStatus = {\n        dx         : 0, dy         : 0,\n        restrictedX: 0, restrictedY: 0,\n        snap       : null,\n        restricted : false,\n        changed    : false\n    };\n\n    this.restrictStatus.snap = this.snapStatus;\n\n    this.pointerIsDown   = false;\n    this.pointerWasMoved = false;\n    this.gesturing       = false;\n    this.dragging        = false;\n    this.resizing        = false;\n    this.resizeAxes      = 'xy';\n\n    this.mouse = false;\n\n    scope.interactions.push(this);\n}\n\n// Check if action is enabled globally and the current target supports it\n// If so, return the validated action. Otherwise, return null\nfunction validateAction (action, interactable) {\n    if (!scope.isObject(action)) { return null; }\n\n    var actionName = action.name,\n        options = interactable.options;\n\n    if ((  (actionName  === 'resize'   && options.resize.enabled )\n        || (actionName      === 'drag'     && options.drag.enabled  )\n        || (actionName      === 'gesture'  && options.gesture.enabled))\n        && scope.actionIsEnabled[actionName]) {\n\n        if (actionName === 'resize' || actionName === 'resizeyx') {\n            actionName = 'resizexy';\n        }\n\n        return action;\n    }\n    return null;\n}\n\nfunction getActionCursor (action) {\n    var cursor = '';\n\n    if (action.name === 'drag') {\n        cursor =  scope.actionCursors.drag;\n    }\n    if (action.name === 'resize') {\n        if (action.axis) {\n            cursor =  scope.actionCursors[action.name + action.axis];\n        }\n        else if (action.edges) {\n            var cursorKey = 'resize',\n                edgeNames = ['top', 'bottom', 'left', 'right'];\n\n            for (var i = 0; i < 4; i++) {\n                if (action.edges[edgeNames[i]]) {\n                    cursorKey += edgeNames[i];\n                }\n            }\n\n            cursor = scope.actionCursors[cursorKey];\n        }\n    }\n\n    return cursor;\n}\n\nfunction preventOriginalDefault () {\n    this.originalEvent.preventDefault();\n}\n\nInteraction.prototype = {\n    getPageXY  : function (pointer, xy) { return   utils.getPageXY(pointer, xy, this); },\n    getClientXY: function (pointer, xy) { return utils.getClientXY(pointer, xy, this); },\n    setEventXY : function (target, ptr) { return  utils.setEventXY(target, ptr, this); },\n\n    pointerOver: function (pointer, event, eventTarget) {\n        if (this.prepared.name || !this.mouse) { return; }\n\n        var curMatches = [],\n            curMatchElements = [],\n            prevTargetElement = this.element;\n\n        this.addPointer(pointer);\n\n        if (this.target\n            && (scope.testIgnore(this.target, this.element, eventTarget)\n            || !scope.testAllow(this.target, this.element, eventTarget))) {\n            // if the eventTarget should be ignored or shouldn't be allowed\n            // clear the previous target\n            this.target = null;\n            this.element = null;\n            this.matches = [];\n            this.matchElements = [];\n        }\n\n        var elementInteractable = scope.interactables.get(eventTarget),\n            elementAction = (elementInteractable\n            && !scope.testIgnore(elementInteractable, eventTarget, eventTarget)\n            && scope.testAllow(elementInteractable, eventTarget, eventTarget)\n            && validateAction(\n                elementInteractable.getAction(pointer, event, this, eventTarget),\n                elementInteractable));\n\n        if (elementAction && !scope.withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n            elementAction = null;\n        }\n\n        function pushCurMatches (interactable, selector) {\n            if (interactable\n                && scope.inContext(interactable, eventTarget)\n                && !scope.testIgnore(interactable, eventTarget, eventTarget)\n                && scope.testAllow(interactable, eventTarget, eventTarget)\n                && scope.matchesSelector(eventTarget, selector)) {\n\n                curMatches.push(interactable);\n                curMatchElements.push(eventTarget);\n            }\n        }\n\n        if (elementAction) {\n            this.target = elementInteractable;\n            this.element = eventTarget;\n            this.matches = [];\n            this.matchElements = [];\n        }\n        else {\n            scope.interactables.forEachSelector(pushCurMatches);\n\n            if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n                this.matches = curMatches;\n                this.matchElements = curMatchElements;\n\n                this.pointerHover(pointer, event, this.matches, this.matchElements);\n                events.add(eventTarget,\n                    scope.PointerEvent? scope.pEventTypes.move : 'mousemove',\n                    scope.listeners.pointerHover);\n            }\n            else if (this.target) {\n                if (scope.nodeContains(prevTargetElement, eventTarget)) {\n                    this.pointerHover(pointer, event, this.matches, this.matchElements);\n                    events.add(this.element,\n                        scope.PointerEvent? scope.pEventTypes.move : 'mousemove',\n                        scope.listeners.pointerHover);\n                }\n                else {\n                    this.target = null;\n                    this.element = null;\n                    this.matches = [];\n                    this.matchElements = [];\n                }\n            }\n        }\n    },\n\n    // Check what action would be performed on pointerMove target if a mouse\n    // button were pressed and change the cursor accordingly\n    pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n        var target = this.target;\n\n        if (!this.prepared.name && this.mouse) {\n\n            var action;\n\n            // update pointer coords for defaultActionChecker to use\n            this.setEventXY(this.curCoords, pointer);\n\n            if (matches) {\n                action = this.validateSelector(pointer, event, matches, matchElements);\n            }\n            else if (target) {\n                action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n            }\n\n            if (target && target.options.styleCursor) {\n                if (action) {\n                    target._doc.documentElement.style.cursor = getActionCursor(action);\n                }\n                else {\n                    target._doc.documentElement.style.cursor = '';\n                }\n            }\n        }\n        else if (this.prepared.name) {\n            this.checkAndPreventDefault(event, target, this.element);\n        }\n    },\n\n    pointerOut: function (pointer, event, eventTarget) {\n        if (this.prepared.name) { return; }\n\n        // Remove temporary event listeners for selector Interactables\n        if (!scope.interactables.get(eventTarget)) {\n            events.remove(eventTarget,\n                scope.PointerEvent? scope.pEventTypes.move : 'mousemove',\n                scope.listeners.pointerHover);\n        }\n\n        if (this.target && this.target.options.styleCursor && !this.interacting()) {\n            this.target._doc.documentElement.style.cursor = '';\n        }\n    },\n\n    selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n        var that = this,\n        // copy event to be used in timeout for IE8\n            eventCopy = events.useAttachEvent? utils.extend({}, event) : event,\n            element = eventTarget,\n            pointerIndex = this.addPointer(pointer),\n            action;\n\n        this.holdTimers[pointerIndex] = setTimeout(function () {\n            that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n        }, scope.defaultOptions._holdDuration);\n\n        this.pointerIsDown = true;\n\n        // Check if the down event hits the current inertia target\n        if (this.inertiaStatus.active && this.target.selector) {\n            // climb up the DOM tree from the event target\n            while (utils.isElement(element)) {\n\n                // if this element is the current inertia target element\n                if (element === this.element\n                        // and the prospective action is the same as the ongoing one\n                    && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\n                    // stop inertia so that the next move will be a normal one\n                    animationFrame.cancel(this.inertiaStatus.i);\n                    this.inertiaStatus.active = false;\n\n                    this.collectEventTargets(pointer, event, eventTarget, 'down');\n                    return;\n                }\n                element = scope.parentElement(element);\n            }\n        }\n\n        // do nothing if interacting\n        if (this.interacting()) {\n            this.collectEventTargets(pointer, event, eventTarget, 'down');\n            return;\n        }\n\n        function pushMatches (interactable, selector, context) {\n            var elements = scope.ie8MatchesSelector\n                ? context.querySelectorAll(selector)\n                : undefined;\n\n            if (scope.inContext(interactable, element)\n                && !scope.testIgnore(interactable, element, eventTarget)\n                && scope.testAllow(interactable, element, eventTarget)\n                && scope.matchesSelector(element, selector, elements)) {\n\n                that.matches.push(interactable);\n                that.matchElements.push(element);\n            }\n        }\n\n        // update pointer coords for defaultActionChecker to use\n        this.setEventXY(this.curCoords, pointer);\n        this.downEvent = event;\n\n        while (utils.isElement(element) && !action) {\n            this.matches = [];\n            this.matchElements = [];\n\n            scope.interactables.forEachSelector(pushMatches);\n\n            action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n            element = scope.parentElement(element);\n        }\n\n        if (action) {\n            this.prepared.name  = action.name;\n            this.prepared.axis  = action.axis;\n            this.prepared.edges = action.edges;\n\n            this.collectEventTargets(pointer, event, eventTarget, 'down');\n\n            return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n        }\n        else {\n            // do these now since pointerDown isn't being called from here\n            this.downTimes[pointerIndex] = new Date().getTime();\n            this.downTargets[pointerIndex] = eventTarget;\n            utils.extend(this.downPointer, pointer);\n\n            utils.copyCoords(this.prevCoords, this.curCoords);\n            this.pointerWasMoved = false;\n        }\n\n        this.collectEventTargets(pointer, event, eventTarget, 'down');\n    },\n\n    // Determine action to be performed on next pointerMove and add appropriate\n    // style and event Listeners\n    pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n        if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n            this.checkAndPreventDefault(event, this.target, this.element);\n\n            return;\n        }\n\n        this.pointerIsDown = true;\n        this.downEvent = event;\n\n        var pointerIndex = this.addPointer(pointer),\n            action;\n\n        // If it is the second touch of a multi-touch gesture, keep the target\n        // the same if a target was set by the first touch\n        // Otherwise, set the target if there is no action prepared\n        if ((this.pointerIds.length < 2 && !this.target) || !this.prepared.name) {\n\n            var interactable = scope.interactables.get(curEventTarget);\n\n            if (interactable\n                && !scope.testIgnore(interactable, curEventTarget, eventTarget)\n                && scope.testAllow(interactable, curEventTarget, eventTarget)\n                && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n                && scope.withinInteractionLimit(interactable, curEventTarget, action)) {\n                this.target = interactable;\n                this.element = curEventTarget;\n            }\n        }\n\n        var target = this.target,\n            options = target && target.options;\n\n        if (target && (forceAction || !this.prepared.name)) {\n            action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\n            this.setEventXY(this.startCoords);\n\n            if (!action) { return; }\n\n            if (options.styleCursor) {\n                target._doc.documentElement.style.cursor = getActionCursor(action);\n            }\n\n            this.resizeAxes = action.name === 'resize'? action.axis : null;\n\n            if (action === 'gesture' && this.pointerIds.length < 2) {\n                action = null;\n            }\n\n            this.prepared.name  = action.name;\n            this.prepared.axis  = action.axis;\n            this.prepared.edges = action.edges;\n\n            this.snapStatus.snappedX = this.snapStatus.snappedY =\n                this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\n            this.downTimes[pointerIndex] = new Date().getTime();\n            this.downTargets[pointerIndex] = eventTarget;\n            utils.extend(this.downPointer, pointer);\n\n            this.setEventXY(this.prevCoords);\n            this.pointerWasMoved = false;\n\n            this.checkAndPreventDefault(event, target, this.element);\n        }\n        // if inertia is active try to resume action\n        else if (this.inertiaStatus.active\n            && curEventTarget === this.element\n            && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\n            animationFrame.cancel(this.inertiaStatus.i);\n            this.inertiaStatus.active = false;\n\n            this.checkAndPreventDefault(event, target, this.element);\n        }\n    },\n\n    setModifications: function (coords, preEnd) {\n        var target         = this.target,\n            shouldMove     = true,\n            shouldSnap     = scope.checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),\n            shouldRestrict = scope.checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\n        if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }\n        if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }\n\n        if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n            shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n        }\n        else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n            shouldMove = false;\n        }\n\n        return shouldMove;\n    },\n\n    setStartOffsets: function (action, interactable, element) {\n        var rect = interactable.getRect(element),\n            origin = scope.getOriginXY(interactable, element),\n            snap = interactable.options[this.prepared.name].snap,\n            restrict = interactable.options[this.prepared.name].restrict,\n            width, height;\n\n        if (rect) {\n            this.startOffset.left = this.startCoords.page.x - rect.left;\n            this.startOffset.top  = this.startCoords.page.y - rect.top;\n\n            this.startOffset.right  = rect.right  - this.startCoords.page.x;\n            this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n            if ('width' in rect) { width = rect.width; }\n            else { width = rect.right - rect.left; }\n            if ('height' in rect) { height = rect.height; }\n            else { height = rect.bottom - rect.top; }\n        }\n        else {\n            this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n        }\n\n        this.snapOffsets.splice(0);\n\n        var snapOffset = snap && snap.offset === 'startCoords'\n            ? {\n            x: this.startCoords.page.x - origin.x,\n            y: this.startCoords.page.y - origin.y\n        }\n            : snap && snap.offset || { x: 0, y: 0 };\n\n        if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n            for (var i = 0; i < snap.relativePoints.length; i++) {\n                this.snapOffsets.push({\n                    x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,\n                    y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y\n                });\n            }\n        }\n        else {\n            this.snapOffsets.push(snapOffset);\n        }\n\n        if (rect && restrict.elementRect) {\n            this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);\n            this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);\n\n            this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));\n            this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));\n        }\n        else {\n            this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n        }\n    },\n\n    /*\\\n     * Interaction.start\n     [ method ]\n     *\n     * Start an action with the given Interactable and Element as tartgets. The\n     * action must be enabled for the target Interactable and an appropriate number\n     * of pointers must be held down – 1 for drag/resize, 2 for gesture.\n     *\n     * Use it with `interactable.<action>able({ manualStart: false })` to always\n     * [start actions manually](https://github.com/taye/interact.js/issues/114)\n     *\n     - action       (object)  The action to be performed - drag, resize, etc.\n     - interactable (Interactable) The Interactable to target\n     - element      (Element) The DOM Element to target\n     = (object) interact\n     **\n     | interact(target)\n     |   .draggable({\n     |     // disable the default drag start by down->move\n     |     manualStart: true\n     |   })\n     |   // start dragging after the user holds the pointer down\n     |   .on('hold', function (event) {\n     |     var interaction = event.interaction;\n     |\n     |     if (!interaction.interacting()) {\n     |       interaction.start({ name: 'drag' },\n     |                         event.interactable,\n     |                         event.currentTarget);\n     |     }\n     | });\n     \\*/\n    start: function (action, interactable, element) {\n        if (this.interacting()\n            || !this.pointerIsDown\n            || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n            return;\n        }\n\n        // if this interaction had been removed after stopping\n        // add it back\n        if (scope.indexOf(scope.interactions, this) === -1) {\n            scope.interactions.push(this);\n        }\n\n        this.prepared.name  = action.name;\n        this.prepared.axis  = action.axis;\n        this.prepared.edges = action.edges;\n        this.target         = interactable;\n        this.element        = element;\n\n        this.setEventXY(this.startCoords);\n        this.setStartOffsets(action.name, interactable, element);\n        this.setModifications(this.startCoords.page);\n\n        this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n    },\n\n    pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n        this.recordPointer(pointer);\n\n        this.setEventXY(this.curCoords, (pointer instanceof InteractEvent)\n            ? this.inertiaStatus.startEvent\n            : undefined);\n\n        var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n        && this.curCoords.page.y === this.prevCoords.page.y\n        && this.curCoords.client.x === this.prevCoords.client.x\n        && this.curCoords.client.y === this.prevCoords.client.y);\n\n        var dx, dy,\n            pointerIndex = this.mouse? 0 : scope.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n        // register movement greater than pointerMoveTolerance\n        if (this.pointerIsDown && !this.pointerWasMoved) {\n            dx = this.curCoords.client.x - this.startCoords.client.x;\n            dy = this.curCoords.client.y - this.startCoords.client.y;\n\n            this.pointerWasMoved = utils.hypot(dx, dy) > scope.pointerMoveTolerance;\n        }\n\n        if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n            if (this.pointerIsDown) {\n                clearTimeout(this.holdTimers[pointerIndex]);\n            }\n\n            this.collectEventTargets(pointer, event, eventTarget, 'move');\n        }\n\n        if (!this.pointerIsDown) { return; }\n\n        if (duplicateMove && this.pointerWasMoved && !preEnd) {\n            this.checkAndPreventDefault(event, this.target, this.element);\n            return;\n        }\n\n        // set pointer coordinate, time changes and speeds\n        utils.setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n        if (!this.prepared.name) { return; }\n\n        if (this.pointerWasMoved\n                // ignore movement while inertia is active\n            && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\n            // if just starting an action, calculate the pointer speed now\n            if (!this.interacting()) {\n                utils.setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n                // check if a drag is in the correct axis\n                if (this.prepared.name === 'drag') {\n                    var absX = Math.abs(dx),\n                        absY = Math.abs(dy),\n                        targetAxis = this.target.options.drag.axis,\n                        axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n                    // if the movement isn't in the axis of the interactable\n                    if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n                        // cancel the prepared action\n                        this.prepared.name = null;\n\n                        // then try to get a drag from another ineractable\n\n                        var element = eventTarget;\n\n                        // check element interactables\n                        while (utils.isElement(element)) {\n                            var elementInteractable = scope.interactables.get(element);\n\n                            if (elementInteractable\n                                && elementInteractable !== this.target\n                                && !elementInteractable.options.drag.manualStart\n                                && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag'\n                                && scope.checkAxis(axis, elementInteractable)) {\n\n                                this.prepared.name = 'drag';\n                                this.target = elementInteractable;\n                                this.element = element;\n                                break;\n                            }\n\n                            element = scope.parentElement(element);\n                        }\n\n                        // if there's no drag from element interactables,\n                        // check the selector interactables\n                        if (!this.prepared.name) {\n                            var thisInteraction = this;\n\n                            var getDraggable = function (interactable, selector, context) {\n                                var elements = scope.ie8MatchesSelector\n                                    ? context.querySelectorAll(selector)\n                                    : undefined;\n\n                                if (interactable === thisInteraction.target) { return; }\n\n                                if (scope.inContext(interactable, eventTarget)\n                                    && !interactable.options.drag.manualStart\n                                    && !scope.testIgnore(interactable, element, eventTarget)\n                                    && scope.testAllow(interactable, element, eventTarget)\n                                    && scope.matchesSelector(element, selector, elements)\n                                    && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'\n                                    && scope.checkAxis(axis, interactable)\n                                    && scope.withinInteractionLimit(interactable, element, 'drag')) {\n\n                                    return interactable;\n                                }\n                            };\n\n                            element = eventTarget;\n\n                            while (utils.isElement(element)) {\n                                var selectorInteractable = scope.interactables.forEachSelector(getDraggable);\n\n                                if (selectorInteractable) {\n                                    this.prepared.name = 'drag';\n                                    this.target = selectorInteractable;\n                                    this.element = element;\n                                    break;\n                                }\n\n                                element = scope.parentElement(element);\n                            }\n                        }\n                    }\n                }\n            }\n\n            var starting = !!this.prepared.name && !this.interacting();\n\n            if (starting\n                && (this.target.options[this.prepared.name].manualStart\n                || !scope.withinInteractionLimit(this.target, this.element, this.prepared))) {\n                this.stop(event);\n                return;\n            }\n\n            if (this.prepared.name && this.target) {\n                if (starting) {\n                    this.start(this.prepared, this.target, this.element);\n                }\n\n                var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\n                // move if snapping or restriction doesn't prevent it\n                if (shouldMove || starting) {\n                    this.prevEvent = this[this.prepared.name + 'Move'](event);\n                }\n\n                this.checkAndPreventDefault(event, this.target, this.element);\n            }\n        }\n\n        utils.copyCoords(this.prevCoords, this.curCoords);\n\n        if (this.dragging || this.resizing) {\n            this.autoScrollMove(pointer);\n        }\n    },\n\n    dragStart: function (event) {\n        var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\n        this.dragging = true;\n        this.target.fire(dragEvent);\n\n        // reset active dropzones\n        this.activeDrops.dropzones = [];\n        this.activeDrops.elements  = [];\n        this.activeDrops.rects     = [];\n\n        if (!this.dynamicDrop) {\n            this.setActiveDrops(this.element);\n        }\n\n        var dropEvents = this.getDropEvents(event, dragEvent);\n\n        if (dropEvents.activate) {\n            this.fireActiveDrops(dropEvents.activate);\n        }\n\n        return dragEvent;\n    },\n\n    dragMove: function (event) {\n        var target = this.target,\n            dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),\n            draggableElement = this.element,\n            drop = this.getDrop(event, draggableElement);\n\n        this.dropTarget = drop.dropzone;\n        this.dropElement = drop.element;\n\n        var dropEvents = this.getDropEvents(event, dragEvent);\n\n        target.fire(dragEvent);\n\n        if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n        if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n        if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }\n\n        this.prevDropTarget  = this.dropTarget;\n        this.prevDropElement = this.dropElement;\n\n        return dragEvent;\n    },\n\n    resizeStart: function (event) {\n        var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\n        if (this.prepared.edges) {\n            var startRect = this.target.getRect(this.element);\n\n            if (this.target.options.resize.square) {\n                var squareEdges = utils.extend({}, this.prepared.edges);\n\n                squareEdges.top    = squareEdges.top    || (squareEdges.left   && !squareEdges.bottom);\n                squareEdges.left   = squareEdges.left   || (squareEdges.top    && !squareEdges.right );\n                squareEdges.bottom = squareEdges.bottom || (squareEdges.right  && !squareEdges.top   );\n                squareEdges.right  = squareEdges.right  || (squareEdges.bottom && !squareEdges.left  );\n\n                this.prepared._squareEdges = squareEdges;\n            }\n            else {\n                this.prepared._squareEdges = null;\n            }\n\n            this.resizeRects = {\n                start     : startRect,\n                current   : utils.extend({}, startRect),\n                restricted: utils.extend({}, startRect),\n                previous  : utils.extend({}, startRect),\n                delta     : {\n                    left: 0, right : 0, width : 0,\n                    top : 0, bottom: 0, height: 0\n                }\n            };\n\n            resizeEvent.rect = this.resizeRects.restricted;\n            resizeEvent.deltaRect = this.resizeRects.delta;\n        }\n\n        this.target.fire(resizeEvent);\n\n        this.resizing = true;\n\n        return resizeEvent;\n    },\n\n    resizeMove: function (event) {\n        var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\n        var edges = this.prepared.edges,\n            invert = this.target.options.resize.invert,\n            invertible = invert === 'reposition' || invert === 'negate';\n\n        if (edges) {\n            var dx = resizeEvent.dx,\n                dy = resizeEvent.dy,\n\n                start      = this.resizeRects.start,\n                current    = this.resizeRects.current,\n                restricted = this.resizeRects.restricted,\n                delta      = this.resizeRects.delta,\n                previous   = utils.extend(this.resizeRects.previous, restricted);\n\n            if (this.target.options.resize.square) {\n                var originalEdges = edges;\n\n                edges = this.prepared._squareEdges;\n\n                if ((originalEdges.left && originalEdges.bottom)\n                    || (originalEdges.right && originalEdges.top)) {\n                    dy = -dx;\n                }\n                else if (originalEdges.left || originalEdges.right) { dy = dx; }\n                else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n            }\n\n            // update the 'current' rect without modifications\n            if (edges.top   ) { current.top    += dy; }\n            if (edges.bottom) { current.bottom += dy; }\n            if (edges.left  ) { current.left   += dx; }\n            if (edges.right ) { current.right  += dx; }\n\n            if (invertible) {\n                // if invertible, copy the current rect\n                utils.extend(restricted, current);\n\n                if (invert === 'reposition') {\n                    // swap edge values if necessary to keep width/height positive\n                    var swap;\n\n                    if (restricted.top > restricted.bottom) {\n                        swap = restricted.top;\n\n                        restricted.top = restricted.bottom;\n                        restricted.bottom = swap;\n                    }\n                    if (restricted.left > restricted.right) {\n                        swap = restricted.left;\n\n                        restricted.left = restricted.right;\n                        restricted.right = swap;\n                    }\n                }\n            }\n            else {\n                // if not invertible, restrict to minimum of 0x0 rect\n                restricted.top    = Math.min(current.top, start.bottom);\n                restricted.bottom = Math.max(current.bottom, start.top);\n                restricted.left   = Math.min(current.left, start.right);\n                restricted.right  = Math.max(current.right, start.left);\n            }\n\n            restricted.width  = restricted.right  - restricted.left;\n            restricted.height = restricted.bottom - restricted.top ;\n\n            for (var edge in restricted) {\n                delta[edge] = restricted[edge] - previous[edge];\n            }\n\n            resizeEvent.edges = this.prepared.edges;\n            resizeEvent.rect = restricted;\n            resizeEvent.deltaRect = delta;\n        }\n\n        this.target.fire(resizeEvent);\n\n        return resizeEvent;\n    },\n\n    gestureStart: function (event) {\n        var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\n        gestureEvent.ds = 0;\n\n        this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n        this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n        this.gesture.scale = 1;\n\n        this.gesturing = true;\n\n        this.target.fire(gestureEvent);\n\n        return gestureEvent;\n    },\n\n    gestureMove: function (event) {\n        if (!this.pointerIds.length) {\n            return this.prevEvent;\n        }\n\n        var gestureEvent;\n\n        gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n        gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\n        this.target.fire(gestureEvent);\n\n        this.gesture.prevAngle = gestureEvent.angle;\n        this.gesture.prevDistance = gestureEvent.distance;\n\n        if (gestureEvent.scale !== Infinity &&\n            gestureEvent.scale !== null &&\n            gestureEvent.scale !== undefined  &&\n            !isNaN(gestureEvent.scale)) {\n\n            this.gesture.scale = gestureEvent.scale;\n        }\n\n        return gestureEvent;\n    },\n\n    pointerHold: function (pointer, event, eventTarget) {\n        this.collectEventTargets(pointer, event, eventTarget, 'hold');\n    },\n\n    pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n        var pointerIndex = this.mouse? 0 : scope.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n        clearTimeout(this.holdTimers[pointerIndex]);\n\n        this.collectEventTargets(pointer, event, eventTarget, 'up' );\n        this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\n        this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n        this.removePointer(pointer);\n    },\n\n    pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n        var pointerIndex = this.mouse? 0 : scope.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n        clearTimeout(this.holdTimers[pointerIndex]);\n\n        this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n        this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n        this.removePointer(pointer);\n    },\n\n    // http://www.quirksmode.org/dom/events/click.html\n    // >Events leading to dblclick\n    //\n    // IE8 doesn't fire down event before dblclick.\n    // This workaround tries to fire a tap and doubletap after dblclick\n    ie8Dblclick: function (pointer, event, eventTarget) {\n        if (this.prevTap\n            && event.clientX === this.prevTap.clientX\n            && event.clientY === this.prevTap.clientY\n            && eventTarget   === this.prevTap.target) {\n\n            this.downTargets[0] = eventTarget;\n            this.downTimes[0] = new Date().getTime();\n            this.collectEventTargets(pointer, event, eventTarget, 'tap');\n        }\n    },\n\n    // End interact move events and stop auto-scroll unless inertia is enabled\n    pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n        var endEvent,\n            target = this.target,\n            options = target && target.options,\n            inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n            inertiaStatus = this.inertiaStatus;\n\n        if (this.interacting()) {\n\n            if (inertiaStatus.active) { return; }\n\n            var pointerSpeed,\n                now = new Date().getTime(),\n                inertiaPossible = false,\n                inertia = false,\n                smoothEnd = false,\n                endSnap = scope.checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n                endRestrict = scope.checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n                dx = 0,\n                dy = 0,\n                startEvent;\n\n            if (this.dragging) {\n                if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n                else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n                else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n            }\n            else {\n                pointerSpeed = this.pointerDelta.client.speed;\n            }\n\n            // check if inertia should be started\n            inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n            && this.prepared.name !== 'gesture'\n            && event !== inertiaStatus.startEvent);\n\n            inertia = (inertiaPossible\n            && (now - this.curCoords.timeStamp) < 50\n            && pointerSpeed > inertiaOptions.minSpeed\n            && pointerSpeed > inertiaOptions.endSpeed);\n\n            if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\n                var snapRestrict = {};\n\n                snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\n                if (endSnap) {\n                    this.setSnapping(this.curCoords.page, snapRestrict);\n                    if (snapRestrict.locked) {\n                        dx += snapRestrict.dx;\n                        dy += snapRestrict.dy;\n                    }\n                }\n\n                if (endRestrict) {\n                    this.setRestriction(this.curCoords.page, snapRestrict);\n                    if (snapRestrict.restricted) {\n                        dx += snapRestrict.dx;\n                        dy += snapRestrict.dy;\n                    }\n                }\n\n                if (dx || dy) {\n                    smoothEnd = true;\n                }\n            }\n\n            if (inertia || smoothEnd) {\n                utils.copyCoords(inertiaStatus.upCoords, this.curCoords);\n\n                this.pointers[0] = inertiaStatus.startEvent = startEvent =\n                    new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\n                inertiaStatus.t0 = now;\n\n                target.fire(inertiaStatus.startEvent);\n\n                if (inertia) {\n                    inertiaStatus.vx0 = this.pointerDelta.client.vx;\n                    inertiaStatus.vy0 = this.pointerDelta.client.vy;\n                    inertiaStatus.v0 = pointerSpeed;\n\n                    this.calcInertia(inertiaStatus);\n\n                    var page = utils.extend({}, this.curCoords.page),\n                        origin = scope.getOriginXY(target, this.element),\n                        statusObject;\n\n                    page.x = page.x + inertiaStatus.xe - origin.x;\n                    page.y = page.y + inertiaStatus.ye - origin.y;\n\n                    statusObject = {\n                        useStatusXY: true,\n                        x: page.x,\n                        y: page.y,\n                        dx: 0,\n                        dy: 0,\n                        snap: null\n                    };\n\n                    statusObject.snap = statusObject;\n\n                    dx = dy = 0;\n\n                    if (endSnap) {\n                        var snap = this.setSnapping(this.curCoords.page, statusObject);\n\n                        if (snap.locked) {\n                            dx += snap.dx;\n                            dy += snap.dy;\n                        }\n                    }\n\n                    if (endRestrict) {\n                        var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\n                        if (restrict.restricted) {\n                            dx += restrict.dx;\n                            dy += restrict.dy;\n                        }\n                    }\n\n                    inertiaStatus.modifiedXe += dx;\n                    inertiaStatus.modifiedYe += dy;\n\n                    inertiaStatus.i = animationFrame.request(this.boundInertiaFrame);\n                }\n                else {\n                    inertiaStatus.smoothEnd = true;\n                    inertiaStatus.xe = dx;\n                    inertiaStatus.ye = dy;\n\n                    inertiaStatus.sx = inertiaStatus.sy = 0;\n\n                    inertiaStatus.i = animationFrame.request(this.boundSmoothEndFrame);\n                }\n\n                inertiaStatus.active = true;\n                return;\n            }\n\n            if (endSnap || endRestrict) {\n                // fire a move event at the snapped coordinates\n                this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n            }\n        }\n\n        if (this.dragging) {\n            endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\n            var draggableElement = this.element,\n                drop = this.getDrop(event, draggableElement);\n\n            this.dropTarget = drop.dropzone;\n            this.dropElement = drop.element;\n\n            var dropEvents = this.getDropEvents(event, endEvent);\n\n            if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n            if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n            if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }\n            if (dropEvents.deactivate) {\n                this.fireActiveDrops(dropEvents.deactivate);\n            }\n\n            target.fire(endEvent);\n        }\n        else if (this.resizing) {\n            endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n            target.fire(endEvent);\n        }\n        else if (this.gesturing) {\n            endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n            target.fire(endEvent);\n        }\n\n        this.stop(event);\n    },\n\n    collectDrops: function (element) {\n        var drops = [],\n            elements = [],\n            i;\n\n        element = element || this.element;\n\n        // collect all dropzones and their elements which qualify for a drop\n        for (i = 0; i < scope.interactables.length; i++) {\n            if (!scope.interactables[i].options.drop.enabled) { continue; }\n\n            var current = scope.interactables[i],\n                accept = current.options.drop.accept;\n\n            // test the draggable element against the dropzone's accept setting\n            if ((utils.isElement(accept) && accept !== element)\n                || (scope.isString(accept)\n                && !scope.matchesSelector(element, accept))) {\n\n                continue;\n            }\n\n            // query for new elements if necessary\n            var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];\n\n            for (var j = 0, len = dropElements.length; j < len; j++) {\n                var currentElement = dropElements[j];\n\n                if (currentElement === element) {\n                    continue;\n                }\n\n                drops.push(current);\n                elements.push(currentElement);\n            }\n        }\n\n        return {\n            dropzones: drops,\n            elements: elements\n        };\n    },\n\n    fireActiveDrops: function (event) {\n        var i,\n            current,\n            currentElement,\n            prevElement;\n\n        // loop through all active dropzones and trigger event\n        for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n            current = this.activeDrops.dropzones[i];\n            currentElement = this.activeDrops.elements [i];\n\n            // prevent trigger of duplicate events on same element\n            if (currentElement !== prevElement) {\n                // set current element as event target\n                event.target = currentElement;\n                current.fire(event);\n            }\n            prevElement = currentElement;\n        }\n    },\n\n    // Collect a new set of possible drops and save them in activeDrops.\n    // setActiveDrops should always be called when a drag has just started or a\n    // drag event happens while dynamicDrop is true\n    setActiveDrops: function (dragElement) {\n        // get dropzones and their elements that could receive the draggable\n        var possibleDrops = this.collectDrops(dragElement, true);\n\n        this.activeDrops.dropzones = possibleDrops.dropzones;\n        this.activeDrops.elements  = possibleDrops.elements;\n        this.activeDrops.rects     = [];\n\n        for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n            this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n        }\n    },\n\n    getDrop: function (event, dragElement) {\n        var validDrops = [];\n\n        if (scope.dynamicDrop) {\n            this.setActiveDrops(dragElement);\n        }\n\n        // collect all dropzones and their elements which qualify for a drop\n        for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n            var current        = this.activeDrops.dropzones[j],\n                currentElement = this.activeDrops.elements [j],\n                rect           = this.activeDrops.rects    [j];\n\n            validDrops.push(current.dropCheck(this.pointers[0], event, this.target, dragElement, currentElement, rect)\n                ? currentElement\n                : null);\n        }\n\n        // get the most appropriate dropzone based on DOM depth and order\n        var dropIndex = scope.indexOfDeepestElement(validDrops),\n            dropzone  = this.activeDrops.dropzones[dropIndex] || null,\n            element   = this.activeDrops.elements [dropIndex] || null;\n\n        return {\n            dropzone: dropzone,\n            element: element\n        };\n    },\n\n    getDropEvents: function (pointerEvent, dragEvent) {\n        var dropEvents = {\n            enter     : null,\n            leave     : null,\n            activate  : null,\n            deactivate: null,\n            move      : null,\n            drop      : null\n        };\n\n        if (this.dropElement !== this.prevDropElement) {\n            // if there was a prevDropTarget, create a dragleave event\n            if (this.prevDropTarget) {\n                dropEvents.leave = {\n                    target       : this.prevDropElement,\n                    dropzone     : this.prevDropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dragleave'\n                };\n\n                dragEvent.dragLeave = this.prevDropElement;\n                dragEvent.prevDropzone = this.prevDropTarget;\n            }\n            // if the dropTarget is not null, create a dragenter event\n            if (this.dropTarget) {\n                dropEvents.enter = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dragenter'\n                };\n\n                dragEvent.dragEnter = this.dropElement;\n                dragEvent.dropzone = this.dropTarget;\n            }\n        }\n\n        if (dragEvent.type === 'dragend' && this.dropTarget) {\n            dropEvents.drop = {\n                target       : this.dropElement,\n                dropzone     : this.dropTarget,\n                relatedTarget: dragEvent.target,\n                draggable    : dragEvent.interactable,\n                dragEvent    : dragEvent,\n                interaction  : this,\n                timeStamp    : dragEvent.timeStamp,\n                type         : 'drop'\n            };\n\n            dragEvent.dropzone = this.dropTarget;\n        }\n        if (dragEvent.type === 'dragstart') {\n            dropEvents.activate = {\n                target       : null,\n                dropzone     : null,\n                relatedTarget: dragEvent.target,\n                draggable    : dragEvent.interactable,\n                dragEvent    : dragEvent,\n                interaction  : this,\n                timeStamp    : dragEvent.timeStamp,\n                type         : 'dropactivate'\n            };\n        }\n        if (dragEvent.type === 'dragend') {\n            dropEvents.deactivate = {\n                target       : null,\n                dropzone     : null,\n                relatedTarget: dragEvent.target,\n                draggable    : dragEvent.interactable,\n                dragEvent    : dragEvent,\n                interaction  : this,\n                timeStamp    : dragEvent.timeStamp,\n                type         : 'dropdeactivate'\n            };\n        }\n        if (dragEvent.type === 'dragmove' && this.dropTarget) {\n            dropEvents.move = {\n                target       : this.dropElement,\n                dropzone     : this.dropTarget,\n                relatedTarget: dragEvent.target,\n                draggable    : dragEvent.interactable,\n                dragEvent    : dragEvent,\n                interaction  : this,\n                dragmove     : dragEvent,\n                timeStamp    : dragEvent.timeStamp,\n                type         : 'dropmove'\n            };\n            dragEvent.dropzone = this.dropTarget;\n        }\n\n        return dropEvents;\n    },\n\n    currentAction: function () {\n        return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;\n    },\n\n    interacting: function () {\n        return this.dragging || this.resizing || this.gesturing;\n    },\n\n    clearTargets: function () {\n        this.target = this.element = null;\n\n        this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n    },\n\n    stop: function (event) {\n        if (this.interacting()) {\n            scope.autoScroll.stop();\n            this.matches = [];\n            this.matchElements = [];\n\n            var target = this.target;\n\n            if (target.options.styleCursor) {\n                target._doc.documentElement.style.cursor = '';\n            }\n\n            // prevent Default only if were previously interacting\n            if (event && scope.isFunction(event.preventDefault)) {\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n\n            if (this.dragging) {\n                this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n            }\n        }\n\n        this.clearTargets();\n\n        this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n        this.prepared.name = this.prevEvent = null;\n        this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\n        // remove pointers if their ID isn't in this.pointerIds\n        for (var i = 0; i < this.pointers.length; i++) {\n            if (scope.indexOf(this.pointerIds, utils.getPointerId(this.pointers[i])) === -1) {\n                this.pointers.splice(i, 1);\n            }\n        }\n\n        for (i = 0; i < scope.interactions.length; i++) {\n            // remove this interaction if it's not the only one of it's type\n            if (scope.interactions[i] !== this && scope.interactions[i].mouse === this.mouse) {\n                scope.interactions.splice(scope.indexOf(scope.interactions, this), 1);\n            }\n        }\n    },\n\n    inertiaFrame: function () {\n        var inertiaStatus = this.inertiaStatus,\n            options = this.target.options[this.prepared.name].inertia,\n            lambda = options.resistance,\n            t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n        if (t < inertiaStatus.te) {\n\n            var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\n            if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n                inertiaStatus.sx = inertiaStatus.xe * progress;\n                inertiaStatus.sy = inertiaStatus.ye * progress;\n            }\n            else {\n                var quadPoint = scope.getQuadraticCurvePoint(\n                    0, 0,\n                    inertiaStatus.xe, inertiaStatus.ye,\n                    inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,\n                    progress);\n\n                inertiaStatus.sx = quadPoint.x;\n                inertiaStatus.sy = quadPoint.y;\n            }\n\n            this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n            inertiaStatus.i = animationFrame.request(this.boundInertiaFrame);\n        }\n        else {\n            inertiaStatus.sx = inertiaStatus.modifiedXe;\n            inertiaStatus.sy = inertiaStatus.modifiedYe;\n\n            this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n            inertiaStatus.active = false;\n            this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        }\n    },\n\n    smoothEndFrame: function () {\n        var inertiaStatus = this.inertiaStatus,\n            t = new Date().getTime() - inertiaStatus.t0,\n            duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n        if (t < duration) {\n            inertiaStatus.sx = scope.easeOutQuad(t, 0, inertiaStatus.xe, duration);\n            inertiaStatus.sy = scope.easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\n            this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n            inertiaStatus.i = animationFrame.request(this.boundSmoothEndFrame);\n        }\n        else {\n            inertiaStatus.sx = inertiaStatus.xe;\n            inertiaStatus.sy = inertiaStatus.ye;\n\n            this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n            inertiaStatus.active = false;\n            inertiaStatus.smoothEnd = false;\n\n            this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        }\n    },\n\n    addPointer: function (pointer) {\n        var id = utils.getPointerId(pointer),\n            index = this.mouse? 0 : scope.indexOf(this.pointerIds, id);\n\n        if (index === -1) {\n            index = this.pointerIds.length;\n        }\n\n        this.pointerIds[index] = id;\n        this.pointers[index] = pointer;\n\n        return index;\n    },\n\n    removePointer: function (pointer) {\n        var id = utils.getPointerId(pointer),\n            index = this.mouse? 0 : scope.indexOf(this.pointerIds, id);\n\n        if (index === -1) { return; }\n\n        if (!this.interacting()) {\n            this.pointers.splice(index, 1);\n        }\n\n        this.pointerIds .splice(index, 1);\n        this.downTargets.splice(index, 1);\n        this.downTimes  .splice(index, 1);\n        this.holdTimers .splice(index, 1);\n    },\n\n    recordPointer: function (pointer) {\n        // Do not update pointers while inertia is active.\n        // The inertia start event should be this.pointers[0]\n        if (this.inertiaStatus.active) { return; }\n\n        var index = this.mouse? 0: scope.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n        if (index === -1) { return; }\n\n        this.pointers[index] = pointer;\n    },\n\n    collectEventTargets: function (pointer, event, eventTarget, eventType) {\n        var pointerIndex = this.mouse? 0 : scope.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n        // do not fire a tap event if the pointer was moved before being lifted\n        if (eventType === 'tap' && (this.pointerWasMoved\n                // or if the pointerup target is different to the pointerdown target\n            || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n            return;\n        }\n\n        var targets = [],\n            elements = [],\n            element = eventTarget;\n\n        function collectSelectors (interactable, selector, context) {\n            var els = scope.ie8MatchesSelector\n                ? context.querySelectorAll(selector)\n                : undefined;\n\n            if (interactable._iEvents[eventType]\n                && utils.isElement(element)\n                && scope.inContext(interactable, element)\n                && !scope.testIgnore(interactable, element, eventTarget)\n                && scope.testAllow(interactable, element, eventTarget)\n                && scope.matchesSelector(element, selector, els)) {\n\n                targets.push(interactable);\n                elements.push(element);\n            }\n        }\n\n\n        var interact = scope.interact;\n\n        while (element) {\n            if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n                targets.push(interact(element));\n                elements.push(element);\n            }\n\n            scope.interactables.forEachSelector(collectSelectors);\n\n            element = scope.parentElement(element);\n        }\n\n        // create the tap event even if there are no listeners so that\n        // doubletap can still be created and fired\n        if (targets.length || eventType === 'tap') {\n            this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n        }\n    },\n\n    firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n        var pointerIndex = this.mouse? 0 : scope.indexOf(utils.getPointerId(pointer)),\n            pointerEvent = {},\n            i,\n        // for tap events\n            interval, createNewDoubleTap;\n\n        // if it's a doubletap then the event properties would have been\n        // copied from the tap event and provided as the pointer argument\n        if (eventType === 'doubletap') {\n            pointerEvent = pointer;\n        }\n        else {\n            utils.extend(pointerEvent, event);\n            if (event !== pointer) {\n                utils.extend(pointerEvent, pointer);\n            }\n\n            pointerEvent.preventDefault           = preventOriginalDefault;\n            pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n            pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n            pointerEvent.interaction              = this;\n\n            pointerEvent.timeStamp     = new Date().getTime();\n            pointerEvent.originalEvent = event;\n            pointerEvent.type          = eventType;\n            pointerEvent.pointerId     = utils.getPointerId(pointer);\n            pointerEvent.pointerType   = this.mouse? 'mouse' : !browser.supportsPointerEvent? 'touch'\n                : scope.isString(pointer.pointerType)\n                ? pointer.pointerType\n                : [,,'touch', 'pen', 'mouse'][pointer.pointerType];\n        }\n\n        if (eventType === 'tap') {\n            pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\n            interval = pointerEvent.timeStamp - this.tapTime;\n            createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'\n            && this.prevTap.target === pointerEvent.target\n            && interval < 500);\n\n            pointerEvent.double = createNewDoubleTap;\n\n            this.tapTime = pointerEvent.timeStamp;\n        }\n\n        for (i = 0; i < targets.length; i++) {\n            pointerEvent.currentTarget = elements[i];\n            pointerEvent.interactable = targets[i];\n            targets[i].fire(pointerEvent);\n\n            if (pointerEvent.immediatePropagationStopped\n                ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {\n                break;\n            }\n        }\n\n        if (createNewDoubleTap) {\n            var doubleTap = {};\n\n            utils.extend(doubleTap, pointerEvent);\n\n            doubleTap.dt   = interval;\n            doubleTap.type = 'doubletap';\n\n            this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\n            this.prevTap = doubleTap;\n        }\n        else if (eventType === 'tap') {\n            this.prevTap = pointerEvent;\n        }\n    },\n\n    validateSelector: function (pointer, event, matches, matchElements) {\n        for (var i = 0, len = matches.length; i < len; i++) {\n            var match = matches[i],\n                matchElement = matchElements[i],\n                action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\n            if (action && scope.withinInteractionLimit(match, matchElement, action)) {\n                this.target = match;\n                this.element = matchElement;\n\n                return action;\n            }\n        }\n    },\n\n    setSnapping: function (pageCoords, status) {\n        var snap = this.target.options[this.prepared.name].snap,\n            targets = [],\n            target,\n            page,\n            i;\n\n        status = status || this.snapStatus;\n\n        if (status.useStatusXY) {\n            page = { x: status.x, y: status.y };\n        }\n        else {\n            var origin = scope.getOriginXY(this.target, this.element);\n\n            page = utils.extend({}, pageCoords);\n\n            page.x -= origin.x;\n            page.y -= origin.y;\n        }\n\n        status.realX = page.x;\n        status.realY = page.y;\n\n        page.x = page.x - this.inertiaStatus.resumeDx;\n        page.y = page.y - this.inertiaStatus.resumeDy;\n\n        var len = snap.targets? snap.targets.length : 0;\n\n        for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n            var relative = {\n                x: page.x - this.snapOffsets[relIndex].x,\n                y: page.y - this.snapOffsets[relIndex].y\n            };\n\n            for (i = 0; i < len; i++) {\n                if (scope.isFunction(snap.targets[i])) {\n                    target = snap.targets[i](relative.x, relative.y, this);\n                }\n                else {\n                    target = snap.targets[i];\n                }\n\n                if (!target) { continue; }\n\n                targets.push({\n                    x: scope.isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,\n                    y: scope.isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,\n\n                    range: scope.isNumber(target.range)? target.range: snap.range\n                });\n            }\n        }\n\n        var closest = {\n            target: null,\n            inRange: false,\n            distance: 0,\n            range: 0,\n            dx: 0,\n            dy: 0\n        };\n\n        for (i = 0, len = targets.length; i < len; i++) {\n            target = targets[i];\n\n            var range = target.range,\n                dx = target.x - page.x,\n                dy = target.y - page.y,\n                distance = utils.hypot(dx, dy),\n                inRange = distance <= range;\n\n            // Infinite targets count as being out of range\n            // compared to non infinite ones that are in range\n            if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n                inRange = false;\n            }\n\n            if (!closest.target || (inRange\n                    // is the closest target in range?\n                    ? (closest.inRange && range !== Infinity\n                    // the pointer is relatively deeper in this target\n                    ? distance / range < closest.distance / closest.range\n                    // this target has Infinite range and the closest doesn't\n                    : (range === Infinity && closest.range !== Infinity)\n                    // OR this target is closer that the previous closest\n                || distance < closest.distance)\n                    // The other is not in range and the pointer is closer to this target\n                    : (!closest.inRange && distance < closest.distance))) {\n\n                if (range === Infinity) {\n                    inRange = true;\n                }\n\n                closest.target = target;\n                closest.distance = distance;\n                closest.range = range;\n                closest.inRange = inRange;\n                closest.dx = dx;\n                closest.dy = dy;\n\n                status.range = range;\n            }\n        }\n\n        var snapChanged;\n\n        if (closest.target) {\n            snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\n            status.snappedX = closest.target.x;\n            status.snappedY = closest.target.y;\n        }\n        else {\n            snapChanged = true;\n\n            status.snappedX = NaN;\n            status.snappedY = NaN;\n        }\n\n        status.dx = closest.dx;\n        status.dy = closest.dy;\n\n        status.changed = (snapChanged || (closest.inRange && !status.locked));\n        status.locked = closest.inRange;\n\n        return status;\n    },\n\n    setRestriction: function (pageCoords, status) {\n        var target = this.target,\n            restrict = target && target.options[this.prepared.name].restrict,\n            restriction = restrict && restrict.restriction,\n            page;\n\n        if (!restriction) {\n            return status;\n        }\n\n        status = status || this.restrictStatus;\n\n        page = status.useStatusXY\n            ? page = { x: status.x, y: status.y }\n            : page = utils.extend({}, pageCoords);\n\n        if (status.snap && status.snap.locked) {\n            page.x += status.snap.dx || 0;\n            page.y += status.snap.dy || 0;\n        }\n\n        page.x -= this.inertiaStatus.resumeDx;\n        page.y -= this.inertiaStatus.resumeDy;\n\n        status.dx = 0;\n        status.dy = 0;\n        status.restricted = false;\n\n        var rect, restrictedX, restrictedY;\n\n        if (scope.isString(restriction)) {\n            if (restriction === 'parent') {\n                restriction = scope.parentElement(this.element);\n            }\n            else if (restriction === 'self') {\n                restriction = target.getRect(this.element);\n            }\n            else {\n                restriction = scope.closest(this.element, restriction);\n            }\n\n            if (!restriction) { return status; }\n        }\n\n        if (scope.isFunction(restriction)) {\n            restriction = restriction(page.x, page.y, this.element);\n        }\n\n        if (utils.isElement(restriction)) {\n            restriction = scope.getElementRect(restriction);\n        }\n\n        rect = restriction;\n\n        if (!restriction) {\n            restrictedX = page.x;\n            restrictedY = page.y;\n        }\n        // object is assumed to have\n        // x, y, width, height or\n        // left, top, right, bottom\n        else if ('x' in restriction && 'y' in restriction) {\n            restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);\n            restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );\n        }\n        else {\n            restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);\n            restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );\n        }\n\n        status.dx = restrictedX - page.x;\n        status.dy = restrictedY - page.y;\n\n        status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n        status.restricted = !!(status.dx || status.dy);\n\n        status.restrictedX = restrictedX;\n        status.restrictedY = restrictedY;\n\n        return status;\n    },\n\n    checkAndPreventDefault: function (event, interactable, element) {\n        if (!(interactable = interactable || this.target)) { return; }\n\n        var options = interactable.options,\n            prevent = options.preventDefault;\n\n        if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n            // do not preventDefault on pointerdown if the prepared action is a drag\n            // and dragging can only start from a certain direction - this allows\n            // a touch to pan the viewport if a drag isn't in the right direction\n            if (/down|start/i.test(event.type)\n                && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\n                return;\n            }\n\n            // with manualStart, only preventDefault while interacting\n            if (options[this.prepared.name] && options[this.prepared.name].manualStart\n                && !this.interacting()) {\n                return;\n            }\n\n            event.preventDefault();\n            return;\n        }\n\n        if (prevent === 'always') {\n            event.preventDefault();\n            return;\n        }\n    },\n\n    calcInertia: function (status) {\n        var inertiaOptions = this.target.options[this.prepared.name].inertia,\n            lambda = inertiaOptions.resistance,\n            inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n        status.x0 = this.prevEvent.pageX;\n        status.y0 = this.prevEvent.pageY;\n        status.t0 = status.startEvent.timeStamp / 1000;\n        status.sx = status.sy = 0;\n\n        status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n        status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n        status.te = inertiaDur;\n\n        status.lambda_v0 = lambda / status.v0;\n        status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n    },\n\n    autoScrollMove: function (pointer) {\n        if (!(this.interacting()\n            && scope.checkAutoScroll(this.target, this.prepared.name))) {\n            return;\n        }\n\n        if (this.inertiaStatus.active) {\n            scope.autoScroll.x = scope.autoScroll.y = 0;\n            return;\n        }\n\n        var top,\n            right,\n            bottom,\n            left,\n            options = this.target.options[this.prepared.name].autoScroll,\n            container = options.container || scope.getWindow(this.element);\n\n        if (scope.isWindow(container)) {\n            left   = pointer.clientX < scope.autoScroll.margin;\n            top    = pointer.clientY < scope.autoScroll.margin;\n            right  = pointer.clientX > container.innerWidth  - scope.autoScroll.margin;\n            bottom = pointer.clientY > container.innerHeight - scope.autoScroll.margin;\n        }\n        else {\n            var rect = scope.getElementRect(container);\n\n            left   = pointer.clientX < rect.left   + scope.autoScroll.margin;\n            top    = pointer.clientY < rect.top    + scope.autoScroll.margin;\n            right  = pointer.clientX > rect.right  - scope.autoScroll.margin;\n            bottom = pointer.clientY > rect.bottom - scope.autoScroll.margin;\n        }\n\n        scope.autoScroll.x = (right ? 1: left? -1: 0);\n        scope.autoScroll.y = (bottom? 1:  top? -1: 0);\n\n        if (!scope.autoScroll.isScrolling) {\n            // set the autoScroll properties to those of the target\n            scope.autoScroll.margin = options.margin;\n            scope.autoScroll.speed  = options.speed;\n\n            scope.autoScroll.start(this);\n        }\n    },\n\n    _updateEventTargets: function (target, currentTarget) {\n        this._eventTarget    = target;\n        this._curEventTarget = currentTarget;\n    }\n\n};\n\nmodule.exports = Interaction;\n\n},{\"./InteractEvent\":2,\"./scope\":6,\"./utils\":13,\"./utils/browser\":8,\"./utils/events\":10}],4:[function(require,module,exports){\n'use strict';\n\nvar raf       = require('./utils/raf'),\n    getWindow = require('./utils/window').getWindow,\n    isWindow  = require('./utils/isType').isWindow;\n\nvar autoScroll = {\n\n    interaction: null,\n    i: null,    // the handle returned by window.setInterval\n    x: 0, y: 0, // Direction each pulse is to scroll in\n\n    isScrolling: false,\n    prevTime: 0,\n\n    start: function (interaction) {\n        autoScroll.isScrolling = true;\n        raf.cancel(autoScroll.i);\n\n        autoScroll.interaction = interaction;\n        autoScroll.prevTime = new Date().getTime();\n        autoScroll.i = raf.request(autoScroll.scroll);\n    },\n\n    stop: function () {\n        autoScroll.isScrolling = false;\n        raf.cancel(autoScroll.i);\n    },\n\n    // scroll the window by the values in scroll.x/y\n    scroll: function () {\n        var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n            container = options.container || getWindow(autoScroll.interaction.element),\n            now = new Date().getTime(),\n            // change in time in seconds\n            dt = (now - autoScroll.prevTime) / 1000,\n            // displacement\n            s = options.speed * dt;\n\n        if (s >= 1) {\n            if (isWindow(container)) {\n                container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n            }\n            else if (container) {\n                container.scrollLeft += autoScroll.x * s;\n                container.scrollTop  += autoScroll.y * s;\n            }\n\n            autoScroll.prevTime = now;\n        }\n\n        if (autoScroll.isScrolling) {\n            raf.cancel(autoScroll.i);\n            autoScroll.i = raf.request(autoScroll.scroll);\n        }\n    }\n};\n\nmodule.exports = autoScroll;\n\n},{\"./utils/isType\":14,\"./utils/raf\":17,\"./utils/window\":18}],5:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    base: {\n        accept        : null,\n        actionChecker : null,\n        styleCursor   : true,\n        preventDefault: 'auto',\n        origin        : { x: 0, y: 0 },\n        deltaSource   : 'page',\n        allowFrom     : null,\n        ignoreFrom    : null,\n        _context      : require('./utils/domObjects').document,\n        dropChecker   : null\n    },\n\n    drag: {\n        enabled: false,\n        manualStart: true,\n        max: Infinity,\n        maxPerElement: 1,\n\n        snap: null,\n        restrict: null,\n        inertia: null,\n        autoScroll: null,\n\n        axis: 'xy'\n    },\n\n    drop: {\n        enabled: false,\n        accept: null,\n        overlap: 'pointer'\n    },\n\n    resize: {\n        enabled: false,\n        manualStart: false,\n        max: Infinity,\n        maxPerElement: 1,\n\n        snap: null,\n        restrict: null,\n        inertia: null,\n        autoScroll: null,\n\n        square: false,\n        axis: 'xy',\n\n        // use default margin\n        margin: NaN,\n\n        // object with props left, right, top, bottom which are\n        // true/false values to resize when the pointer is over that edge,\n        // CSS selectors to match the handles for each direction\n        // or the Elements for each handle\n        edges: null,\n\n        // a value of 'none' will limit the resize rect to a minimum of 0x0\n        // 'negate' will alow the rect to have negative width/height\n        // 'reposition' will keep the width/height positive by swapping\n        // the top and bottom edges and/or swapping the left and right edges\n        invert: 'none'\n    },\n\n    gesture: {\n        manualStart: false,\n        enabled: false,\n        max: Infinity,\n        maxPerElement: 1,\n\n        restrict: null\n    },\n\n    perAction: {\n        manualStart: false,\n        max: Infinity,\n        maxPerElement: 1,\n\n        snap: {\n            enabled     : false,\n            endOnly     : false,\n            range       : Infinity,\n            targets     : null,\n            offsets     : null,\n\n            relativePoints: null\n        },\n\n        restrict: {\n            enabled: false,\n            endOnly: false\n        },\n\n        autoScroll: {\n            enabled     : false,\n            container   : null,     // the item that is scrolled (Window or HTMLElement)\n            margin      : 60,\n            speed       : 300       // the scroll speed in pixels per second\n        },\n\n        inertia: {\n            enabled          : false,\n            resistance       : 10,    // the lambda in exponential decay\n            minSpeed         : 100,   // target speed must be above this for inertia to start\n            endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n            allowResume      : true,  // allow resuming an action in inertia phase\n            zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n            smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia\n        }\n    },\n\n    _holdDuration: 600\n};\n\n},{\"./utils/domObjects\":9}],6:[function(require,module,exports){\n'use strict';\n\nvar scope = {},\n    extend = require('./utils/extend');\n\nextend(scope, require('./utils/window'));\nextend(scope, require('./utils/domObjects'));\nextend(scope, require('./utils/arr.js'));\nextend(scope, require('./utils/isType'));\n\nmodule.exports = scope;\n\n},{\"./utils/arr.js\":7,\"./utils/domObjects\":9,\"./utils/extend\":11,\"./utils/isType\":14,\"./utils/window\":18}],7:[function(require,module,exports){\n'use strict';\n\nfunction indexOf (array, target) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (array[i] === target) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nfunction contains (array, target) {\n    return indexOf(array, target) !== -1;\n}\n\nmodule.exports = {\n    indexOf: indexOf,\n    contains: contains\n};\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\nvar win = require('./window'),\n    domObjects = require('./domObjects');\n\nvar browser = {\n    // Does the browser support touch input?\n    supportsTouch : !!(('ontouchstart' in win) || win.window.DocumentTouch\n        && domObjects.document instanceof win.DocumentTouch),\n\n    // Does the browser support PointerEvents\n    supportsPointerEvent : !!domObjects.PointerEvent,\n\n    // Opera Mobile must be handled differently\n    isOperaMobile : (navigator.appName === 'Opera'\n        && browser.supportsTouch\n        && navigator.userAgent.match('Presto')),\n\n    // scrolling doesn't change the result of\n    // getBoundingClientRect/getClientRects on iOS <=7 but it does on iOS 8\n    isIOS7orLower : (/iP(hone|od|ad)/.test(navigator.platform) && /OS [1-7][^\\d]/.test(navigator.appVersion)),\n\n    isIe9OrOlder : domObjects.document.all && !win.window.atob,\n\n    // prefix matchesSelector\n    prefixedMatchesSelector: 'matches' in Element.prototype?\n            'matches': 'webkitMatchesSelector' in Element.prototype?\n                'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n                    'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n                        'oMatchesSelector': 'msMatchesSelector'\n\n};\n\nmodule.exports = browser;\n\n},{\"./domObjects\":9,\"./window\":18}],9:[function(require,module,exports){\n'use strict';\n\nvar domObjects = {},\n    win = require('./window').window,\n    blank = function () {};\n\ndomObjects.document           = win.document;\ndomObjects.DocumentFragment   = win.DocumentFragment   || blank;\ndomObjects.SVGElement         = win.SVGElement         || blank;\ndomObjects.SVGSVGElement      = win.SVGSVGElement      || blank;\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\ndomObjects.HTMLElement        = win.HTMLElement        || win.Element;\n\ndomObjects.PointerEvent = (win.PointerEvent || win.MSPointerEvent);\n\nmodule.exports = domObjects;\n\n},{\"./window\":18}],10:[function(require,module,exports){\n'use strict';\n\nvar arr = require('./arr'),\n    indexOf  = arr.indexOf,\n    contains = arr.contains,\n    getWindow = require('./window').getWindow,\n\n    useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),\n    addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',\n    removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',\n    on             = useAttachEvent? 'on': '',\n\n    elements          = [],\n    targets           = [],\n    attachedListeners = [];\n\nfunction add (element, type, listener, useCapture) {\n    var elementIndex = indexOf(elements, element),\n        target = targets[elementIndex];\n\n    if (!target) {\n        target = {\n            events: {},\n            typeCount: 0\n        };\n\n        elementIndex = elements.push(element) - 1;\n        targets.push(target);\n\n        attachedListeners.push((useAttachEvent ? {\n                supplied: [],\n                wrapped : [],\n                useCount: []\n            } : null));\n    }\n\n    if (!target.events[type]) {\n        target.events[type] = [];\n        target.typeCount++;\n    }\n\n    if (!contains(target.events[type], listener)) {\n        var ret;\n\n        if (useAttachEvent) {\n            var listeners = attachedListeners[elementIndex],\n                listenerIndex = indexOf(listeners.supplied, listener);\n\n            var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n                if (!event.immediatePropagationStopped) {\n                    event.target = event.srcElement;\n                    event.currentTarget = element;\n\n                    event.preventDefault = event.preventDefault || preventDef;\n                    event.stopPropagation = event.stopPropagation || stopProp;\n                    event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n                    if (/mouse|click/.test(event.type)) {\n                        event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n                        event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n                    }\n\n                    listener(event);\n                }\n            };\n\n            ret = element[addEvent](on + type, wrapped, !!useCapture);\n\n            if (listenerIndex === -1) {\n                listeners.supplied.push(listener);\n                listeners.wrapped.push(wrapped);\n                listeners.useCount.push(1);\n            }\n            else {\n                listeners.useCount[listenerIndex]++;\n            }\n        }\n        else {\n            ret = element[addEvent](type, listener, !!useCapture);\n        }\n        target.events[type].push(listener);\n\n        return ret;\n    }\n}\n\nfunction remove (element, type, listener, useCapture) {\n    var i,\n        elementIndex = indexOf(elements, element),\n        target = targets[elementIndex],\n        listeners,\n        listenerIndex,\n        wrapped = listener;\n\n    if (!target || !target.events) {\n        return;\n    }\n\n    if (useAttachEvent) {\n        listeners = attachedListeners[elementIndex];\n        listenerIndex = indexOf(listeners.supplied, listener);\n        wrapped = listeners.wrapped[listenerIndex];\n    }\n\n    if (type === 'all') {\n        for (type in target.events) {\n            if (target.events.hasOwnProperty(type)) {\n                remove(element, type, 'all');\n            }\n        }\n        return;\n    }\n\n    if (target.events[type]) {\n        var len = target.events[type].length;\n\n        if (listener === 'all') {\n            for (i = 0; i < len; i++) {\n                remove(element, type, target.events[type][i], !!useCapture);\n            }\n            return;\n        } else {\n            for (i = 0; i < len; i++) {\n                if (target.events[type][i] === listener) {\n                    element[removeEvent](on + type, wrapped, !!useCapture);\n                    target.events[type].splice(i, 1);\n\n                    if (useAttachEvent && listeners) {\n                        listeners.useCount[listenerIndex]--;\n                        if (listeners.useCount[listenerIndex] === 0) {\n                            listeners.supplied.splice(listenerIndex, 1);\n                            listeners.wrapped.splice(listenerIndex, 1);\n                            listeners.useCount.splice(listenerIndex, 1);\n                        }\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        if (target.events[type] && target.events[type].length === 0) {\n            target.events[type] = null;\n            target.typeCount--;\n        }\n    }\n\n    if (!target.typeCount) {\n        targets.splice(elementIndex, 1);\n        elements.splice(elementIndex, 1);\n        attachedListeners.splice(elementIndex, 1);\n    }\n}\n\nfunction preventDef () {\n    this.returnValue = false;\n}\n\nfunction stopProp () {\n    this.cancelBubble = true;\n}\n\nfunction stopImmProp () {\n    this.cancelBubble = true;\n    this.immediatePropagationStopped = true;\n}\n\nmodule.exports = {\n    add: add,\n    remove: remove,\n    useAttachEvent: useAttachEvent,\n\n    _elements: elements,\n    _targets: targets,\n    _attachedListeners: attachedListeners\n};\n\n},{\"./arr\":7,\"./window\":18}],11:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function extend (dest, source) {\n    for (var prop in source) {\n        dest[prop] = source[prop];\n    }\n    return dest;\n};\n\n},{}],12:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function hypot (x, y) { return Math.sqrt(x * x + y * y); };\n\n},{}],13:[function(require,module,exports){\n'use strict';\n\nvar utils = module.exports,\n    extend = require('./extend'),\n    win = require('./window');\n\nutils.blank  = function () {};\n\nutils.warnOnce = function (method, message) {\n    var warned = false;\n\n    return function () {\n        if (!warned) {\n            win.window.console.warn(message);\n            warned = true;\n        }\n\n        return method.apply(this, arguments);\n    };\n};\n\nutils.extend  = extend;\nutils.hypot   = require('./hypot');\nutils.raf     = require('./raf');\nutils.browser = require('./browser');\n\nextend(utils, require('./arr'));\nextend(utils, require('./isType'));\nextend(utils, require('./pointerUtils'));\n\n},{\"./arr\":7,\"./browser\":8,\"./extend\":11,\"./hypot\":12,\"./isType\":14,\"./pointerUtils\":16,\"./raf\":17,\"./window\":18}],14:[function(require,module,exports){\n'use strict';\n\nvar win = require('./window'),\n    domObjects = require('./domObjects');\n\nvar isType = {\n    isElement : function (o) {\n        if (!o || (typeof o !== 'object')) { return false; }\n    \n        var _window = win.getWindow(o) || win.window;\n    \n        return (/object|function/.test(typeof _window.Element)\n            ? o instanceof _window.Element //DOM2\n            : o.nodeType === 1 && typeof o.nodeName === \"string\");\n    },\n\n    isArray    : null,\n    \n    isWindow   : require('./isWindow'),\n\n    isDocFrag  : function (thing) { return !!thing && thing instanceof domObjects.DocumentFragment; },\n\n    isObject   : function (thing) { return !!thing && (typeof thing === 'object'); },\n\n    isFunction : function (thing) { return typeof thing === 'function'; },\n\n    isNumber   : function (thing) { return typeof thing === 'number'  ; },\n\n    isBool     : function (thing) { return typeof thing === 'boolean' ; },\n\n    isString   : function (thing) { return typeof thing === 'string'  ; }\n    \n};\n\nisType.isArray = function (thing) {\n    return isType.isObject(thing)\n        && (typeof thing.length !== 'undefined')\n        && isType.isFunction(thing.splice);\n};\n\nmodule.exports = isType;\n\n},{\"./domObjects\":9,\"./isWindow\":15,\"./window\":18}],15:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function isWindow (thing) {\n    return !!(thing && thing.Window) && (thing instanceof thing.Window);\n};\n\n},{}],16:[function(require,module,exports){\n'use strict';\n\nvar pointerUtils = {},\n    // reduce object creation in getXY()\n    tmpXY = {},\n    win = require('./window'),\n    hypot = require('./hypot'),\n    extend = require('./extend'),\n    browser = require('./browser'),\n    isType = require('./isType'),\n    InteractEvent = require('../InteractEvent');\n\npointerUtils.copyCoords = function (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n};\n\npointerUtils.setEventXY = function (targetObj, pointer, interaction) {\n    if (!pointer) {\n        if (interaction.pointerIds.length > 1) {\n            pointer = pointerUtils.touchAverage(interaction.pointers);\n        }\n        else {\n            pointer = interaction.pointers[0];\n        }\n    }\n\n    pointerUtils.getPageXY(pointer, tmpXY, interaction);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    pointerUtils.getClientXY(pointer, tmpXY, interaction);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = new Date().getTime();\n};\n\npointerUtils.setEventDeltas = function (targetObj, prev, cur) {\n    targetObj.page.x     = cur.page.x      - prev.page.x;\n    targetObj.page.y     = cur.page.y      - prev.page.y;\n    targetObj.client.x   = cur.client.x    - prev.client.x;\n    targetObj.client.y   = cur.client.y    - prev.client.y;\n    targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\n    // set pointer velocity\n    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n    targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx      = targetObj.page.x / dt;\n    targetObj.page.vy      = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx    = targetObj.client.x / dt;\n    targetObj.client.vy    = targetObj.client.y / dt;\n};\n\n// Get specified X/Y coords for mouse or event.touches[0]\npointerUtils.getXY = function (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n};\n\npointerUtils.getPageXY = function (pointer, page, interaction) {\n    page = page || {};\n\n    if (pointer instanceof InteractEvent) {\n        if (/inertiastart/.test(pointer.type)) {\n            interaction = interaction || pointer.interaction;\n\n            extend(page, interaction.inertiaStatus.upCoords.page);\n\n            page.x += interaction.inertiaStatus.sx;\n            page.y += interaction.inertiaStatus.sy;\n        }\n        else {\n            page.x = pointer.pageX;\n            page.y = pointer.pageY;\n        }\n    }\n    // Opera Mobile handles the viewport and scrolling oddly\n    else if (browser.isOperaMobile) {\n        pointerUtils.getXY('screen', pointer, page);\n\n        page.x += win.window.scrollX;\n        page.y += win.window.scrollY;\n    }\n    else {\n        pointerUtils.getXY('page', pointer, page);\n    }\n\n    return page;\n};\n\npointerUtils.getClientXY = function (pointer, client, interaction) {\n    client = client || {};\n\n    if (pointer instanceof InteractEvent) {\n        if (/inertiastart/.test(pointer.type)) {\n            extend(client, interaction.inertiaStatus.upCoords.client);\n\n            client.x += interaction.inertiaStatus.sx;\n            client.y += interaction.inertiaStatus.sy;\n        }\n        else {\n            client.x = pointer.clientX;\n            client.y = pointer.clientY;\n        }\n    }\n    else {\n        // Opera Mobile handles the viewport and scrolling oddly\n        pointerUtils.getXY(browser.isOperaMobile? 'screen': 'client', pointer, client);\n    }\n\n    return client;\n};\n\npointerUtils.getPointerId = function (pointer) {\n    return isType.isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n};\n\nmodule.exports = pointerUtils;\n\n},{\"../InteractEvent\":2,\"./browser\":8,\"./extend\":11,\"./hypot\":12,\"./isType\":14,\"./window\":18}],17:[function(require,module,exports){\n'use strict';\n\nvar lastTime = 0,\n    vendors = ['ms', 'moz', 'webkit', 'o'],\n    reqFrame,\n    cancelFrame;\n\nfor(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    reqFrame = window[vendors[x]+'RequestAnimationFrame'];\n    cancelFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\n}\n\nif (!reqFrame) {\n    reqFrame = function(callback) {\n        var currTime = new Date().getTime(),\n            timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n            id = setTimeout(function() { callback(currTime + timeToCall); },\n          timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n    };\n}\n\nif (!cancelFrame) {\n    cancelFrame = function(id) {\n        clearTimeout(id);\n    };\n}\n\nmodule.exports = {\n    request: reqFrame,\n    cancel: cancelFrame\n};\n\n},{}],18:[function(require,module,exports){\n'use strict';\n\nvar isWindow = require('./isWindow');\n\nvar isShadowDom = function() {\n    // create a TextNode\n    var el = window.document.createTextNode('');\n\n    // check if it's wrapped by a polyfill\n    return el.ownerDocument !== window.document\n        && typeof window.wrap === 'function'\n        && window.wrap(el) === el;\n};\n\nvar win = {\n\n    window: undefined,\n\n    realWindow: window,\n\n    getWindow: function getWindow (node) {\n        if (isWindow(node)) {\n            return node;\n        }\n\n        var rootNode = (node.ownerDocument || node);\n\n        return rootNode.defaultView || rootNode.parentWindow || win.window;\n    }\n};\n\nif (typeof window !== 'undefined') {\n    if (isShadowDom()) {\n        win.window = window.wrap(window);\n    } else {\n        win.window = window;\n    }\n}\n\nmodule.exports = win;\n\n},{\"./isWindow\":15}]},{},[1]);\n"],"sourceRoot":"/source/"}