{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","interact.js","src/InteractEvent.js","src/Interactable.js","src/Interaction.js","src/actions/base.js","src/actions/drag.js","src/actions/drop.js","src/actions/gesture.js","src/actions/resize.js","src/autoScroll.js","src/defaultOptions.js","src/index.js","src/interact.js","src/legacyBrowsers.js","src/modifiers/base.js","src/modifiers/restrict.js","src/modifiers/snap.js","src/pointerEvents.js","src/scope.js","src/utils/arr.js","src/utils/browser.js","src/utils/domObjects.js","src/utils/domUtils.js","src/utils/events.js","src/utils/extend.js","src/utils/getOriginXY.js","src/utils/hypot.js","src/utils/index.js","src/utils/interactionFinder.js","src/utils/isType.js","src/utils/isWindow.js","src/utils/pointerUtils.js","src/utils/raf.js","src/utils/signals.js","src/utils/window.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","interact","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"init","./src/index","./src/utils/window",2,"_classCallCheck","instance","Constructor","TypeError","hypot","extend","getOriginXY","signals","modifiers","scope","InteractEvent","interaction","event","action","phase","element","related","target","deltaSource","options","defaultOptions","sourceX","sourceY","origin","starting","ending","coords","startCoords","curCoords","page","client","x","y","ctrlKey","altKey","shiftKey","metaKey","button","buttons","relatedTarget","t0","downTimes","type","interactable","names","modifierName","modifier","modifyCoords","modifierStatuses","pageX","pageY","clientX","clientY","x0","y0","clientX0","clientY0","signalArg","iEvent","inertiaStatus","active","detail","fire","timeStamp","dt","duration","speed","velocityX","velocityY","prevEvent","Date","getTime","dx","dy","pointerDelta","vx","vy","angle","Math","atan2","PI","overlap","left","up","right","down","swipe","velocity","prototype","preventDefault","stopImmediatePropagation","immediatePropagationStopped","propagationStopped","stopPropagation","on","_ref","inertia","zeroResumeDelta","resumeDx","resumeDy","./modifiers/base","./scope","./utils/extend","./utils/getOriginXY","./utils/hypot","./utils/signals",3,"isType","events","actions","_require","getElementRect","_require2","indexOf","contains","interactables","Interactable","_element","_context","document","_iEvents","_window","undefined","trySelector","selector","context","getWindow","Node","isElement","_doc","win","doc","push","set","setOnEvents","phases","onAction","isFunction","onstart","onmove","onend","oninertiastart","setPerAction","option","isObject","perAction","enabled","isBool","getAction","pointer","defaultActionChecker","actionChecker","checker","getRect","querySelector","rectChecker","styleCursor","newValue","test","ignoreFrom","allowFrom","eventTypes","listeners","onEvent","len","globalEvents","eventType","listener","useCapture","isString","search","trim","split","isArray","prop","wheelEvent","addDelegate","add","off","eventList","index","splice","removeDelegate","remove","base","perActions","actionName","methodDict","methodName","settings","setting","unset","delegatedEvents","delegated","selectors","contexts","delegateListener","delegateUseCapture","style","cursor","defaultChecker","./actions/base","./utils/arr","./utils/domUtils","./utils/events","./utils/isType",4,"validateAction","utils","name","doOnInteractions","method","eventTarget","getActualElement","path","curEventTarget","currentTarget","matches","browser","supportsTouch","prevTouchTime","_iterator","changedTouches","_isArray","Array","_i","Symbol","iterator","next","done","value","finder","Interaction","invalidPointer","supportsPointerEvent","interactions","mouse","pointerIsDown","pointerType","_iterator2","_isArray2","_i2","_ref2","_updateEventTargets","animationFrame","raf","methodNames","_this","matchElements","prepared","axis","edges","smoothEnd","startEvent","upCoords","xe","ye","sx","sy","vx0","vys","lambda_v0","one_ve_v0","boundInertiaFrame","inertiaFrame","boundSmoothEndFrame","smoothEndFrame","pointers","pointerIds","downTargets","holdTimers","prevCoords","downEvent","downPointer","_eventTarget","_curEventTarget","startOffset","top","bottom","modifierOffsets","resetStatuses","pointerWasMoved","_interacting","setEventXY","targetObj","pointerAverage","tmpXY","getPageXY","getClientXY","pointerOver","pushCurMatches","inContext","testIgnore","testAllow","matchesSelector","curMatches","curMatchElements","prevTargetElement","addPointer","elementInteractable","get","elementAction","withinInteractionLimit","forEachSelector","validateSelector","pointerHover","PointerEvent","pEventTypes","move","nodeContains","documentElement","getCursor","checkAndPreventDefault","pointerOut","interacting","selectorDown","_this2","pointerIndex","cancel","parentElement","pushMatches","elements","useMatchesSelectorPolyfill","querySelectorAll","pointerDown","pointerExtend","copyCoords","forceAction","newAction","resizeAxes","setStartOffsets","rect","width","height","setOffsets","start","setAll","pointerMove","preEnd","pageUp","clientUp","recordPointer","duplicateMove","pointerMoveTolerance","duplicate","setEventDeltas","beforeStart","manualStart","stop","modifierResult","shouldMove","pointerUp","getPointerId","clearTimeout","pointerEnd","removePointer","pointerCancel","inertiaOptions","now","statuses","pointerSpeed","inertiaPossible","dragging","drag","abs","minSpeed","endSpeed","locked","vy0","v0","calcInertia","modifiedXe","modifiedYe","request","shouldDo","end","currentAction","lambda","resistance","te","progress","exp","quadPoint","getQuadraticCurvePoint","smoothEndDuration","easeOutQuad","id","match","matchElement","prevent","nodeName","status","inertiaDur","log","_ref4","_ref5","_ref6","over","out","endAllInteractions","frameElement","parentDoc","ownerDocument","parentWindow","defaultView","error","windowParentError","_iterator3","_isArray3","_i3","_ref3","documents","withinLimit","./InteractEvent","./utils","./utils/browser","./utils/interactionFinder",5,6,"checkAxis","thisAxis","drop","defaults","max","Infinity","maxPerElement","snap","restrict","autoScroll","absX","absY","targetAxis","getDraggable","selectorInteractable","dragEvent","endEvent","draggable","merge","../InteractEvent","../Interactable","../defaultOptions","../scope","../utils","../utils/browser","./base","./drop",7,"collectDrops","drops","current","accept","dropElements","currentElement","dropzones","fireActiveDrops","prevElement","activeDrops","setActiveDrops","dragElement","possibleDrops","rects","getDrop","validDrops","dynamicDrop","j","dropCheck","dropIndex","indexOfDeepestElement","dropzone","getDropEvents","pointerEvent","dropEvents","enter","leave","activate","deactivate","dropElement","prevDropElement","prevDropTarget","dragLeave","prevDropzone","dropTarget","dragEnter","dragmove","draggableElement","dropOptions","dropResult","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","isNumber","min","dropped","dropOverlap","horizontal","vertical","dragRect","cx","cy","overlapArea","overlapRatio","../utils/signals",8,"gesture","blank","gestureEvent","ds","startDistance","prevDistance","distance","startAngle","prevAngle","scale","isNaN","gesturable","arg","touches","touchDistance","box","touchBBox","touchAngle","da","prevScale",9,"checkResizeEdge","interactableElement","margin","matchesUpTo","resize","square","preserveAspectRatio","NaN","invert","resizeOptions","resizeEdges","edge","axes","cursors","isIe9OrOlder","xy","topleft","bottomright","topright","bottomleft","cursorKey","edgeNames","resizeEvent","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","restricted","previous","delta","deltaRect","invertible","originalEdges","swap","resizable",10,"isWindow","domUtils","container","isScrolling","prevTime","scroll","scrollBy","scrollLeft","scrollTop","check","onInteractionMove","innerWidth","innerHeight","getElementClientRect","./defaultOptions","./utils/raf","./utils/window",11,"allowResume","_holdDuration",12,"./Interaction.js","./actions/drag","./actions/gesture","./actions/resize","./autoScroll","./interact","./legacyBrowsers","./modifiers/restrict","./modifiers/snap","./pointerEvents",13,"maxInteractions","indexOfElement","callback","ret","isSet","debug","getPointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","closest","./Interactable",14,"onIE8Dblclick","iFinder","prevTap","pointerEvents","collectEventTargets","toString","Object","obj","String","replace","isIE8",15,"offsets","setOffset","coordsArg","requireEndOnly","result","changed","currentStatus","reset","../utils/extend",16,"endOnly","restriction","elementRect","restrictOptions","offset","pageCoords","useStatusXY","restrictedX","restrictedY","modifiedX","modifiedY",17,"range","targets","relativePoints","snapOptions","snapOffset","relativeX","relativeY","realX","realY","offsetX","offsetY","snapTarget","inRange","snapChanged","snappedX","snappedY","createSnapGrid","grid","gridx","round","gridy","newX","newY","../interact",18,"preventOriginalDefault","originalEvent","firePointers","interval","createNewDoubleTap","pointerId","tapTime","doubleTap","collectSelectors","els","createSignalListener","simpleSignals","simpleEvents","eventCopy","setTimeout",19,"maxActions","activeInteractions","targetCount","targetElementCount","otherAction","prefixedPropREs","./utils/domObjects",20,"array","source",21,"domObjects","DocumentTouch","isOperaMobile","navigator","appName","userAgent","isIOS7","platform","appVersion","all","atob","prefixedMatchesSelector","Element","MSPointerEvent","./domObjects","./isType","./window",22,"DocumentFragment","SVGElement","SVGSVGElement","SVGElementInstance","HTMLElement","Event","Touch",23,"parent","child","parentNode","node","isDocFrag","host","matchesSelectorPolyfill","elems","nodeList","realWindow","deepestZoneParents","dropzoneParents","deepestZone","unshift","ownerSVGElement","parents","lastChild","previousSibling","limit","correspondingUseElement","getScrollXY","relevantWindow","scrollX","scrollY","clientRect","getBoundingClientRect","getClientRects","_scroll","./browser",24,"elementIndex","typeCount","attachedListeners","useAttachEvent","supplied","wrapped","useCount","_attachedListeners$elementIndex","listenerIndex","wrappedListener","srcElement","preventDef","stopProp","stopImmProp","addEvent","removeEvent","hasOwnProperty","matchFound","fn","useCap","fakeEvent","returnValue","cancelBubble","arr","_elements","_targets","_attachedListeners","./arr","./domUtils",25,"dest",26,27,"sqrt",28,"warnOnce","message","warned","console","warn","apply","arguments","_getQBezierValue","p1","p2","p3","iT","startX","startY","cpX","cpY","endX","endY","position","b","c","d","./extend","./getOriginXY","./hypot","./pointerUtils","./raf",29,"methodOrder","mouseEvent","details","inertiaResume","_ref7","_ref8","_iterator4","_isArray4","_i4","hasPointer","_ref9","_iterator5","_isArray5","_i5","idle","_ref10","_iterator6","_isArray6","_i6","./index",30,"nodeType","thing","./isWindow",31,"Window",32,"dom","pointerUtils","src","prev","cur","isNativePointer","getXY","identifier","webkit","deprecated","vendor","getTouchPair","average","screenX","screenY","minX","minY","maxX","maxY","atan","dr","drClamped",33,"vendors","lastTime","requestAnimationFrame","currTime","timeToCall",34,"targetListeners",35,"el","createTextNode","wrap","rootNode"],"mappings":"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","file":"interact.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * In a (windowless) server environment this file exports a factory function\n * that takes the window to use.\n *\n *     var interact = require('interact.js')(windowObject);\n *\n * See https://github.com/taye/interact.js/issues/187\n */\nif (typeof window === 'undefined') {\n  module.exports = function (window) {\n    require('./src/utils/window').init(window);\n\n    return require('./src/index');\n  };\n}\nelse {\n  module.exports = require('./src/index');\n}\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.interact = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*\n * In a (windowless) server environment this file exports a factory function\n * that takes the window to use.\n *\n *     var interact = require('interact.js')(windowObject);\n *\n * See https://github.com/taye/interact.js/issues/187\n */\nif (typeof window === 'undefined') {\n  module.exports = function (window) {\n    require('./src/utils/window').init(window);\n\n    return require('./src/index');\n  };\n} else {\n  module.exports = require('./src/index');\n}\n\n},{\"./src/index\":12,\"./src/utils/window\":35}],2:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar hypot = require('./utils/hypot');\nvar extend = require('./utils/extend');\nvar getOriginXY = require('./utils/getOriginXY');\nvar signals = require('./utils/signals');\nvar modifiers = require('./modifiers/base');\nvar scope = require('./scope');\n\nvar InteractEvent = (function () {\n  function InteractEvent(interaction, event, action, phase, element, related) {\n    _classCallCheck(this, InteractEvent);\n\n    var target = interaction.target;\n    var deltaSource = (target && target.options || scope.defaultOptions).deltaSource;\n    var sourceX = deltaSource + 'X';\n    var sourceY = deltaSource + 'Y';\n    var origin = getOriginXY(target, element);\n    var starting = phase === 'start';\n    var ending = phase === 'end';\n    var coords = starting ? interaction.startCoords : interaction.curCoords;\n\n    element = element || interaction.element;\n\n    var page = extend({}, coords.page);\n    var client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    this.ctrlKey = event.ctrlKey;\n    this.altKey = event.altKey;\n    this.shiftKey = event.shiftKey;\n    this.metaKey = event.metaKey;\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.target = element;\n    this.relatedTarget = related || null;\n    this.t0 = interaction.downTimes[interaction.downTimes.length - 1];\n    this.type = action + (phase || '');\n    this.interaction = interaction;\n    this.interactable = target;\n\n    for (var i = 0; i < modifiers.names.length; i++) {\n      var modifierName = modifiers.names[i];\n      var modifier = modifiers[modifierName];\n\n      this[modifierName] = modifier.modifyCoords(page, client, target, interaction.modifierStatuses[modifierName], action, phase);\n    }\n\n    this.pageX = page.x;\n    this.pageY = page.y;\n    this.clientX = client.x;\n    this.clientY = client.y;\n\n    this.x0 = interaction.startCoords.page.x - origin.x;\n    this.y0 = interaction.startCoords.page.y - origin.y;\n    this.clientX0 = interaction.startCoords.client.x - origin.x;\n    this.clientY0 = interaction.startCoords.client.y - origin.y;\n\n    var signalArg = {\n      interaction: interaction,\n      event: event,\n      action: action,\n      phase: phase,\n      element: element,\n      related: related,\n      page: page,\n      client: client,\n      coords: coords,\n      starting: starting,\n      ending: ending,\n      deltaSource: deltaSource,\n      iEvent: this\n    };\n\n    var inertiaStatus = interaction.inertiaStatus;\n\n    if (inertiaStatus.active) {\n      this.detail = 'inertia';\n    }\n\n    signals.fire('interactevent-new', signalArg);\n    signals.fire('interactevent-' + action, signalArg);\n\n    if (starting) {\n      this.timeStamp = interaction.downTimes[0];\n      this.dt = 0;\n      this.duration = 0;\n      this.speed = 0;\n      this.velocityX = 0;\n      this.velocityY = 0;\n    } else if (phase === 'inertiastart') {\n      this.timeStamp = interaction.prevEvent.timeStamp;\n      this.dt = interaction.prevEvent.dt;\n      this.duration = interaction.prevEvent.duration;\n      this.speed = interaction.prevEvent.speed;\n      this.velocityX = interaction.prevEvent.velocityX;\n      this.velocityY = interaction.prevEvent.velocityY;\n    } else {\n      this.timeStamp = new Date().getTime();\n      this.dt = this.timeStamp - interaction.prevEvent.timeStamp;\n      this.duration = this.timeStamp - interaction.downTimes[0];\n\n      if (event instanceof InteractEvent) {\n        var dx = this[sourceX] - interaction.prevEvent[sourceX];\n        var dy = this[sourceY] - interaction.prevEvent[sourceY];\n        var dt = this.dt / 1000;\n\n        this.speed = hypot(dx, dy) / dt;\n        this.velocityX = dx / dt;\n        this.velocityY = dy / dt;\n      }\n      // if normal move or end event, use previous user event coords\n      else {\n          // speed and velocity in pixels per second\n          this.speed = interaction.pointerDelta[deltaSource].speed;\n          this.velocityX = interaction.pointerDelta[deltaSource].vx;\n          this.velocityY = interaction.pointerDelta[deltaSource].vy;\n        }\n    }\n\n    if ((ending || phase === 'inertiastart') && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n      var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n      var overlap = 22.5;\n\n      if (angle < 0) {\n        angle += 360;\n      }\n\n      var left = 135 - overlap <= angle && angle < 225 + overlap;\n      var up = 225 - overlap <= angle && angle < 315 + overlap;\n\n      var right = !left && (315 - overlap <= angle || angle < 45 + overlap);\n      var down = !up && 45 - overlap <= angle && angle < 135 + overlap;\n\n      this.swipe = {\n        up: up,\n        down: down,\n        left: left,\n        right: right,\n        angle: angle,\n        speed: interaction.prevEvent.speed,\n        velocity: {\n          x: interaction.prevEvent.velocityX,\n          y: interaction.prevEvent.velocityY\n        }\n      };\n    }\n  }\n\n  InteractEvent.prototype.preventDefault = function preventDefault() {};\n\n  InteractEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  };\n\n  InteractEvent.prototype.stopPropagation = function stopPropagation() {\n    this.propagationStopped = true;\n  };\n\n  return InteractEvent;\n})();\n\nsignals.on('interactevent-new', function (_ref) {\n  var iEvent = _ref.iEvent;\n  var interaction = _ref.interaction;\n  var action = _ref.action;\n  var phase = _ref.phase;\n  var ending = _ref.ending;\n  var starting = _ref.starting;\n  var page = _ref.page;\n  var client = _ref.client;\n  var deltaSource = _ref.deltaSource;\n\n  // end event dx, dy is difference between start and end points\n  if (ending) {\n    if (deltaSource === 'client') {\n      iEvent.dx = client.x - interaction.startCoords.client.x;\n      iEvent.dy = client.y - interaction.startCoords.client.y;\n    } else {\n      iEvent.dx = page.x - interaction.startCoords.page.x;\n      iEvent.dy = page.y - interaction.startCoords.page.y;\n    }\n  } else if (starting) {\n    iEvent.dx = 0;\n    iEvent.dy = 0;\n  }\n  // copy properties from previousmove if starting inertia\n  else if (phase === 'inertiastart') {\n      iEvent.dx = interaction.prevEvent.dx;\n      iEvent.dy = interaction.prevEvent.dy;\n    } else {\n      if (deltaSource === 'client') {\n        iEvent.dx = client.x - interaction.prevEvent.clientX;\n        iEvent.dy = client.y - interaction.prevEvent.clientY;\n      } else {\n        iEvent.dx = page.x - interaction.prevEvent.pageX;\n        iEvent.dy = page.y - interaction.prevEvent.pageY;\n      }\n    }\n\n  var options = interaction.target.options;\n  var inertiaStatus = interaction.inertiaStatus;\n\n  if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia' && !inertiaStatus.active && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\n    inertiaStatus.resumeDx += iEvent.dx;\n    inertiaStatus.resumeDy += iEvent.dy;\n\n    iEvent.dx = iEvent.dy = 0;\n  }\n});\n\nmodule.exports = InteractEvent;\n\n},{\"./modifiers/base\":15,\"./scope\":19,\"./utils/extend\":25,\"./utils/getOriginXY\":26,\"./utils/hypot\":27,\"./utils/signals\":34}],3:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar isType = require('./utils/isType');\nvar events = require('./utils/events');\nvar signals = require('./utils/signals');\nvar extend = require('./utils/extend');\nvar actions = require('./actions/base');\nvar scope = require('./scope');\n\nvar _require = require('./utils/domUtils');\n\nvar getElementRect = _require.getElementRect;\n\nvar _require2 = require('./utils/arr');\n\nvar indexOf = _require2.indexOf;\nvar contains = _require2.contains;\n\n// all set interactables\nscope.interactables = [];\n\n/*\\\n * Interactable\n [ property ]\n **\n * Object type returned by @interact\n\\*/\n\nvar Interactable = (function () {\n  function Interactable(element, options) {\n    _classCallCheck(this, Interactable);\n\n    this._element = element;\n    this._context = scope.document;\n    this._iEvents = this._iEvents || {};\n\n    var _window = undefined;\n\n    if (isType.trySelector(element)) {\n      this.selector = element;\n\n      var context = options && options.context;\n\n      _window = context ? scope.getWindow(context) : scope.window;\n\n      if (context && (_window.Node ? context instanceof _window.Node : isType.isElement(context) || context === _window.document)) {\n\n        this._context = context;\n      }\n    } else {\n      _window = scope.getWindow(element);\n    }\n\n    this._doc = _window.document;\n\n    signals.fire('interactable-new', {\n      element: element,\n      options: options,\n      interactable: this,\n      win: _window\n    });\n\n    if (this._doc !== scope.document) {\n      signals.fire('listen-to-document', {\n        doc: this._doc,\n        win: _window\n      });\n    }\n\n    scope.interactables.push(this);\n\n    this.set(options);\n  }\n\n  Interactable.prototype.setOnEvents = function setOnEvents(action, phases) {\n    var onAction = 'on' + action;\n\n    if (isType.isFunction(phases.onstart)) {\n      this[onAction + 'start'] = phases.onstart;\n    }\n    if (isType.isFunction(phases.onmove)) {\n      this[onAction + 'move'] = phases.onmove;\n    }\n    if (isType.isFunction(phases.onend)) {\n      this[onAction + 'end'] = phases.onend;\n    }\n    if (isType.isFunction(phases.oninertiastart)) {\n      this[onAction + 'inertiastart'] = phases.oninertiastart;\n    }\n\n    return this;\n  };\n\n  Interactable.prototype.setPerAction = function setPerAction(action, options) {\n    // for all the default per-action options\n    for (var option in options) {\n      // if this option exists for this action\n      if (option in scope.defaultOptions[action]) {\n        // if the option in the options arg is an object value\n        if (isType.isObject(options[option])) {\n          // duplicate the object\n          this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n          if (isType.isObject(scope.defaultOptions.perAction[option]) && 'enabled' in scope.defaultOptions.perAction[option]) {\n            this.options[action][option].enabled = options[option].enabled === false ? false : true;\n          }\n        } else if (isType.isBool(options[option]) && isType.isObject(scope.defaultOptions.perAction[option])) {\n          this.options[action][option].enabled = options[option];\n        } else if (options[option] !== undefined) {\n          // or if it's not undefined, do a plain assignment\n          this.options[action][option] = options[option];\n        }\n      }\n    }\n  };\n\n  Interactable.prototype.getAction = function getAction(pointer, event, interaction, element) {\n    var action = this.defaultActionChecker(pointer, event, interaction, element);\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction);\n    }\n\n    return action;\n  };\n\n  /*\\\n   * Interactable.actionChecker\n   [ method ]\n   *\n   * Gets or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n   = (Function | Interactable) The checker function or this Interactable\n   *\n   | interact('.resize-drag')\n   |   .resizable(true)\n   |   .draggable(true)\n   |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   |\n   |   if (interact.matchesSelector(event.target, '.drag-handle') {\n   |     // force drag with handle target\n   |     action.name = drag;\n   |   }\n   |   else {\n   |     // resize from the top and right edges\n   |     action.name  = 'resize';\n   |     action.edges = { top: true, right: true };\n   |   }\n   |\n   |   return action;\n   | });\n  \\*/\n\n  Interactable.prototype.actionChecker = function actionChecker(checker) {\n    if (isType.isFunction(checker)) {\n      this.options.actionChecker = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.actionChecker;\n\n      return this;\n    }\n\n    return this.options.actionChecker;\n  };\n\n  /*\\\n   * Interactable.getRect\n   [ method ]\n   *\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using @Interactable.rectChecker.\n   *\n   - element (Element) #optional The element to measure.\n   = (object) The object's bounding rectangle.\n   o {\n   o     top   : 0,\n   o     left  : 0,\n   o     bottom: 0,\n   o     right : 0,\n   o     width : 0,\n   o     height: 0\n   o }\n  \\*/\n\n  Interactable.prototype.getRect = function getRect(element) {\n    element = element || this._element;\n\n    if (this.selector && !isType.isElement(element)) {\n      element = this._context.querySelector(this.selector);\n    }\n\n    return getElementRect(element);\n  };\n\n  /*\\\n   * Interactable.rectChecker\n   [ method ]\n   *\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n   = (function | object) The checker function or this Interactable\n  \\*/\n\n  Interactable.prototype.rectChecker = function rectChecker(checker) {\n    if (isType.isFunction(checker)) {\n      this.getRect = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.getRect;\n\n      return this;\n    }\n\n    return this.getRect;\n  };\n\n  /*\\\n   * Interactable.styleCursor\n   [ method ]\n   *\n   * Returns or sets whether the action that would be performed when the\n   * mouse on the element are checked on `mousemove` so that the cursor\n   * may be styled appropriately\n   *\n   - newValue (boolean) #optional\n   = (boolean | Interactable) The current setting or this Interactable\n  \\*/\n\n  Interactable.prototype.styleCursor = function styleCursor(newValue) {\n    if (isType.isBool(newValue)) {\n      this.options.styleCursor = newValue;\n\n      return this;\n    }\n\n    if (newValue === null) {\n      delete this.options.styleCursor;\n\n      return this;\n    }\n\n    return this.options.styleCursor;\n  };\n\n  /*\\\n   * Interactable.preventDefault\n   [ method ]\n   *\n   * Returns or sets whether to prevent the browser's default behaviour\n   * in response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   - newValue (string) #optional `true`, `false` or `'auto'`\n   = (string | Interactable) The current setting or this Interactable\n  \\*/\n\n  Interactable.prototype.preventDefault = function preventDefault(newValue) {\n    if (/^(always|never|auto)$/.test(newValue)) {\n      this.options.preventDefault = newValue;\n      return this;\n    }\n\n    if (isType.isBool(newValue)) {\n      this.options.preventDefault = newValue ? 'always' : 'never';\n      return this;\n    }\n\n    return this.options.preventDefault;\n  };\n\n  /*\\\n   * Interactable.origin\n   [ method ]\n   *\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n   * OR\n   - origin (Element) #optional An HTML or SVG Element whose rect will be used\n   **\n   = (object) The current origin or this Interactable\n  \\*/\n\n  Interactable.prototype.origin = function origin(newValue) {\n    if (isType.trySelector(newValue)) {\n      this.options.origin = newValue;\n      return this;\n    } else if (isType.isObject(newValue)) {\n      this.options.origin = newValue;\n      return this;\n    }\n\n    return this.options.origin;\n  };\n\n  /*\\\n   * Interactable.deltaSource\n   [ method ]\n   *\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n   = (string | object) The current deltaSource or this Interactable\n  \\*/\n\n  Interactable.prototype.deltaSource = function deltaSource(newValue) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue;\n\n      return this;\n    }\n\n    return this.options.deltaSource;\n  };\n\n  /*\\\n   * Interactable.context\n   [ method ]\n   *\n   * Gets the selector context Node of the Interactable. The default is `window.document`.\n   *\n   = (Node) The context Node of this Interactable\n   **\n  \\*/\n\n  Interactable.prototype.context = function context() {\n    return this._context;\n  };\n\n  /*\\\n   * Interactable.ignoreFrom\n   [ method ]\n   *\n   * If the target of the `mousedown`, `pointerdown` or `touchstart`\n   * event or any of it's parents match the given CSS selector or\n   * Element, no drag/resize/gesture is started.\n   *\n   - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n   = (string | Element | object) The current ignoreFrom value or this Interactable\n   **\n   | interact(element, { ignoreFrom: document.getElementById('no-action') });\n   | // or\n   | interact(element).ignoreFrom('input, textarea, a');\n  \\*/\n\n  Interactable.prototype.ignoreFrom = function ignoreFrom(newValue) {\n    if (isType.trySelector(newValue)) {\n      // CSS selector to match event.target\n      this.options.ignoreFrom = newValue;\n      return this;\n    }\n\n    if (isType.isElement(newValue)) {\n      // specific element\n      this.options.ignoreFrom = newValue;\n      return this;\n    }\n\n    return this.options.ignoreFrom;\n  };\n\n  /*\\\n   * Interactable.allowFrom\n   [ method ]\n   *\n   * A drag/resize/gesture is started only If the target of the\n   * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n   * parents match the given CSS selector or Element.\n   *\n   - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n   = (string | Element | object) The current allowFrom value or this Interactable\n   **\n   | interact(element, { allowFrom: document.getElementById('drag-handle') });\n   | // or\n   | interact(element).allowFrom('.handle');\n  \\*/\n\n  Interactable.prototype.allowFrom = function allowFrom(newValue) {\n    if (isType.trySelector(newValue)) {\n      // CSS selector to match event.target\n      this.options.allowFrom = newValue;\n      return this;\n    }\n\n    if (isType.isElement(newValue)) {\n      // specific element\n      this.options.allowFrom = newValue;\n      return this;\n    }\n\n    return this.options.allowFrom;\n  };\n\n  /*\\\n   * Interactable.element\n   [ method ]\n   *\n   * If this is not a selector Interactable, it returns the element this\n   * interactable represents\n   *\n   = (Element) HTML / SVG Element\n  \\*/\n\n  Interactable.prototype.element = function element() {\n    return this._element;\n  };\n\n  /*\\\n   * Interactable.fire\n   [ method ]\n   *\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n   = (Interactable) this Interactable\n  \\*/\n\n  Interactable.prototype.fire = function fire(iEvent) {\n    if (!(iEvent && iEvent.type) || !contains(scope.eventTypes, iEvent.type)) {\n      return this;\n    }\n\n    var listeners = undefined;\n    var onEvent = 'on' + iEvent.type;\n\n    // Interactable#on() listeners\n    if (iEvent.type in this._iEvents) {\n      listeners = this._iEvents[iEvent.type];\n\n      for (var i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n        listeners[i](iEvent);\n      }\n    }\n\n    // interactable.onevent listener\n    if (isType.isFunction(this[onEvent])) {\n      this[onEvent](iEvent);\n    }\n\n    // interact.on() listeners\n    if (iEvent.type in scope.globalEvents && (listeners = scope.globalEvents[iEvent.type])) {\n\n      for (var i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n        listeners[i](iEvent);\n      }\n    }\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.on\n   [ method ]\n   *\n   * Binds a listener for an InteractEvent or DOM event.\n   *\n   - eventType  (string | array | object) The types of events to listen for\n   - listener   (function) The function event (s)\n   - useCapture (boolean) #optional useCapture flag for addEventListener\n   = (object) This Interactable\n  \\*/\n\n  Interactable.prototype.on = function on(eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (var i = 0; i < eventType.length; i++) {\n        this.on(eventType[i], listener, useCapture);\n      }\n\n      return this;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (var prop in eventType) {\n        this.on(prop, eventType[prop], listener);\n      }\n\n      return this;\n    }\n\n    if (eventType === 'wheel') {\n      eventType = scope.wheelEvent;\n    }\n\n    // convert to boolean\n    useCapture = useCapture ? true : false;\n\n    if (contains(scope.eventTypes, eventType)) {\n      // if this type of event was never bound to this Interactable\n      if (!(eventType in this._iEvents)) {\n        this._iEvents[eventType] = [listener];\n      } else {\n        this._iEvents[eventType].push(listener);\n      }\n    }\n    // delegated event for selector\n    else if (this.selector) {\n        events.addDelegate(this.selector, this._context, eventType, listener, useCapture);\n      } else {\n        events.add(this._element, eventType, listener, useCapture);\n      }\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.off\n   [ method ]\n   *\n   * Removes an InteractEvent or DOM event listener\n   *\n   - eventType  (string | array | object) The types of events that were listened for\n   - listener   (function) The listener function to be removed\n   - useCapture (boolean) #optional useCapture flag for removeEventListener\n   = (object) This Interactable\n  \\*/\n\n  Interactable.prototype.off = function off(eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (var i = 0; i < eventType.length; i++) {\n        this.off(eventType[i], listener, useCapture);\n      }\n\n      return this;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (var prop in eventType) {\n        this.off(prop, eventType[prop], listener);\n      }\n\n      return this;\n    }\n\n    // convert to boolean\n    useCapture = useCapture ? true : false;\n\n    if (eventType === 'wheel') {\n      eventType = scope.wheelEvent;\n    }\n\n    // if it is an action event type\n    if (contains(scope.eventTypes, eventType)) {\n      var eventList = this._iEvents[eventType];\n      var index = eventList ? indexOf(eventList, listener) : -1;\n\n      if (index !== -1) {\n        this._iEvents[eventType].splice(index, 1);\n      }\n    }\n    // delegated event\n    else if (this.selector) {\n        events.removeDelegate(this.selector, this._context, eventType, listener, useCapture);\n      }\n      // remove listener from this Interatable's element\n      else {\n          events.remove(this._element, eventType, listener, useCapture);\n        }\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.set\n   [ method ]\n   *\n   * Reset the options of this Interactable\n   - options (object) The new settings to apply\n   = (object) This Interactable\n  \\*/\n\n  Interactable.prototype.set = function set(options) {\n    if (!isType.isObject(options)) {\n      options = {};\n    }\n\n    this.options = extend({}, scope.defaultOptions.base);\n\n    var perActions = extend({}, scope.defaultOptions.perAction);\n\n    for (var actionName in actions.methodDict) {\n      var methodName = actions.methodDict[actionName];\n\n      this.options[actionName] = extend({}, scope.defaultOptions[actionName]);\n\n      this.setPerAction(actionName, perActions);\n\n      this[methodName](options[actionName]);\n    }\n\n    var settings = ['accept', 'actionChecker', 'allowFrom', 'deltaSource', 'dropChecker', 'ignoreFrom', 'origin', 'preventDefault', 'rectChecker', 'styleCursor'];\n\n    for (var i = 0, len = settings.length; i < len; i++) {\n      var setting = settings[i];\n\n      this.options[setting] = scope.defaultOptions.base[setting];\n\n      if (setting in options) {\n        this[setting](options[setting]);\n      }\n    }\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.unset\n   [ method ]\n   *\n   * Remove this interactable from the list of interactables and remove\n   * it's action capabilities and event listeners\n   *\n   = (object) @interact\n  \\*/\n\n  Interactable.prototype.unset = function unset() {\n    events.remove(this._element, 'all');\n\n    if (!isType.isString(this.selector)) {\n      events.remove(this, 'all');\n      if (this.options.styleCursor) {\n        this._element.style.cursor = '';\n      }\n    } else {\n      // remove delegated events\n      for (var type in events.delegatedEvents) {\n        var delegated = events.delegatedEvents[type];\n\n        for (var i = 0; i < delegated.selectors.length; i++) {\n          if (delegated.selectors[i] === this.selector && delegated.contexts[i] === this._context) {\n\n            delegated.selectors.splice(i, 1);\n            delegated.contexts.splice(i, 1);\n            delegated.listeners.splice(i, 1);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegated[type] = null;\n            }\n          }\n\n          events.remove(this._context, type, events.delegateListener);\n          events.remove(this._context, type, events.delegateUseCapture, true);\n\n          break;\n        }\n      }\n    }\n\n    signals.fire('interactable-unset', { interactable: this });\n\n    scope.interactables.splice(isType.indexOf(scope.interactables, this), 1);\n\n    return scope.interact;\n  };\n\n  return Interactable;\n})();\n\nInteractable.prototype.defaultActionChecker = actions.defaultChecker;\n\nmodule.exports = Interactable;\n\n},{\"./actions/base\":5,\"./scope\":19,\"./utils/arr\":20,\"./utils/domUtils\":23,\"./utils/events\":24,\"./utils/extend\":25,\"./utils/isType\":30,\"./utils/signals\":34}],4:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar scope = require('./scope');\nvar utils = require('./utils');\nvar InteractEvent = require('./InteractEvent');\nvar events = require('./utils/events');\nvar signals = require('./utils/signals');\nvar browser = require('./utils/browser');\nvar finder = require('./utils/interactionFinder');\nvar actions = require('./actions/base');\nvar modifiers = require('./modifiers/base');\nvar animationFrame = utils.raf;\n\nvar listeners = {};\nvar methodNames = ['pointerOver', 'pointerOut', 'pointerHover', 'selectorDown', 'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd', 'addPointer', 'removePointer', 'recordPointer'];\n\n// for ignoring browser's simulated mouse events\nvar prevTouchTime = 0;\n\n// all active and idle interactions\nscope.interactions = [];\n\nvar Interaction = (function () {\n  function Interaction() {\n    var _this = this;\n\n    _classCallCheck(this, Interaction);\n\n    this.target = null; // current interactable being interacted with\n    this.element = null; // the target element of the interactable\n\n    this.matches = []; // all selectors that are matched by target element\n    this.matchElements = []; // corresponding elements\n\n    this.prepared = { // action that's ready to be fired on next move event\n      name: null,\n      axis: null,\n      edges: null\n    };\n\n    this.inertiaStatus = {\n      active: false,\n      smoothEnd: false,\n      ending: false,\n\n      startEvent: null,\n      upCoords: {},\n\n      xe: 0, ye: 0,\n      sx: 0, sy: 0,\n\n      t0: 0,\n      vx0: 0, vys: 0,\n      duration: 0,\n\n      resumeDx: 0,\n      resumeDy: 0,\n\n      lambda_v0: 0,\n      one_ve_v0: 0,\n      i: null\n    };\n\n    this.boundInertiaFrame = function () {\n      return _this.inertiaFrame();\n    };\n    this.boundSmoothEndFrame = function () {\n      return _this.smoothEndFrame();\n    };\n\n    // keep track of added pointers\n    this.pointers = [];\n    this.pointerIds = [];\n    this.downTargets = [];\n    this.downTimes = [];\n    this.holdTimers = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      client: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      timeStamp: 0\n    };\n\n    this.downEvent = null; // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null; // previous action event\n\n    this.startOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n    this.modifierOffsets = {};\n    this.modifierStatuses = modifiers.resetStatuses({});\n\n    this.pointerIsDown = false;\n    this.pointerWasMoved = false;\n    this._interacting = false;\n\n    this.mouse = false;\n\n    signals.fire('interaction-new', this);\n\n    scope.interactions.push(this);\n  }\n\n  // Check if the current target supports the action.\n  // If so, return the validated action. Otherwise, return null\n\n  Interaction.prototype.setEventXY = function setEventXY(targetObj, pointers) {\n    var pointer = pointers.length > 1 ? utils.pointerAverage(pointers) : pointers[0];\n\n    var tmpXY = {};\n\n    utils.getPageXY(pointer, tmpXY, this);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    utils.getClientXY(pointer, tmpXY, this);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = new Date().getTime();\n  };\n\n  Interaction.prototype.pointerOver = function pointerOver(pointer, event, eventTarget) {\n    if (this.prepared.name || !this.mouse) {\n      return;\n    }\n\n    var curMatches = [];\n    var curMatchElements = [];\n    var prevTargetElement = this.element;\n\n    this.addPointer(pointer);\n\n    if (this.target && (scope.testIgnore(this.target, this.element, eventTarget) || !scope.testAllow(this.target, this.element, eventTarget))) {\n      // if the eventTarget should be ignored or shouldn't be allowed\n      // clear the previous target\n      this.target = null;\n      this.element = null;\n      this.matches = [];\n      this.matchElements = [];\n    }\n\n    var elementInteractable = scope.interactables.get(eventTarget);\n    var elementAction = elementInteractable && !scope.testIgnore(elementInteractable, eventTarget, eventTarget) && scope.testAllow(elementInteractable, eventTarget, eventTarget) && validateAction(elementInteractable.getAction(pointer, event, this, eventTarget), elementInteractable);\n\n    if (elementAction && !scope.withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n      elementAction = null;\n    }\n\n    function pushCurMatches(interactable, selector) {\n      if (interactable && scope.inContext(interactable, eventTarget) && !scope.testIgnore(interactable, eventTarget, eventTarget) && scope.testAllow(interactable, eventTarget, eventTarget) && utils.matchesSelector(eventTarget, selector)) {\n\n        curMatches.push(interactable);\n        curMatchElements.push(eventTarget);\n      }\n    }\n\n    if (elementAction) {\n      this.target = elementInteractable;\n      this.element = eventTarget;\n      this.matches = [];\n      this.matchElements = [];\n    } else {\n      scope.interactables.forEachSelector(pushCurMatches);\n\n      if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n        this.matches = curMatches;\n        this.matchElements = curMatchElements;\n\n        this.pointerHover(pointer, event, this.matches, this.matchElements);\n        events.add(eventTarget, scope.PointerEvent ? browser.pEventTypes.move : 'mousemove', listeners.pointerHover);\n      } else if (this.target) {\n        if (utils.nodeContains(prevTargetElement, eventTarget)) {\n          this.pointerHover(pointer, event, this.matches, this.matchElements);\n          events.add(this.element, scope.PointerEvent ? browser.pEventTypes.move : 'mousemove', listeners.pointerHover);\n        } else {\n          this.target = null;\n          this.element = null;\n          this.matches = [];\n          this.matchElements = [];\n        }\n      }\n    }\n  };\n\n  // Check what action would be performed on pointerMove target if a mouse\n  // button were pressed and change the cursor accordingly\n\n  Interaction.prototype.pointerHover = function pointerHover(pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n    var target = this.target;\n\n    if (!this.prepared.name && this.mouse) {\n\n      var action = undefined;\n\n      // update pointer coords for defaultActionChecker to use\n      this.setEventXY(this.curCoords, [pointer]);\n\n      if (matches) {\n        action = this.validateSelector(pointer, event, matches, matchElements);\n      } else if (target) {\n        action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n      }\n\n      if (target && target.options.styleCursor) {\n        if (action) {\n          target._doc.documentElement.style.cursor = actions[action.name].getCursor(action);\n        } else {\n          target._doc.documentElement.style.cursor = '';\n        }\n      }\n    } else if (this.prepared.name) {\n      this.checkAndPreventDefault(event, target, this.element);\n    }\n  };\n\n  Interaction.prototype.pointerOut = function pointerOut(pointer, event, eventTarget) {\n    if (this.prepared.name) {\n      return;\n    }\n\n    // Remove temporary event listeners for selector Interactables\n    if (!scope.interactables.get(eventTarget)) {\n      events.remove(eventTarget, scope.PointerEvent ? browser.pEventTypes.move : 'mousemove', listeners.pointerHover);\n    }\n\n    if (this.target && this.target.options.styleCursor && !this.interacting()) {\n      this.target._doc.documentElement.style.cursor = '';\n    }\n  };\n\n  Interaction.prototype.selectorDown = function selectorDown(pointer, event, eventTarget, curEventTarget) {\n    var _this2 = this;\n\n    var pointerIndex = this.addPointer(pointer);\n    var element = eventTarget;\n    var action = undefined;\n\n    this.pointerIsDown = true;\n\n    signals.fire('interaction-down', {\n      pointer: pointer,\n      event: event,\n      eventTarget: eventTarget,\n      pointerIndex: pointerIndex,\n      interaction: this\n    });\n\n    // Check if the down event hits the current inertia target\n    if (this.inertiaStatus.active && this.target.selector) {\n      // climb up the DOM tree from the event target\n      while (utils.isElement(element)) {\n\n        // if this element is the current inertia target element\n        if (element === this.element\n        // and the prospective action is the same as the ongoing one\n         && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\n          // stop inertia so that the next move will be a normal one\n          animationFrame.cancel(this.inertiaStatus.i);\n          this.inertiaStatus.active = false;\n\n          return;\n        }\n        element = utils.parentElement(element);\n      }\n    }\n\n    // do nothing if interacting\n    if (this.interacting()) {\n      return;\n    }\n\n    var pushMatches = function (interactable, selector, context) {\n      var elements = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n      if (scope.inContext(interactable, element) && !scope.testIgnore(interactable, element, eventTarget) && scope.testAllow(interactable, element, eventTarget) && utils.matchesSelector(element, selector, elements)) {\n\n        _this2.matches.push(interactable);\n        _this2.matchElements.push(element);\n      }\n    };\n\n    // update pointer coords for defaultActionChecker to use\n    this.setEventXY(this.curCoords, [pointer]);\n    this.downEvent = event;\n\n    while (utils.isElement(element) && !action) {\n      this.matches = [];\n      this.matchElements = [];\n\n      scope.interactables.forEachSelector(pushMatches);\n\n      action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n      element = utils.parentElement(element);\n    }\n\n    if (action) {\n      this.prepared.name = action.name;\n      this.prepared.axis = action.axis;\n      this.prepared.edges = action.edges;\n\n      return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n    } else {\n      // do these now since pointerDown isn't being called from here\n      this.downTimes[pointerIndex] = new Date().getTime();\n      this.downTargets[pointerIndex] = eventTarget;\n      utils.pointerExtend(this.downPointer, pointer);\n\n      utils.copyCoords(this.prevCoords, this.curCoords);\n      this.pointerWasMoved = false;\n    }\n  };\n\n  // Determine action to be performed on next pointerMove and add appropriate\n  // style and event Listeners\n\n  Interaction.prototype.pointerDown = function pointerDown(pointer, event, eventTarget, curEventTarget, forceAction) {\n    if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n      this.checkAndPreventDefault(event, this.target, this.element);\n\n      return;\n    }\n\n    this.pointerIsDown = true;\n    this.downEvent = event;\n\n    var pointerIndex = this.addPointer(pointer);\n    var action = undefined;\n\n    // If it is the second touch of a multi-touch gesture, keep the\n    // target the same and get a new action if a target was set by the\n    // first touch\n    if (this.pointerIds.length > 1 && this.target._element === this.element) {\n      var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\n      if (scope.withinInteractionLimit(this.target, this.element, newAction)) {\n        action = newAction;\n      }\n\n      this.prepared.name = null;\n    }\n    // Otherwise, set the target if there is no action prepared\n    else if (!this.prepared.name) {\n        var interactable = scope.interactables.get(curEventTarget);\n\n        if (interactable && !scope.testIgnore(interactable, curEventTarget, eventTarget) && scope.testAllow(interactable, curEventTarget, eventTarget) && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget)) && scope.withinInteractionLimit(interactable, curEventTarget, action)) {\n          this.target = interactable;\n          this.element = curEventTarget;\n        }\n      }\n\n    var target = this.target;\n    var options = target && target.options;\n\n    if (target && (forceAction || !this.prepared.name)) {\n      action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\n      this.setEventXY(this.startCoords, this.pointers);\n\n      if (!action) {\n        return;\n      }\n\n      if (options.styleCursor) {\n        target._doc.documentElement.style.cursor = actions[action.name].getCursor(action);\n      }\n\n      this.resizeAxes = action.name === 'resize' ? action.axis : null;\n\n      if (action === 'gesture' && this.pointerIds.length < 2) {\n        action = null;\n      }\n\n      this.prepared.name = action.name;\n      this.prepared.axis = action.axis;\n      this.prepared.edges = action.edges;\n\n      modifiers.resetStatuses(this.modifierStatuses);\n\n      this.downTimes[pointerIndex] = new Date().getTime();\n      this.downTargets[pointerIndex] = eventTarget;\n      utils.pointerExtend(this.downPointer, pointer);\n\n      utils.copyCoords(this.prevCoords, this.startCoords);\n      this.pointerWasMoved = false;\n\n      this.checkAndPreventDefault(event, target, this.element);\n    }\n    // if inertia is active try to resume action\n    else if (this.inertiaStatus.active && curEventTarget === this.element && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\n        animationFrame.cancel(this.inertiaStatus.i);\n        this.inertiaStatus.active = false;\n\n        this.checkAndPreventDefault(event, target, this.element);\n      }\n  };\n\n  Interaction.prototype.setStartOffsets = function setStartOffsets(action, interactable, element) {\n    var rect = interactable.getRect(element);\n\n    if (rect) {\n      this.startOffset.left = this.startCoords.page.x - rect.left;\n      this.startOffset.top = this.startCoords.page.y - rect.top;\n\n      this.startOffset.right = rect.right - this.startCoords.page.x;\n      this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n      if (!('width' in rect)) {\n        rect.width = rect.right - rect.left;\n      }\n      if (!('height' in rect)) {\n        rect.height = rect.bottom - rect.top;\n      }\n    } else {\n      this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n    }\n\n    modifiers.setOffsets(this, interactable, element, rect, this.modifierOffsets);\n  };\n\n  /*\\\n   * Interaction.start\n   [ method ]\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate number\n   * of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   - action       (object)  The action to be performed - drag, resize, etc.\n   - interactable (Interactable) The Interactable to target\n   - element      (Element) The DOM Element to target\n   = (object) interact\n   **\n   | interact(target)\n   |   .draggable({\n   |     // disable the default drag start by down->move\n   |     manualStart: true\n   |   })\n   |   // start dragging after the user holds the pointer down\n   |   .on('hold', function (event) {\n   |     var interaction = event.interaction;\n   |\n   |     if (!interaction.interacting()) {\n   |       interaction.start({ name: 'drag' },\n   |                         event.interactable,\n   |                         event.currentTarget);\n   |     }\n   | });\n   \\*/\n\n  Interaction.prototype.start = function start(action, interactable, element) {\n    if (this.interacting() || !this.pointerIsDown || this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)) {\n      return;\n    }\n\n    // if this interaction had been removed after stopping\n    // add it back\n    if (utils.indexOf(scope.interactions, this) === -1) {\n      scope.interactions.push(this);\n    }\n\n    // set the startCoords if there was no prepared action\n    if (!this.prepared.name) {\n      this.setEventXY(this.startCoords, this.pointers);\n    }\n\n    this.prepared.name = action.name;\n    this.prepared.axis = action.axis;\n    this.prepared.edges = action.edges;\n    this.target = interactable;\n    this.element = element;\n\n    this.setStartOffsets(action.name, interactable, element, this.modifierOffsets);\n\n    modifiers.setAll(this, this.startCoords.page, this.modifierStatuses);\n\n    this.prevEvent = actions[this.prepared.name].start(this, this.downEvent);\n  };\n\n  Interaction.prototype.pointerMove = function pointerMove(pointer, event, eventTarget, curEventTarget, preEnd) {\n    if (this.inertiaStatus.active) {\n      var pageUp = this.inertiaStatus.upCoords.page;\n      var clientUp = this.inertiaStatus.upCoords.client;\n\n      this.setEventXY(this.curCoords, [{\n        pageX: pageUp.x + this.inertiaStatus.sx,\n        pageY: pageUp.y + this.inertiaStatus.sy,\n        clientX: clientUp.x + this.inertiaStatus.sx,\n        clientY: clientUp.y + this.inertiaStatus.sy\n      }]);\n    } else {\n      this.recordPointer(pointer);\n      this.setEventXY(this.curCoords, this.pointers);\n    }\n\n    var duplicateMove = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y;\n\n    var dx = undefined;\n    var dy = undefined;\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.curCoords.client.x - this.startCoords.client.x;\n      dy = this.curCoords.client.y - this.startCoords.client.y;\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > scope.pointerMoveTolerance;\n    }\n\n    signals.fire('interaction-move', {\n      pointer: pointer,\n      event: event,\n      eventTarget: eventTarget,\n      dx: dx,\n      dy: dy,\n      interaction: this,\n      duplicate: duplicateMove\n    });\n\n    if (!this.pointerIsDown) {\n      return;\n    }\n\n    if (duplicateMove && this.pointerWasMoved && !preEnd) {\n      this.checkAndPreventDefault(event, this.target, this.element);\n      return;\n    }\n\n    // set pointer coordinate, time changes and speeds\n    utils.setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n    if (!this.prepared.name) {\n      return;\n    }\n\n    if (this.pointerWasMoved\n    // ignore movement while inertia is active\n     && (!this.inertiaStatus.active || pointer instanceof InteractEvent && /inertiastart/.test(pointer.type))) {\n\n      // if just starting an action, calculate the pointer speed now\n      if (!this.interacting()) {\n        utils.setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n        actions[this.prepared.name].beforeStart(this, pointer, event, eventTarget, curEventTarget, dx, dy);\n      }\n\n      var starting = !!this.prepared.name && !this.interacting();\n\n      if (starting && (this.target.options[this.prepared.name].manualStart || !scope.withinInteractionLimit(this.target, this.element, this.prepared))) {\n        this.stop(event);\n        return;\n      }\n\n      if (this.prepared.name && this.target) {\n        if (starting) {\n          this.start(this.prepared, this.target, this.element);\n        }\n\n        var modifierResult = modifiers.setAll(this, this.curCoords.page, this.modifierStatuses, preEnd);\n\n        // move if snapping or restriction doesn't prevent it\n        if (modifierResult.shouldMove || starting) {\n          this.prevEvent = actions[this.prepared.name].move(this, event);\n        }\n\n        this.checkAndPreventDefault(event, this.target, this.element);\n      }\n    }\n\n    utils.copyCoords(this.prevCoords, this.curCoords);\n\n    signals.fire('interaction-move-done', {\n      pointer: pointer,\n      event: event,\n      interaction: this\n    });\n  };\n\n  Interaction.prototype.pointerUp = function pointerUp(pointer, event, eventTarget, curEventTarget) {\n    var pointerIndex = this.mouse ? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    clearTimeout(this.holdTimers[pointerIndex]);\n\n    signals.fire('interaction-up', {\n      pointer: pointer,\n      event: event,\n      eventTarget: eventTarget,\n      curEventTarget: curEventTarget,\n      interaction: this\n    });\n\n    this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n    this.removePointer(pointer);\n  };\n\n  Interaction.prototype.pointerCancel = function pointerCancel(pointer, event, eventTarget, curEventTarget) {\n    var pointerIndex = this.mouse ? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    clearTimeout(this.holdTimers[pointerIndex]);\n\n    signals.fire('interaction-cancel', {\n      pointer: pointer,\n      event: event,\n      eventTarget: eventTarget,\n      interaction: this\n    });\n\n    this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n    this.removePointer(pointer);\n  };\n\n  // End interact move events and stop auto-scroll unless inertia is enabled\n\n  Interaction.prototype.pointerEnd = function pointerEnd(pointer, event, eventTarget, curEventTarget) {\n    var target = this.target;\n    var options = target && target.options;\n    var inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia;\n    var inertiaStatus = this.inertiaStatus;\n\n    if (this.interacting()) {\n\n      if (inertiaStatus.active && !inertiaStatus.ending) {\n        return;\n      }\n\n      var now = new Date().getTime();\n      var statuses = {};\n      var page = utils.extend({}, this.curCoords.page);\n      var pointerSpeed = undefined;\n      var inertiaPossible = false;\n      var inertia = false;\n      var smoothEnd = false;\n      var modifierResult = undefined;\n\n      if (this.dragging) {\n        if (options.drag.axis === 'x') {\n          pointerSpeed = Math.abs(this.pointerDelta.client.vx);\n        } else if (options.drag.axis === 'y') {\n          pointerSpeed = Math.abs(this.pointerDelta.client.vy);\n        } else /*options.drag.axis === 'xy'*/{\n            pointerSpeed = this.pointerDelta.client.speed;\n          }\n      } else {\n        pointerSpeed = this.pointerDelta.client.speed;\n      }\n\n      // check if inertia should be started\n      inertiaPossible = inertiaOptions && inertiaOptions.enabled && this.prepared.name !== 'gesture' && event !== inertiaStatus.startEvent;\n\n      inertia = inertiaPossible && now - this.curCoords.timeStamp < 50 && pointerSpeed > inertiaOptions.minSpeed && pointerSpeed > inertiaOptions.endSpeed;\n\n      // smoothEnd\n      if (inertiaPossible && !inertia) {\n        modifiers.resetStatuses(statuses);\n\n        modifierResult = modifiers.setAll(this, page, statuses, true);\n\n        if (modifierResult.shouldMove && modifierResult.locked) {\n          smoothEnd = true;\n        }\n      }\n\n      if (inertia || smoothEnd) {\n        utils.copyCoords(inertiaStatus.upCoords, this.curCoords);\n\n        this.pointers[0] = inertiaStatus.startEvent = new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\n        inertiaStatus.t0 = now;\n\n        target.fire(inertiaStatus.startEvent);\n\n        if (inertia) {\n          inertiaStatus.vx0 = this.pointerDelta.client.vx;\n          inertiaStatus.vy0 = this.pointerDelta.client.vy;\n          inertiaStatus.v0 = pointerSpeed;\n\n          this.calcInertia(inertiaStatus);\n\n          utils.extend(page, this.curCoords.page);\n\n          page.x += inertiaStatus.xe;\n          page.y += inertiaStatus.ye;\n\n          modifiers.resetStatuses(statuses);\n\n          modifierResult = modifiers.setAll(this, page, statuses, true, true);\n\n          inertiaStatus.modifiedXe += modifierResult.dx;\n          inertiaStatus.modifiedYe += modifierResult.dy;\n\n          inertiaStatus.i = animationFrame.request(this.boundInertiaFrame);\n        } else {\n          inertiaStatus.smoothEnd = true;\n          inertiaStatus.xe = modifierResult.dx;\n          inertiaStatus.ye = modifierResult.dy;\n\n          inertiaStatus.sx = inertiaStatus.sy = 0;\n\n          inertiaStatus.i = animationFrame.request(this.boundSmoothEndFrame);\n        }\n\n        inertiaStatus.active = true;\n        return;\n      }\n\n      for (var i = 0; i < modifiers.names.length; i++) {\n        // if the endOnly option is true for any modifier\n        if (modifiers[modifiers.names[i]].shouldDo(target, this.prepared.name, true, true)) {\n          // fire a move event at the snapped coordinates\n          this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n          break;\n        }\n      }\n    }\n\n    if (this.interacting()) {\n      actions[this.prepared.name].end(this, event);\n    }\n\n    this.stop(event);\n  };\n\n  Interaction.prototype.currentAction = function currentAction() {\n    return this._interacting ? this.prepared.name : null;\n  };\n\n  Interaction.prototype.interacting = function interacting() {\n    return this._interacting;\n  };\n\n  Interaction.prototype.stop = function stop(event) {\n    signals.fire('interaction-stop', { interaction: this });\n\n    if (this._interacting) {\n      signals.fire('interaction-stop-active', { interaction: this });\n\n      this.matches = [];\n      this.matchElements = [];\n\n      var target = this.target;\n\n      if (target.options.styleCursor) {\n        target._doc.documentElement.style.cursor = '';\n      }\n\n      // prevent Default only if were previously interacting\n      if (event && utils.isFunction(event.preventDefault)) {\n        this.checkAndPreventDefault(event, target, this.element);\n      }\n\n      actions[this.prepared.name].stop(this, event);\n    }\n\n    this.target = this.element = null;\n\n    this.pointerIsDown = this._interacting = false;\n    this.prepared.name = this.prevEvent = null;\n    this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\n    modifiers.resetStatuses(this.modifierStatuses);\n\n    // remove pointers if their ID isn't in this.pointerIds\n    for (var i = 0; i < this.pointers.length; i++) {\n      if (utils.indexOf(this.pointerIds, utils.getPointerId(this.pointers[i])) === -1) {\n        this.pointers.splice(i, 1);\n      }\n    }\n  };\n\n  Interaction.prototype.inertiaFrame = function inertiaFrame() {\n    var inertiaStatus = this.inertiaStatus;\n    var options = this.target.options[this.prepared.name].inertia;\n    var lambda = options.resistance;\n    var t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n    if (t < inertiaStatus.te) {\n\n      var progress = 1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\n      if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n        inertiaStatus.sx = inertiaStatus.xe * progress;\n        inertiaStatus.sy = inertiaStatus.ye * progress;\n      } else {\n        var quadPoint = utils.getQuadraticCurvePoint(0, 0, inertiaStatus.xe, inertiaStatus.ye, inertiaStatus.modifiedXe, inertiaStatus.modifiedYe, progress);\n\n        inertiaStatus.sx = quadPoint.x;\n        inertiaStatus.sy = quadPoint.y;\n      }\n\n      this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n      inertiaStatus.i = animationFrame.request(this.boundInertiaFrame);\n    } else {\n      inertiaStatus.ending = true;\n\n      inertiaStatus.sx = inertiaStatus.modifiedXe;\n      inertiaStatus.sy = inertiaStatus.modifiedYe;\n\n      this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n      this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n      inertiaStatus.active = inertiaStatus.ending = false;\n    }\n  };\n\n  Interaction.prototype.smoothEndFrame = function smoothEndFrame() {\n    var inertiaStatus = this.inertiaStatus;\n    var t = new Date().getTime() - inertiaStatus.t0;\n    var duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n    if (t < duration) {\n      inertiaStatus.sx = utils.easeOutQuad(t, 0, inertiaStatus.xe, duration);\n      inertiaStatus.sy = utils.easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\n      this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n      inertiaStatus.i = animationFrame.request(this.boundSmoothEndFrame);\n    } else {\n      inertiaStatus.ending = true;\n\n      inertiaStatus.sx = inertiaStatus.xe;\n      inertiaStatus.sy = inertiaStatus.ye;\n\n      this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n      this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n      inertiaStatus.smoothEnd = inertiaStatus.active = inertiaStatus.ending = false;\n    }\n  };\n\n  Interaction.prototype.addPointer = function addPointer(pointer) {\n    var id = utils.getPointerId(pointer);\n    var index = this.mouse ? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) {\n      index = this.pointerIds.length;\n    }\n\n    this.pointerIds[index] = id;\n    this.pointers[index] = pointer;\n\n    return index;\n  };\n\n  Interaction.prototype.removePointer = function removePointer(pointer) {\n    var id = utils.getPointerId(pointer);\n    var index = this.mouse ? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) {\n      return;\n    }\n\n    this.pointers.splice(index, 1);\n    this.pointerIds.splice(index, 1);\n    this.downTargets.splice(index, 1);\n    this.downTimes.splice(index, 1);\n    this.holdTimers.splice(index, 1);\n  };\n\n  Interaction.prototype.recordPointer = function recordPointer(pointer) {\n    var index = this.mouse ? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    if (index === -1) {\n      return;\n    }\n\n    this.pointers[index] = pointer;\n  };\n\n  Interaction.prototype.validateSelector = function validateSelector(pointer, event, matches, matchElements) {\n    for (var i = 0, len = matches.length; i < len; i++) {\n      var match = matches[i];\n      var matchElement = matchElements[i];\n      var action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\n      if (action && scope.withinInteractionLimit(match, matchElement, action)) {\n        this.target = match;\n        this.element = matchElement;\n\n        return action;\n      }\n    }\n  };\n\n  Interaction.prototype.checkAndPreventDefault = function checkAndPreventDefault(event, interactable, element) {\n    if (!(interactable = interactable || this.target)) {\n      return;\n    }\n\n    var options = interactable.options;\n    var prevent = options.preventDefault;\n\n    if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n      // do not preventDefault on pointerdown if the prepared action is a drag\n      // and dragging can only start from a certain direction - this allows\n      // a touch to pan the viewport if a drag isn't in the right direction\n      if (/down|start/i.test(event.type) && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\n        return;\n      }\n\n      // with manualStart, only preventDefault while interacting\n      if (options[this.prepared.name] && options[this.prepared.name].manualStart && !this.interacting()) {\n        return;\n      }\n\n      event.preventDefault();\n      return;\n    }\n\n    if (prevent === 'always') {\n      event.preventDefault();\n      return;\n    }\n  };\n\n  Interaction.prototype.calcInertia = function calcInertia(status) {\n    var inertiaOptions = this.target.options[this.prepared.name].inertia;\n    var lambda = inertiaOptions.resistance;\n    var inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n    status.x0 = this.prevEvent.pageX;\n    status.y0 = this.prevEvent.pageY;\n    status.t0 = status.startEvent.timeStamp / 1000;\n    status.sx = status.sy = 0;\n\n    status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n    status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n    status.te = inertiaDur;\n\n    status.lambda_v0 = lambda / status.v0;\n    status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n  };\n\n  Interaction.prototype._updateEventTargets = function _updateEventTargets(target, currentTarget) {\n    this._eventTarget = target;\n    this._curEventTarget = currentTarget;\n  };\n\n  return Interaction;\n})();\n\nfunction validateAction(action, interactable) {\n  if (utils.isObject(action) && interactable.options[action.name].enabled) {\n    return action;\n  }\n\n  return null;\n}\n\nfor (var i = 0, len = methodNames.length; i < len; i++) {\n  var method = methodNames[i];\n\n  listeners[method] = doOnInteractions(method);\n}\n\nfunction doOnInteractions(method) {\n  return function (event) {\n    var eventTarget = utils.getActualElement(event.path ? event.path[0] : event.target);\n    var curEventTarget = utils.getActualElement(event.currentTarget);\n    var matches = []; // [ [pointer, interaction], ...]\n\n    if (browser.supportsTouch && /touch/.test(event.type)) {\n      prevTouchTime = new Date().getTime();\n\n      for (var _iterator = event.changedTouches, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var pointer = _ref;\n\n        var interaction = finder.search(pointer, event.type, eventTarget);\n\n        matches.push([pointer, interaction || new Interaction()]);\n      }\n    } else {\n      var invalidPointer = false;\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (var i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n          invalidPointer = !scope.interactions[i].mouse && scope.interactions[i].pointerIsDown;\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer || new Date().getTime() - prevTouchTime < 500;\n      }\n\n      if (!invalidPointer) {\n        var interaction = finder.search(event, event.type, eventTarget);\n\n        if (!interaction) {\n\n          interaction = new Interaction();\n          interaction.mouse = /mouse/i.test(event.pointerType || event.type)\n          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n           || event.pointerType === 4;\n        }\n\n        matches.push([event, interaction]);\n      }\n    }\n\n    for (var _iterator2 = matches, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var pointer = _ref2[0];\n      var interaction = _ref2[1];\n\n      interaction._updateEventTargets(eventTarget, curEventTarget);\n      interaction[method](pointer, event, eventTarget, curEventTarget);\n    }\n  };\n}\n\nsignals.on('interactable-new', function (_ref4) {\n  var interactable = _ref4.interactable;\n  var win = _ref4.win;\n\n  var element = interactable._element;\n\n  if (utils.isElement(element, win)) {\n    if (scope.PointerEvent) {\n      events.add(element, browser.pEventTypes.down, listeners.pointerDown);\n      events.add(element, browser.pEventTypes.move, listeners.pointerHover);\n    } else {\n      events.add(element, 'mousedown', listeners.pointerDown);\n      events.add(element, 'mousemove', listeners.pointerHover);\n      events.add(element, 'touchstart', listeners.pointerDown);\n      events.add(element, 'touchmove', listeners.pointerHover);\n    }\n  }\n});\n\nsignals.on('interactable-unset', function (_ref5) {\n  var interactable = _ref5.interactable;\n  var win = _ref5.win;\n\n  var element = interactable._element;\n\n  if (!interactable.selector && utils.isElement(element, win)) {\n    if (scope.PointerEvent) {\n      events.remove(element, browser.pEventTypes.down, listeners.pointerDown);\n      events.remove(element, browser.pEventTypes.move, listeners.pointerHover);\n    } else {\n      events.remove(element, 'mousedown', listeners.pointerDown);\n      events.remove(element, 'mousemove', listeners.pointerHover);\n      events.remove(element, 'touchstart', listeners.pointerDown);\n      events.remove(element, 'touchmove', listeners.pointerHover);\n    }\n  }\n});\n\nsignals.on('listen-to-document', function (_ref6) {\n  var doc = _ref6.doc;\n  var win = _ref6.win;\n\n  var pEventTypes = browser.pEventTypes;\n\n  // add delegate event listener\n  for (var eventType in scope.delegatedEvents) {\n    events.add(doc, eventType, events.delegateListener);\n    events.add(doc, eventType, events.delegateUseCapture, true);\n  }\n\n  if (scope.PointerEvent) {\n    events.add(doc, pEventTypes.down, listeners.selectorDown);\n    events.add(doc, pEventTypes.move, listeners.pointerMove);\n    events.add(doc, pEventTypes.over, listeners.pointerOver);\n    events.add(doc, pEventTypes.out, listeners.pointerOut);\n    events.add(doc, pEventTypes.up, listeners.pointerUp);\n    events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n  } else {\n    events.add(doc, 'mousedown', listeners.selectorDown);\n    events.add(doc, 'mousemove', listeners.pointerMove);\n    events.add(doc, 'mouseup', listeners.pointerUp);\n    events.add(doc, 'mouseover', listeners.pointerOver);\n    events.add(doc, 'mouseout', listeners.pointerOut);\n\n    events.add(doc, 'touchstart', listeners.selectorDown);\n    events.add(doc, 'touchmove', listeners.pointerMove);\n    events.add(doc, 'touchend', listeners.pointerUp);\n    events.add(doc, 'touchcancel', listeners.pointerCancel);\n  }\n\n  events.add(win, 'blur', scope.endAllInteractions);\n\n  try {\n    if (win.frameElement) {\n      var parentDoc = win.frameElement.ownerDocument;\n      var parentWindow = parentDoc.defaultView;\n\n      events.add(parentDoc, 'mouseup', listeners.pointerEnd);\n      events.add(parentDoc, 'touchend', listeners.pointerEnd);\n      events.add(parentDoc, 'touchcancel', listeners.pointerEnd);\n      events.add(parentDoc, 'pointerup', listeners.pointerEnd);\n      events.add(parentDoc, 'MSPointerUp', listeners.pointerEnd);\n      events.add(parentWindow, 'blur', scope.endAllInteractions);\n    }\n  } catch (error) {\n    scope.windowParentError = error;\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  events.add(doc, 'dragstart', function (event) {\n    for (var _iterator3 = scope.interactions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var interaction = _ref3;\n\n      if (interaction.element && (interaction.element === event.target || utils.nodeContains(interaction.element, event.target))) {\n\n        interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n        return;\n      }\n    }\n  });\n\n  scope.documents.push(doc);\n  events.documents.push(doc);\n});\n\nsignals.fire('listen-to-document', {\n  win: scope.window,\n  doc: scope.document\n});\n\nInteraction.doOnInteractions = doOnInteractions;\nInteraction.withinLimit = scope.withinInteractionLimit;\n\nmodule.exports = Interaction;\n\n},{\"./InteractEvent\":2,\"./actions/base\":5,\"./modifiers/base\":15,\"./scope\":19,\"./utils\":28,\"./utils/browser\":21,\"./utils/events\":24,\"./utils/interactionFinder\":29,\"./utils/signals\":34}],5:[function(require,module,exports){\nvar actions = {\n  defaultChecker: function (pointer, event, interaction, element) {\n    var rect = this.getRect(element);\n    var action = null;\n\n    for (var _iterator = actions.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var actionName = _ref;\n\n      action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n      if (action) {\n        return action;\n      }\n    }\n  },\n\n  names: [],\n  methodDict: {}\n};\n\nmodule.exports = actions;\n\n},{}],6:[function(require,module,exports){\nvar base = require('./base');\nvar drop = require('./drop');\nvar scope = require('../scope');\nvar utils = require('../utils');\nvar browser = require('../utils/browser');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar defaultOptions = require('../defaultOptions');\n\nvar drag = {\n  defaults: {\n    enabled: false,\n    manualStart: true,\n    max: Infinity,\n    maxPerElement: 1,\n\n    snap: null,\n    restrict: null,\n    inertia: null,\n    autoScroll: null,\n\n    axis: 'xy'\n  },\n\n  checker: function (pointer, event, interactable) {\n    return interactable.options.drag.enabled ? { name: 'drag' } : null;\n  },\n\n  getCursor: function () {\n    return 'move';\n  },\n\n  beforeStart: function (interaction, pointer, event, eventTarget, curEventTarget, dx, dy) {\n    // check if a drag is in the correct axis\n    var absX = Math.abs(dx);\n    var absY = Math.abs(dy);\n    var targetAxis = interaction.target.options.drag.axis;\n    var axis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';\n\n    // if the movement isn't in the axis of the interactable\n    if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n      (function () {\n        // cancel the prepared action\n        interaction.prepared.name = null;\n\n        // then try to get a drag from another ineractable\n\n        var element = eventTarget;\n\n        // check element interactables\n        while (utils.isElement(element)) {\n          var elementInteractable = scope.interactables.get(element);\n\n          if (elementInteractable && elementInteractable !== interaction.target && !elementInteractable.options.drag.manualStart && elementInteractable.getAction(interaction.downPointer, interaction.downEvent, interaction, element).name === 'drag' && checkAxis(axis, elementInteractable)) {\n\n            interaction.prepared.name = 'drag';\n            interaction.target = elementInteractable;\n            interaction.element = element;\n            break;\n          }\n\n          element = utils.parentElement(element);\n        }\n\n        // if there's no drag from element interactables,\n        // check the selector interactables\n        if (!interaction.prepared.name) {\n\n          var getDraggable = function (interactable, selector, context) {\n            var elements = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n            if (interactable === interaction.target) {\n              return;\n            }\n\n            if (scope.inContext(interactable, eventTarget) && !interactable.options.drag.manualStart && !scope.testIgnore(interactable, element, eventTarget) && scope.testAllow(interactable, element, eventTarget) && utils.matchesSelector(element, selector, elements) && interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element).name === 'drag' && checkAxis(axis, interactable) && scope.withinInteractionLimit(interactable, element, 'drag')) {\n\n              return interactable;\n            }\n          };\n\n          element = eventTarget;\n\n          while (utils.isElement(element)) {\n            var selectorInteractable = scope.interactables.forEachSelector(getDraggable);\n\n            if (selectorInteractable) {\n              interaction.prepared.name = 'drag';\n              interaction.target = selectorInteractable;\n              interaction.element = element;\n              break;\n            }\n\n            element = utils.parentElement(element);\n          }\n        }\n      })();\n    }\n  },\n\n  start: function (interaction, event) {\n    var dragEvent = new InteractEvent(interaction, event, 'drag', 'start', interaction.element);\n\n    interaction._interacting = true;\n    interaction.target.fire(dragEvent);\n\n    drop.start(interaction, event, dragEvent);\n\n    return dragEvent;\n  },\n\n  move: function (interaction, event) {\n    var dragEvent = new InteractEvent(interaction, event, 'drag', 'move', interaction.element);\n\n    drop.move(interaction, event, dragEvent);\n\n    return dragEvent;\n  },\n\n  end: function (interaction, event) {\n    var endEvent = new InteractEvent(interaction, event, 'drag', 'end', interaction.element);\n\n    drop.end(interaction, event, endEvent);\n\n    interaction.target.fire(endEvent);\n  },\n\n  stop: drop.stop\n};\n\nfunction checkAxis(axis, interactable) {\n  if (!interactable) {\n    return false;\n  }\n\n  var thisAxis = interactable.options.drag.axis;\n\n  return axis === 'xy' || thisAxis === 'xy' || thisAxis === axis;\n}\n\n/*\\\n * Interactable.draggable\n [ method ]\n *\n * Gets or sets whether drag actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of drag events\n | var isDraggable = interact('ul li').draggable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n = (object) This Interactable\n | interact(element).draggable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // the axis in which the first movement must be\n |     // for the drag sequence to start\n |     // 'xy' by default - any direction\n |     axis: 'x' || 'y' || 'xy',\n |\n |     // max number of drags that can happen concurrently\n |     // with elements of this Interactable. Infinity by default\n |     max: Infinity,\n |\n |     // max number of drags that can target the same element+Interactable\n |     // 1 by default\n |     maxPerElement: 2\n | });\n\\*/\nInteractable.prototype.draggable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drag.enabled = options.enabled === false ? false : true;\n    this.setPerAction('drag', options);\n    this.setOnEvents('drag', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.drag.axis = options.axis;\n    } else if (options.axis === null) {\n      delete this.options.drag.axis;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drag.enabled = options;\n\n    return this;\n  }\n\n  return this.options.drag;\n};\n\nbase.drag = drag;\nbase.names.push('drag');\nutils.merge(scope.eventTypes, ['dragstart', 'dragmove', 'draginertiastart', 'dragend']);\nbase.methodDict.drag = 'draggable';\n\ndefaultOptions.drag = drag.defaults;\n\nmodule.exports = drag;\n\n},{\"../InteractEvent\":2,\"../Interactable\":3,\"../defaultOptions\":11,\"../scope\":19,\"../utils\":28,\"../utils/browser\":21,\"./base\":5,\"./drop\":7}],7:[function(require,module,exports){\nvar base = require('./base');\nvar utils = require('../utils');\nvar scope = require('../scope');\nvar signals = require('../utils/signals');\nvar Interactable = require('../Interactable');\nvar defaultOptions = require('../defaultOptions');\n\nvar drop = {\n  defaults: {\n    enabled: false,\n    accept: null,\n    overlap: 'pointer'\n  },\n\n  start: function (interaction, event, dragEvent) {\n    // reset active dropzones\n    interaction.activeDrops.dropzones = [];\n    interaction.activeDrops.elements = [];\n    interaction.activeDrops.rects = [];\n\n    if (!interaction.dynamicDrop) {\n      setActiveDrops(interaction, interaction.element);\n    }\n\n    var dropEvents = getDropEvents(interaction, event, dragEvent);\n\n    if (dropEvents.activate) {\n      fireActiveDrops(interaction, dropEvents.activate);\n    }\n  },\n\n  move: function (interaction, event, dragEvent) {\n    var draggableElement = interaction.element;\n    var dropOptions = getDrop(dragEvent, event, draggableElement);\n\n    interaction.dropTarget = dropOptions.dropzone;\n    interaction.dropElement = dropOptions.element;\n\n    var dropEvents = getDropEvents(interaction, event, dragEvent);\n\n    interaction.target.fire(dragEvent);\n\n    if (dropEvents.leave) {\n      interaction.prevDropTarget.fire(dropEvents.leave);\n    }\n    if (dropEvents.enter) {\n      interaction.dropTarget.fire(dropEvents.enter);\n    }\n    if (dropEvents.move) {\n      interaction.dropTarget.fire(dropEvents.move);\n    }\n\n    interaction.prevDropTarget = interaction.dropTarget;\n    interaction.prevDropElement = interaction.dropElement;\n  },\n\n  end: function (interaction, event, endEvent) {\n    var draggableElement = interaction.element;\n    var dropResult = getDrop(endEvent, event, draggableElement);\n\n    interaction.dropTarget = dropResult.dropzone;\n    interaction.dropElement = dropResult.element;\n\n    var dropEvents = getDropEvents(interaction, event, endEvent);\n\n    if (dropEvents.leave) {\n      interaction.prevDropTarget.fire(dropEvents.leave);\n    }\n    if (dropEvents.enter) {\n      interaction.dropTarget.fire(dropEvents.enter);\n    }\n    if (dropEvents.drop) {\n      interaction.dropTarget.fire(dropEvents.drop);\n    }\n    if (dropEvents.deactivate) {\n      fireActiveDrops(interaction, dropEvents.deactivate);\n    }\n  },\n\n  stop: function (interaction) {\n    interaction.activeDrops.dropzones = interaction.activeDrops.elements = interaction.activeDrops.rects = null;\n  }\n};\n\nfunction collectDrops(interaction, element) {\n  var drops = [];\n  var elements = [];\n\n  element = element || interaction.element;\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (var _iterator = scope.interactables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var current = _ref;\n\n    if (!current.options.drop.enabled) {\n      continue;\n    }\n\n    var accept = current.options.drop.accept;\n\n    // test the draggable element against the dropzone's accept setting\n    if (utils.isElement(accept) && accept !== element || utils.isString(accept) && !utils.matchesSelector(element, accept)) {\n\n      continue;\n    }\n\n    // query for new elements if necessary\n    var dropElements = current.selector ? current._context.querySelectorAll(current.selector) : [current._element];\n\n    for (var i = 0; i < dropElements.length; i++) {\n      var currentElement = dropElements[i];\n\n      if (currentElement !== element) {\n        drops.push(current);\n        elements.push(currentElement);\n      }\n    }\n  }\n\n  return {\n    elements: elements,\n    dropzones: drops\n  };\n}\n\nfunction fireActiveDrops(interaction, event) {\n  var prevElement = undefined;\n\n  // loop through all active dropzones and trigger event\n  for (var i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    var current = interaction.activeDrops.dropzones[i];\n    var currentElement = interaction.activeDrops.elements[i];\n\n    // prevent trigger of duplicate events on same element\n    if (currentElement !== prevElement) {\n      // set current element as event target\n      event.target = currentElement;\n      current.fire(event);\n    }\n    prevElement = currentElement;\n  }\n}\n\n// Collect a new set of possible drops and save them in activeDrops.\n// setActiveDrops should always be called when a drag has just started or a\n// drag event happens while dynamicDrop is true\nfunction setActiveDrops(interaction, dragElement) {\n  // get dropzones and their elements that could receive the draggable\n  var possibleDrops = collectDrops(interaction, dragElement, true);\n\n  interaction.activeDrops.dropzones = possibleDrops.dropzones;\n  interaction.activeDrops.elements = possibleDrops.elements;\n  interaction.activeDrops.rects = [];\n\n  for (var i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    interaction.activeDrops.rects[i] = interaction.activeDrops.dropzones[i].getRect(interaction.activeDrops.elements[i]);\n  }\n}\n\nfunction getDrop(dragEvent, event, dragElement) {\n  var interaction = dragEvent.interaction;\n  var validDrops = [];\n\n  if (scope.dynamicDrop) {\n    setActiveDrops(interaction, dragElement);\n  }\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (var j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n    var current = interaction.activeDrops.dropzones[j];\n    var currentElement = interaction.activeDrops.elements[j];\n    var rect = interaction.activeDrops.rects[j];\n\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect) ? currentElement : null);\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  var dropIndex = utils.indexOfDeepestElement(validDrops);\n\n  return {\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n    element: interaction.activeDrops.elements[dropIndex] || null\n  };\n}\n\nfunction getDropEvents(interaction, pointerEvent, dragEvent) {\n  var dropEvents = {\n    enter: null,\n    leave: null,\n    activate: null,\n    deactivate: null,\n    move: null,\n    drop: null\n  };\n\n  if (interaction.dropElement !== interaction.prevDropElement) {\n    // if there was a prevDropTarget, create a dragleave event\n    if (interaction.prevDropTarget) {\n      dropEvents.leave = {\n        dragEvent: dragEvent,\n        interaction: interaction,\n        target: interaction.prevDropElement,\n        dropzone: interaction.prevDropTarget,\n        relatedTarget: dragEvent.target,\n        draggable: dragEvent.interactable,\n        timeStamp: dragEvent.timeStamp,\n        type: 'dragleave'\n      };\n\n      dragEvent.dragLeave = interaction.prevDropElement;\n      dragEvent.prevDropzone = interaction.prevDropTarget;\n    }\n    // if the dropTarget is not null, create a dragenter event\n    if (interaction.dropTarget) {\n      dropEvents.enter = {\n        dragEvent: dragEvent,\n        interaction: interaction,\n        target: interaction.dropElement,\n        dropzone: interaction.dropTarget,\n        relatedTarget: dragEvent.target,\n        draggable: dragEvent.interactable,\n        timeStamp: dragEvent.timeStamp,\n        type: 'dragenter'\n      };\n\n      dragEvent.dragEnter = interaction.dropElement;\n      dragEvent.dropzone = interaction.dropTarget;\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n    dropEvents.drop = {\n      dragEvent: dragEvent,\n      interaction: interaction,\n      target: interaction.dropElement,\n      dropzone: interaction.dropTarget,\n      relatedTarget: dragEvent.target,\n      draggable: dragEvent.interactable,\n      timeStamp: dragEvent.timeStamp,\n      type: 'drop'\n    };\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = {\n      dragEvent: dragEvent,\n      interaction: interaction,\n      target: null,\n      dropzone: null,\n      relatedTarget: dragEvent.target,\n      draggable: dragEvent.interactable,\n      timeStamp: dragEvent.timeStamp,\n      type: 'dropactivate'\n    };\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = {\n      dragEvent: dragEvent,\n      interaction: interaction,\n      target: null,\n      dropzone: null,\n      relatedTarget: dragEvent.target,\n      draggable: dragEvent.interactable,\n      timeStamp: dragEvent.timeStamp,\n      type: 'dropdeactivate'\n    };\n  }\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n    dropEvents.move = {\n      dragEvent: dragEvent,\n      interaction: interaction,\n      target: interaction.dropElement,\n      dropzone: interaction.dropTarget,\n      relatedTarget: dragEvent.target,\n      draggable: dragEvent.interactable,\n      dragmove: dragEvent,\n      timeStamp: dragEvent.timeStamp,\n      type: 'dropmove'\n    };\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n\n  return dropEvents;\n}\n\n/*\\\n * Interactable.dropzone\n [ method ]\n *\n * Returns or sets whether elements can be dropped onto this\n * Interactable to trigger drop events\n *\n * Dropzones can receive the following events:\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n *  - `dragmove` when a draggable that has entered the dropzone is moved\n *  - `drop` when a draggable is dropped into this dropzone\n *\n * Use the `accept` option to allow only elements that match the given CSS\n * selector or element. The value can be:\n *\n *  - **an Element** - only that element can be dropped into this dropzone.\n *  - **a string**, - the element being dragged must match it as a CSS selector.\n *  - **`null`** - accept options is cleared - it accepts any element.\n *\n * Use the `overlap` option to set how drops are checked for. The allowed\n * values are:\n *\n *   - `'pointer'`, the pointer must be over the dropzone (default)\n *   - `'center'`, the draggable element's center must be over the dropzone\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n *   over the dropzone\n *\n * Use the `checker` option to specify a function to check if a dragged\n * element is over this Interactable.\n *\n | interact(target)\n | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n |                       event,             // TouchEvent/PointerEvent/MouseEvent\n |                       dropped,           // bool result of the default checker\n |                       dropzone,          // dropzone Interactable\n |                       dropElement,       // dropzone elemnt\n |                       draggable,         // draggable Interactable\n |                       draggableElement) {// draggable element\n |\n |   return dropped && event.target.hasAttribute('allow-drop');\n | }\n *\n *\n - options (boolean | object | null) #optional The new value to be set.\n | interact('.drop').dropzone({\n |   accept: '.can-drop' || document.getElementById('single-drop'),\n |   overlap: 'pointer' || 'center' || zeroToOne\n | }\n = (boolean | object) The current setting or this Interactable\n\\*/\nInteractable.prototype.dropzone = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drop.enabled = options.enabled === false ? false : true;\n\n    if (utils.isFunction(options.ondrop)) {\n      this.ondrop = options.ondrop;\n    }\n    if (utils.isFunction(options.ondropactivate)) {\n      this.ondropactivate = options.ondropactivate;\n    }\n    if (utils.isFunction(options.ondropdeactivate)) {\n      this.ondropdeactivate = options.ondropdeactivate;\n    }\n    if (utils.isFunction(options.ondragenter)) {\n      this.ondragenter = options.ondragenter;\n    }\n    if (utils.isFunction(options.ondragleave)) {\n      this.ondragleave = options.ondragleave;\n    }\n    if (utils.isFunction(options.ondropmove)) {\n      this.ondropmove = options.ondropmove;\n    }\n\n    if (/^(pointer|center)$/.test(options.overlap)) {\n      this.options.drop.overlap = options.overlap;\n    } else if (utils.isNumber(options.overlap)) {\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n    }\n    if ('accept' in options) {\n      this.options.drop.accept = options.accept;\n    }\n    if ('checker' in options) {\n      this.options.drop.checker = options.checker;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drop.enabled = options;\n\n    return this;\n  }\n\n  return this.options.drop;\n};\n\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n  var dropped = false;\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || this.getRect(dropElement))) {\n    return this.options.drop.checker ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement) : false;\n  }\n\n  var dropOverlap = this.options.drop.overlap;\n\n  if (dropOverlap === 'pointer') {\n    var origin = utils.getOriginXY(draggable, draggableElement);\n    var page = utils.getPageXY(dragEvent);\n    var horizontal = undefined;\n    var vertical = undefined;\n\n    page.x += origin.x;\n    page.y += origin.y;\n\n    horizontal = page.x > rect.left && page.x < rect.right;\n    vertical = page.y > rect.top && page.y < rect.bottom;\n\n    dropped = horizontal && vertical;\n  }\n\n  var dragRect = draggable.getRect(draggableElement);\n\n  if (dropOverlap === 'center') {\n    var cx = dragRect.left + dragRect.width / 2;\n    var cy = dragRect.top + dragRect.height / 2;\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n  }\n\n  if (utils.isNumber(dropOverlap)) {\n    var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));\n\n    var overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n    dropped = overlapRatio >= dropOverlap;\n  }\n\n  if (this.options.drop.checker) {\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n  }\n\n  return dropped;\n};\n\nsignals.on('interactable-unset', function (_ref2) {\n  var interactable = _ref2.interactable;\n\n  interactable.dropzone(false);\n});\n\nsignals.on('interaction-new', function (interaction) {\n  interaction.dropTarget = null; // the dropzone a drag target might be dropped into\n  interaction.dropElement = null; // the element at the time of checking\n  interaction.prevDropTarget = null; // the dropzone that was recently dragged away from\n  interaction.prevDropElement = null; // the element at the time of checking\n\n  interaction.activeDrops = {\n    dropzones: [], // the dropzones that are mentioned below\n    elements: [], // elements of dropzones that accept the target draggable\n    rects: [] };\n});\n\n// the rects of the elements mentioned above\nsignals.on('interaction-stop', function (_ref3) {\n  var interaction = _ref3.interaction;\n\n  interaction.dropTarget = interaction.dropElement = interaction.prevDropTarget = interaction.prevDropElement = null;\n});\n\nutils.merge(scope.eventTypes, ['dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop']);\nbase.methodDict.drop = 'dropzone';\n\ndefaultOptions.drop = drop.defaults;\n\nmodule.exports = drop;\n\n},{\"../Interactable\":3,\"../defaultOptions\":11,\"../scope\":19,\"../utils\":28,\"../utils/signals\":34,\"./base\":5}],8:[function(require,module,exports){\nvar base = require('./base');\nvar utils = require('../utils');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar scope = require('../scope');\nvar signals = require('../utils/signals');\nvar defaultOptions = require('../defaultOptions');\n\nvar gesture = {\n  defaults: {\n    manualStart: false,\n    enabled: false,\n    max: Infinity,\n    maxPerElement: 1,\n\n    restrict: null\n  },\n\n  checker: function (pointer, event, interactable, element, interaction) {\n    if (interaction.pointerIds.length >= 2) {\n      return { name: 'gesture' };\n    }\n\n    return null;\n  },\n\n  getCursor: function () {\n    return '';\n  },\n\n  beforeStart: utils.blank,\n\n  start: function (interaction, event) {\n    var gestureEvent = new InteractEvent(interaction, event, 'gesture', 'start', interaction.element);\n\n    gestureEvent.ds = 0;\n\n    interaction.gesture.startDistance = interaction.gesture.prevDistance = gestureEvent.distance;\n    interaction.gesture.startAngle = interaction.gesture.prevAngle = gestureEvent.angle;\n    interaction.gesture.scale = 1;\n\n    interaction._interacting = true;\n\n    interaction.target.fire(gestureEvent);\n\n    return gestureEvent;\n  },\n\n  move: function (interaction, event) {\n    if (!interaction.pointerIds.length) {\n      return interaction.prevEvent;\n    }\n\n    var gestureEvent = undefined;\n\n    gestureEvent = new InteractEvent(interaction, event, 'gesture', 'move', interaction.element);\n    gestureEvent.ds = gestureEvent.scale - interaction.gesture.scale;\n\n    interaction.target.fire(gestureEvent);\n\n    interaction.gesture.prevAngle = gestureEvent.angle;\n    interaction.gesture.prevDistance = gestureEvent.distance;\n\n    if (gestureEvent.scale !== Infinity && gestureEvent.scale !== null && gestureEvent.scale !== undefined && !isNaN(gestureEvent.scale)) {\n\n      interaction.gesture.scale = gestureEvent.scale;\n    }\n\n    return gestureEvent;\n  },\n\n  end: function (interaction, event) {\n    var endEvent = new InteractEvent(interaction, event, 'gesture', 'end', interaction.element);\n\n    interaction.target.fire(endEvent);\n  },\n\n  stop: utils.blank\n};\n\n/*\\\n * Interactable.gesturable\n [ method ]\n *\n * Gets or sets whether multitouch gestures can be performed on the\n * Interactable's element\n *\n = (boolean) Indicates if this can be the target of gesture events\n   | var isGestureable = interact(element).gesturable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n = (object) this Interactable\n | interact(element).gesturable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // limit multiple gestures.\n |     // See the explanation in @Interactable.draggable example\n |     max: Infinity,\n |     maxPerElement: 1,\n | });\n\\*/\nInteractable.prototype.gesturable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.gesture.enabled = options.enabled === false ? false : true;\n    this.setPerAction('gesture', options);\n    this.setOnEvents('gesture', options);\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.gesture.enabled = options;\n\n    return this;\n  }\n\n  return this.options.gesture;\n};\n\nsignals.on('interactevent-gesture', function (arg) {\n  if (arg.action !== 'gesture') {\n    return;\n  }\n\n  var interaction = arg.interaction;\n  var iEvent = arg.iEvent;\n  var starting = arg.starting;\n  var ending = arg.ending;\n  var deltaSource = arg.deltaSource;\n\n  var pointers = interaction.pointers;\n\n  iEvent.touches = [pointers[0], pointers[1]];\n\n  if (starting) {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box = utils.touchBBox(pointers);\n    iEvent.scale = 1;\n    iEvent.ds = 0;\n    iEvent.angle = utils.touchAngle(pointers, undefined, deltaSource);\n    iEvent.da = 0;\n  } else if (ending || event instanceof InteractEvent) {\n    iEvent.distance = interaction.prevEvent.distance;\n    iEvent.box = interaction.prevEvent.box;\n    iEvent.scale = interaction.prevEvent.scale;\n    iEvent.ds = iEvent.scale - 1;\n    iEvent.angle = interaction.prevEvent.angle;\n    iEvent.da = iEvent.angle - interaction.gesture.startAngle;\n  } else {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box = utils.touchBBox(pointers);\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance;\n    iEvent.angle = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n  }\n});\n\nsignals.on('interaction-new', function (interaction) {\n  interaction.gesture = {\n    start: { x: 0, y: 0 },\n\n    startDistance: 0, // distance between two touches of touchStart\n    prevDistance: 0,\n    distance: 0,\n\n    scale: 1, // gesture.distance / gesture.startDistance\n\n    startAngle: 0, // angle of line joining two touches\n    prevAngle: 0 };\n});\n\n// angle of the previous gesture event\nbase.gesture = gesture;\nbase.names.push('gesture');\nutils.merge(scope.eventTypes, ['gesturestart', 'gesturemove', 'gestureinertiastart', 'gestureend']);\nbase.methodDict.gesture = 'gesturable';\n\ndefaultOptions.gesture = gesture.defaults;\n\nmodule.exports = gesture;\n\n},{\"../InteractEvent\":2,\"../Interactable\":3,\"../defaultOptions\":11,\"../scope\":19,\"../utils\":28,\"../utils/signals\":34,\"./base\":5}],9:[function(require,module,exports){\nvar base = require('./base');\nvar utils = require('../utils');\nvar browser = require('../utils/browser');\nvar signals = require('../utils/signals');\nvar scope = require('../scope');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar defaultOptions = require('../defaultOptions');\n\nvar resize = {\n  defaults: {\n    enabled: false,\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n\n    snap: null,\n    restrict: null,\n    inertia: null,\n    autoScroll: null,\n\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none'\n  },\n\n  checker: function (pointer, event, interactable, element, interaction, rect) {\n    if (!rect) {\n      return null;\n    }\n\n    var page = utils.extend({}, interaction.curCoords.page);\n    var options = interactable.options;\n\n    if (options.resize.enabled) {\n      var resizeOptions = options.resize;\n      var resizeEdges = { left: false, right: false, top: false, bottom: false };\n\n      // if using resize.edges\n      if (utils.isObject(resizeOptions.edges)) {\n        for (var edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._eventTarget, element, rect, resizeOptions.margin || scope.margin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: 'resize',\n            edges: resizeEdges\n          };\n        }\n      } else {\n        var right = options.resize.axis !== 'y' && page.x > rect.right - scope.margin;\n        var bottom = options.resize.axis !== 'x' && page.y > rect.bottom - scope.margin;\n\n        if (right || bottom) {\n          return {\n            name: 'resize',\n            axes: (right ? 'x' : '') + (bottom ? 'y' : '')\n          };\n        }\n      }\n    }\n\n    return null;\n  },\n\n  cursors: browser.isIe9OrOlder ? {\n    x: 'e-resize',\n    y: 's-resize',\n    xy: 'se-resize',\n\n    top: 'n-resize',\n    left: 'w-resize',\n    bottom: 's-resize',\n    right: 'e-resize',\n    topleft: 'se-resize',\n    bottomright: 'se-resize',\n    topright: 'ne-resize',\n    bottomleft: 'ne-resize'\n  } : {\n    x: 'ew-resize',\n    y: 'ns-resize',\n    xy: 'nwse-resize',\n\n    top: 'ns-resize',\n    left: 'ew-resize',\n    bottom: 'ns-resize',\n    right: 'ew-resize',\n    topleft: 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright: 'nesw-resize',\n    bottomleft: 'nesw-resize'\n  },\n\n  getCursor: function (action) {\n    if (action.axis) {\n      return resize.cursors[action.name + action.axis];\n    } else if (action.edges) {\n      var cursorKey = '';\n      var edgeNames = ['top', 'bottom', 'left', 'right'];\n\n      for (var i = 0; i < 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i];\n        }\n      }\n\n      return resize.cursors[cursorKey];\n    }\n  },\n\n  beforeStart: utils.blank,\n\n  start: function (interaction, event) {\n    var resizeEvent = new InteractEvent(interaction, event, 'resize', 'start', interaction.element);\n\n    if (interaction.prepared.edges) {\n      var startRect = interaction.target.getRect(interaction.element);\n      var resizeOptions = interaction.target.options.resize;\n\n      /*\n       * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n       * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n       * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n       * on the active edges and the edge being interacted with.\n       */\n      if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n        var linkedEdges = utils.extend({}, interaction.prepared.edges);\n\n        linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;\n        linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;\n        linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;\n        linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;\n\n        interaction.prepared._linkedEdges = linkedEdges;\n      } else {\n        interaction.prepared._linkedEdges = null;\n      }\n\n      // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n      if (resizeOptions.preserveAspectRatio) {\n        interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n      }\n\n      interaction.resizeRects = {\n        start: startRect,\n        current: utils.extend({}, startRect),\n        restricted: utils.extend({}, startRect),\n        previous: utils.extend({}, startRect),\n        delta: {\n          left: 0, right: 0, width: 0,\n          top: 0, bottom: 0, height: 0\n        }\n      };\n\n      resizeEvent.rect = interaction.resizeRects.restricted;\n      resizeEvent.deltaRect = interaction.resizeRects.delta;\n    }\n\n    interaction.target.fire(resizeEvent);\n\n    interaction._interacting = true;\n\n    return resizeEvent;\n  },\n\n  move: function (interaction, event) {\n    var resizeEvent = new InteractEvent(interaction, event, 'resize', 'move', interaction.element);\n    var resizeOptions = interaction.target.options.resize;\n    var invert = resizeOptions.invert;\n    var invertible = invert === 'reposition' || invert === 'negate';\n\n    var edges = interaction.prepared.edges;\n\n    if (edges) {\n      var start = interaction.resizeRects.start;\n      var current = interaction.resizeRects.current;\n      var restricted = interaction.resizeRects.restricted;\n      var delta = interaction.resizeRects.delta;\n      var previous = utils.extend(interaction.resizeRects.previous, restricted);\n      var originalEdges = edges;\n\n      var dx = resizeEvent.dx;\n      var dy = resizeEvent.dy;\n\n      // `resize.preserveAspectRatio` takes precedence over `resize.square`\n      if (resizeOptions.preserveAspectRatio) {\n        var resizeStartAspectRatio = interaction.resizeStartAspectRatio;\n\n        edges = interaction.prepared._linkedEdges;\n\n        if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n          dy = -dx / resizeStartAspectRatio;\n        } else if (originalEdges.left || originalEdges.right) {\n          dy = dx / resizeStartAspectRatio;\n        } else if (originalEdges.top || originalEdges.bottom) {\n          dx = dy * resizeStartAspectRatio;\n        }\n      } else if (resizeOptions.square) {\n        edges = interaction.prepared._linkedEdges;\n\n        if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n          dy = -dx;\n        } else if (originalEdges.left || originalEdges.right) {\n          dy = dx;\n        } else if (originalEdges.top || originalEdges.bottom) {\n          dx = dy;\n        }\n      }\n\n      // update the 'current' rect without modifications\n      if (edges.top) {\n        current.top += dy;\n      }\n      if (edges.bottom) {\n        current.bottom += dy;\n      }\n      if (edges.left) {\n        current.left += dx;\n      }\n      if (edges.right) {\n        current.right += dx;\n      }\n\n      if (invertible) {\n        // if invertible, copy the current rect\n        utils.extend(restricted, current);\n\n        if (invert === 'reposition') {\n          // swap edge values if necessary to keep width/height positive\n          var swap = undefined;\n\n          if (restricted.top > restricted.bottom) {\n            swap = restricted.top;\n\n            restricted.top = restricted.bottom;\n            restricted.bottom = swap;\n          }\n          if (restricted.left > restricted.right) {\n            swap = restricted.left;\n\n            restricted.left = restricted.right;\n            restricted.right = swap;\n          }\n        }\n      } else {\n        // if not invertible, restrict to minimum of 0x0 rect\n        restricted.top = Math.min(current.top, start.bottom);\n        restricted.bottom = Math.max(current.bottom, start.top);\n        restricted.left = Math.min(current.left, start.right);\n        restricted.right = Math.max(current.right, start.left);\n      }\n\n      restricted.width = restricted.right - restricted.left;\n      restricted.height = restricted.bottom - restricted.top;\n\n      for (var edge in restricted) {\n        delta[edge] = restricted[edge] - previous[edge];\n      }\n\n      resizeEvent.edges = interaction.prepared.edges;\n      resizeEvent.rect = restricted;\n      resizeEvent.deltaRect = delta;\n    }\n\n    interaction.target.fire(resizeEvent);\n\n    return resizeEvent;\n  },\n\n  end: function (interaction, event) {\n    var endEvent = new InteractEvent(interaction, event, 'resize', 'end', interaction.element);\n\n    interaction.target.fire(endEvent);\n  },\n\n  stop: utils.blank\n};\n\n/*\\\n * Interactable.resizable\n [ method ]\n *\n * Gets or sets whether resize actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of resize elements\n   | var isResizeable = interact('input[type=text]').resizable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n = (object) This Interactable\n   | interact(element).resizable({\n   |   onstart: function (event) {},\n   |   onmove : function (event) {},\n   |   onend  : function (event) {},\n   |\n   |   edges: {\n   |     top   : true,       // Use pointer coords to check for resize.\n   |     left  : false,      // Disable resizing from left edge.\n   |     bottom: '.resize-s',// Resize if pointer target matches selector\n   |     right : handleEl    // Resize if pointer target is the given Element\n   |   },\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height are adjusted at a 1:1 ratio.\n   |     square: false,\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height maintain the aspect ratio they had when resizing started.\n   |     preserveAspectRatio: false,\n   |\n   |   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   |   // 'negate' will allow the rect to have negative width/height\n   |   // 'reposition' will keep the width/height positive by swapping\n   |   // the top and bottom edges and/or swapping the left and right edges\n   |   invert: 'none' || 'negate' || 'reposition'\n   |\n   |   // limit multiple resizes.\n   |   // See the explanation in the @Interactable.draggable example\n   |   max: Infinity,\n   |   maxPerElement: 1,\n   | });\n  \\*/\nInteractable.prototype.resizable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.resize.enabled = options.enabled === false ? false : true;\n    this.setPerAction('resize', options);\n    this.setOnEvents('resize', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.resize.axis = options.axis;\n    } else if (options.axis === null) {\n      this.options.resize.axis = scope.defaultOptions.resize.axis;\n    }\n\n    if (utils.isBool(options.preserveAspectRatio)) {\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n    } else if (utils.isBool(options.square)) {\n      this.options.resize.square = options.square;\n    }\n\n    return this;\n  }\n  if (utils.isBool(options)) {\n    this.options.resize.enabled = options;\n\n    return this;\n  }\n  return this.options.resize;\n};\n\nfunction checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {\n  // false, '', undefined, null\n  if (!value) {\n    return false;\n  }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    var width = utils.isNumber(rect.width) ? rect.width : rect.right - rect.left;\n    var height = utils.isNumber(rect.height) ? rect.height : rect.bottom - rect.top;\n\n    if (width < 0) {\n      if (name === 'left') {\n        name = 'right';\n      } else if (name === 'right') {\n        name = 'left';\n      }\n    }\n    if (height < 0) {\n      if (name === 'top') {\n        name = 'bottom';\n      } else if (name === 'bottom') {\n        name = 'top';\n      }\n    }\n\n    if (name === 'left') {\n      return page.x < (width >= 0 ? rect.left : rect.right) + margin;\n    }\n    if (name === 'top') {\n      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\n    }\n\n    if (name === 'right') {\n      return page.x > (width >= 0 ? rect.right : rect.left) - margin;\n    }\n    if (name === 'bottom') {\n      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\n    }\n  }\n\n  // the remaining checks require an element\n  if (!utils.isElement(element)) {\n    return false;\n  }\n\n  return utils.isElement(value)\n  // the value is an element to use as a resize handle\n  ? value === element\n  // otherwise check if element matches value as selector\n  : utils.matchesUpTo(element, value, interactableElement);\n}\n\nsignals.on('interaction-new', function (interaction) {\n  interaction.resizeAxes = 'xy';\n});\n\nsignals.on('interactevent-resize', function (_ref) {\n  var interaction = _ref.interaction;\n  var iEvent = _ref.iEvent;\n\n  if (!interaction.resizeAxes) {\n    return;\n  }\n\n  var options = interaction.target.options;\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      iEvent.dx = iEvent.dy;\n    } else {\n      iEvent.dy = iEvent.dx;\n    }\n    iEvent.axes = 'xy';\n  } else {\n    iEvent.axes = interaction.resizeAxes;\n\n    if (interaction.resizeAxes === 'x') {\n      iEvent.dy = 0;\n    } else if (interaction.resizeAxes === 'y') {\n      iEvent.dx = 0;\n    }\n  }\n});\n\nbase.resize = resize;\nbase.names.push('resize');\nutils.merge(scope.eventTypes, ['resizestart', 'resizemove', 'resizeinertiastart', 'resizeend']);\nbase.methodDict.resize = 'resizable';\n\ndefaultOptions.resize = resize.defaults;\n\nmodule.exports = resize;\n\n},{\"../InteractEvent\":2,\"../Interactable\":3,\"../defaultOptions\":11,\"../scope\":19,\"../utils\":28,\"../utils/browser\":21,\"../utils/signals\":34,\"./base\":5}],10:[function(require,module,exports){\nvar raf = require('./utils/raf');\nvar getWindow = require('./utils/window').getWindow;\nvar isWindow = require('./utils/isType').isWindow;\nvar domUtils = require('./utils/domUtils');\nvar signals = require('./utils/signals');\nvar defaultOptions = require('./defaultOptions');\n\nvar autoScroll = {\n  defaults: {\n    enabled: false,\n    container: null, // the item that is scrolled (Window or HTMLElement)\n    margin: 60,\n    speed: 300 },\n\n  // the scroll speed in pixels per second\n  interaction: null,\n  i: null, // the handle returned by window.setInterval\n  x: 0, y: 0, // Direction each pulse is to scroll in\n\n  isScrolling: false,\n  prevTime: 0,\n\n  start: function (interaction) {\n    autoScroll.isScrolling = true;\n    raf.cancel(autoScroll.i);\n\n    autoScroll.interaction = interaction;\n    autoScroll.prevTime = new Date().getTime();\n    autoScroll.i = raf.request(autoScroll.scroll);\n  },\n\n  stop: function () {\n    autoScroll.isScrolling = false;\n    raf.cancel(autoScroll.i);\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll: function () {\n    var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n    var container = options.container || getWindow(autoScroll.interaction.element);\n    var now = new Date().getTime();\n    // change in time in seconds\n    var dt = (now - autoScroll.prevTime) / 1000;\n    // displacement\n    var s = options.speed * dt;\n\n    if (s >= 1) {\n      if (isWindow(container)) {\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n      } else if (container) {\n        container.scrollLeft += autoScroll.x * s;\n        container.scrollTop += autoScroll.y * s;\n      }\n\n      autoScroll.prevTime = now;\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i);\n      autoScroll.i = raf.request(autoScroll.scroll);\n    }\n  },\n  check: function (interactable, actionName) {\n    var options = interactable.options;\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n  },\n  onInteractionMove: function (_ref) {\n    var interaction = _ref.interaction;\n    var pointer = _ref.pointer;\n\n    if (!(interaction.interacting() && autoScroll.check(interaction.target, interaction.prepared.name))) {\n      return;\n    }\n\n    if (interaction.inertiaStatus.active) {\n      autoScroll.x = autoScroll.y = 0;\n      return;\n    }\n\n    var top = undefined;\n    var right = undefined;\n    var bottom = undefined;\n    var left = undefined;\n\n    var options = interaction.target.options[interaction.prepared.name].autoScroll;\n    var container = options.container || getWindow(interaction.element);\n\n    if (isWindow(container)) {\n      left = pointer.clientX < autoScroll.margin;\n      top = pointer.clientY < autoScroll.margin;\n      right = pointer.clientX > container.innerWidth - autoScroll.margin;\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n    } else {\n      var rect = domUtils.getElementClientRect(container);\n\n      left = pointer.clientX < rect.left + autoScroll.margin;\n      top = pointer.clientY < rect.top + autoScroll.margin;\n      right = pointer.clientX > rect.right - autoScroll.margin;\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n    }\n\n    autoScroll.x = right ? 1 : left ? -1 : 0;\n    autoScroll.y = bottom ? 1 : top ? -1 : 0;\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin;\n      autoScroll.speed = options.speed;\n\n      autoScroll.start(interaction);\n    }\n  }\n};\n\nsignals.on('interaction-stop-active', function () {\n  autoScroll.stop();\n});\n\nsignals.on('interaction-move-done', autoScroll.onInteractionMove);\n\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\n\nmodule.exports = autoScroll;\n\n},{\"./defaultOptions\":11,\"./utils/domUtils\":23,\"./utils/isType\":30,\"./utils/raf\":33,\"./utils/signals\":34,\"./utils/window\":35}],11:[function(require,module,exports){\nmodule.exports = {\n  base: {\n    accept: null,\n    actionChecker: null,\n    styleCursor: true,\n    preventDefault: 'auto',\n    origin: { x: 0, y: 0 },\n    deltaSource: 'page',\n    allowFrom: null,\n    ignoreFrom: null,\n    checker: null\n  },\n\n  perAction: {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n\n    inertia: {\n      enabled: false,\n      resistance: 10, // the lambda in exponential decay\n      minSpeed: 100, // target speed must be above this for inertia to start\n      endSpeed: 10, // the speed at which inertia is slow enough to stop\n      allowResume: true, // allow resuming an action in inertia phase\n      zeroResumeDelta: true, // if an action is resumed after launch, set dx/dy to 0\n      smoothEndDuration: 300 }\n  },\n\n  // animate to snap/restrict endOnly if there's no inertia\n  _holdDuration: 600\n};\n\n},{}],12:[function(require,module,exports){\n// browser entry point\n\n// Legacy browser support\nrequire('./legacyBrowsers');\n\n// actions\nrequire('./actions/resize');\nrequire('./actions/drag');\nrequire('./actions/gesture');\n\n// autoScroll\nrequire('./autoScroll');\n\n// pointerEvents\nrequire('./pointerEvents');\n\n// modifiers\nrequire('./modifiers/snap');\nrequire('./modifiers/restrict');\n\nrequire('./Interaction.js');\n\nmodule.exports = require('./interact');\n\n},{\"./Interaction.js\":4,\"./actions/drag\":6,\"./actions/gesture\":8,\"./actions/resize\":9,\"./autoScroll\":10,\"./interact\":13,\"./legacyBrowsers\":14,\"./modifiers/restrict\":16,\"./modifiers/snap\":17,\"./pointerEvents\":18}],13:[function(require,module,exports){\n/**\n * interact.js v1.2.5\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n\nvar browser = require('./utils/browser');\nvar events = require('./utils/events');\nvar utils = require('./utils');\nvar scope = require('./scope');\nvar Interactable = require('./Interactable');\n\nscope.dynamicDrop = false;\n\n// Less Precision with touch input\nscope.margin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;\n\nscope.pointerMoveTolerance = 1;\n\n// Allow this many interactions to happen simultaneously\nscope.maxInteractions = Infinity;\n\n// because Webkit and Opera still use 'mousewheel' event type\nscope.wheelEvent = 'onmousewheel' in scope.document ? 'mousewheel' : 'wheel';\n\nscope.globalEvents = {};\n\nscope.inContext = function (interactable, element) {\n  return interactable._context === element.ownerDocument || utils.nodeContains(interactable._context, element);\n};\n\nscope.testIgnore = function (interactable, interactableElement, element) {\n  var ignoreFrom = interactable.options.ignoreFrom;\n\n  if (!ignoreFrom || !utils.isElement(element)) {\n    return false;\n  }\n\n  if (utils.isString(ignoreFrom)) {\n    return utils.matchesUpTo(element, ignoreFrom, interactableElement);\n  } else if (utils.isElement(ignoreFrom)) {\n    return utils.nodeContains(ignoreFrom, element);\n  }\n\n  return false;\n};\n\nscope.testAllow = function (interactable, interactableElement, element) {\n  var allowFrom = interactable.options.allowFrom;\n\n  if (!allowFrom) {\n    return true;\n  }\n\n  if (!utils.isElement(element)) {\n    return false;\n  }\n\n  if (utils.isString(allowFrom)) {\n    return utils.matchesUpTo(element, allowFrom, interactableElement);\n  } else if (utils.isElement(allowFrom)) {\n    return utils.nodeContains(allowFrom, element);\n  }\n\n  return false;\n};\n\nscope.interactables.indexOfElement = function indexOfElement(element, context) {\n  context = context || scope.document;\n\n  for (var i = 0; i < this.length; i++) {\n    var interactable = this[i];\n\n    if (interactable.selector === element && interactable._context === context || !interactable.selector && interactable._element === element) {\n\n      return i;\n    }\n  }\n  return -1;\n};\n\nscope.interactables.get = function interactableGet(element, options) {\n  return this[this.indexOfElement(element, options && options.context)];\n};\n\nscope.interactables.forEachSelector = function (callback) {\n  for (var i = 0; i < this.length; i++) {\n    var interactable = this[i];\n\n    if (!interactable.selector) {\n      continue;\n    }\n\n    var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\n    if (ret !== undefined) {\n      return ret;\n    }\n  }\n};\n\n/*\\\n * interact\n [ method ]\n *\n * The methods of this variable can be used to set elements as\n * interactables and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to\n * configure it.\n *\n - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n = (object) An @Interactable\n *\n > Usage\n | interact(document.getElementById('draggable')).draggable(true);\n |\n | var rectables = interact('rect');\n | rectables\n |     .gesturable(true)\n |     .on('gesturemove', function (event) {\n |         // something cool...\n |     })\n |     .autoScroll(true);\n\\*/\nfunction interact(element, options) {\n  return scope.interactables.get(element, options) || new Interactable(element, options);\n}\n\n/*\\\n * interact.isSet\n [ method ]\n *\n * Check if an element has been set\n - element (Element) The Element being searched for\n = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\\*/\ninteract.isSet = function (element, options) {\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n};\n\n/*\\\n * interact.on\n [ method ]\n *\n * Adds a global listener for an InteractEvent or adds a DOM event to\n * `document`\n *\n - type       (string | array | object) The types of events to listen for\n - listener   (function) The function event (s)\n - useCapture (boolean) #optional useCapture flag for addEventListener\n = (object) interact\n\\*/\ninteract.on = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (var _iterator = type, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var eventType = _ref;\n\n      interact.on(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (var prop in type) {\n      interact.on(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.contains(scope.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!scope.globalEvents[type]) {\n      scope.globalEvents[type] = [listener];\n    } else {\n      scope.globalEvents[type].push(listener);\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n      events.add(scope.document, type, listener, useCapture);\n    }\n\n  return interact;\n};\n\n/*\\\n * interact.off\n [ method ]\n *\n * Removes a global InteractEvent listener or DOM event from `document`\n *\n - type       (string | array | object) The types of events that were listened for\n - listener   (function) The listener function to be removed\n - useCapture (boolean) #optional useCapture flag for removeEventListener\n = (object) interact\n \\*/\ninteract.off = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (var _iterator2 = type, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var eventType = _ref2;\n\n      interact.off(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (var prop in type) {\n      interact.off(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  if (!utils.contains(scope.eventTypes, type)) {\n    events.remove(scope.document, type, listener, useCapture);\n  } else {\n    var index = undefined;\n\n    if (type in scope.globalEvents && (index = utils.indexOf(scope.globalEvents[type], listener)) !== -1) {\n      scope.globalEvents[type].splice(index, 1);\n    }\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.debug\n [ method ]\n *\n * Returns an object which exposes internal data\n = (object) An object with properties that outline the current state and expose internal functions and variables\n\\*/\ninteract.debug = function () {\n  return scope;\n};\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage = utils.pointerAverage;\ninteract.getTouchBBox = utils.touchBBox;\ninteract.getTouchDistance = utils.touchDistance;\ninteract.getTouchAngle = utils.touchAngle;\n\ninteract.getElementRect = utils.getElementRect;\ninteract.getElementClientRect = utils.getElementClientRect;\ninteract.matchesSelector = utils.matchesSelector;\ninteract.closest = utils.closest;\n\n/*\\\n * interact.supportsTouch\n [ method ]\n *\n = (boolean) Whether or not the browser supports touch input\n\\*/\ninteract.supportsTouch = function () {\n  return browser.supportsTouch;\n};\n\n/*\\\n * interact.supportsPointerEvent\n [ method ]\n *\n = (boolean) Whether or not the browser supports PointerEvents\n\\*/\ninteract.supportsPointerEvent = function () {\n  return browser.supportsPointerEvent;\n};\n\n/*\\\n * interact.stop\n [ method ]\n *\n * Cancels all interactions (end events are not fired)\n *\n - event (Event) An event on which to call preventDefault()\n = (object) interact\n\\*/\ninteract.stop = function (event) {\n  for (var i = scope.interactions.length - 1; i >= 0; i--) {\n    scope.interactions[i].stop(event);\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.dynamicDrop\n [ method ]\n *\n * Returns or sets whether the dimensions of dropzone elements are\n * calculated on every dragmove or only on dragstart for the default\n * dropChecker\n *\n - newValue (boolean) #optional True to check on each move. False to check only before start\n = (boolean | interact) The current setting or interact\n\\*/\ninteract.dynamicDrop = function (newValue) {\n  if (utils.isBool(newValue)) {\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\n    //calcRects(dropzones);\n    //}\n\n    scope.dynamicDrop = newValue;\n\n    return interact;\n  }\n  return scope.dynamicDrop;\n};\n\n/*\\\n * interact.pointerMoveTolerance\n [ method ]\n * Returns or sets the distance the pointer must be moved before an action\n * sequence occurs. This also affects tolerance for tap events.\n *\n - newValue (number) #optional The movement from the start position must be greater than this value\n = (number | Interactable) The current setting or interact\n\\*/\ninteract.pointerMoveTolerance = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    scope.pointerMoveTolerance = newValue;\n\n    return this;\n  }\n\n  return scope.pointerMoveTolerance;\n};\n\n/*\\\n * interact.maxInteractions\n [ method ]\n **\n * Returns or sets the maximum number of concurrent interactions allowed.\n * By default only 1 interaction is allowed at a time (for backwards\n * compatibility). To allow multiple interactions on the same Interactables\n * and elements, you need to enable it in the draggable, resizable and\n * gesturable `'max'` and `'maxPerElement'` options.\n **\n - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\\*/\ninteract.maxInteractions = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    scope.maxInteractions = newValue;\n\n    return this;\n  }\n\n  return scope.maxInteractions;\n};\n\nscope.interact = interact;\n\nmodule.exports = interact;\n\n},{\"./Interactable\":3,\"./scope\":19,\"./utils\":28,\"./utils/browser\":21,\"./utils/events\":24}],14:[function(require,module,exports){\nvar scope = require('./scope');\nvar events = require('./utils/events');\nvar signals = require('./utils/signals');\nvar browser = require('./utils/browser');\nvar iFinder = require('./utils/interactionFinder');\n\nvar toString = Object.prototype.toString;\n\nif (!window.Array.isArray) {\n  window.Array.isArray = function (obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n\n// http://www.quirksmode.org/dom/events/click.html\n// >Events leading to dblclick\n//\n// IE8 doesn't fire down event before dblclick.\n// This workaround tries to fire a tap and doubletap after dblclick\nfunction onIE8Dblclick(event) {\n  var interaction = iFinder.search(event, event.type, event.target);\n\n  if (!interaction) {\n    return;\n  }\n\n  if (interaction.prevTap && event.clientX === interaction.prevTap.clientX && event.clientY === interaction.prevTap.clientY && event.target === interaction.prevTap.target) {\n\n    interaction.downTargets[0] = event.target;\n    interaction.downTimes[0] = new Date().getTime();\n\n    scope.pointerEvents.collectEventTargets(interaction, event, event, event.target, 'tap');\n  }\n}\n\nif (browser.isIE8) {\n  signals.on('listen-to-document', function (_ref) {\n    var doc = _ref.doc;\n\n    // For IE's lack of Event#preventDefault\n    events.add(doc, 'selectstart', function (event) {\n      var interaction = scope.interactions[0];\n\n      if (interaction.currentAction()) {\n        interaction.checkAndPreventDefault(event);\n      }\n    });\n\n    if (scope.pointerEvents) {\n      events.add(doc, 'dblclick', onIE8Dblclick);\n    }\n  });\n}\n\nmodule.exports = null;\n\n},{\"./scope\":19,\"./utils/browser\":21,\"./utils/events\":24,\"./utils/interactionFinder\":29,\"./utils/signals\":34}],15:[function(require,module,exports){\nvar extend = require('../utils/extend');\n\nvar modifiers = {\n  names: [],\n\n  setOffsets: function (interaction, interactable, element, rect, offsets) {\n    for (var i = 0; i < modifiers.names.length; i++) {\n      var modifierName = modifiers.names[i];\n\n      offsets[modifierName] = modifiers[modifiers.names[i]].setOffset(interaction, interactable, element, rect, interaction.startOffset);\n    }\n  },\n\n  setAll: function (interaction, coordsArg, statuses, preEnd, requireEndOnly) {\n    var result = {\n      dx: 0,\n      dy: 0,\n      changed: false,\n      locked: false,\n      shouldMove: true\n    };\n    var target = interaction.target;\n    var coords = extend({}, coordsArg);\n\n    var currentStatus = undefined;\n\n    for (var _iterator = modifiers.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var modifierName = _ref;\n\n      var modifier = modifiers[modifierName];\n\n      if (!modifier.shouldDo(target, interaction.prepared.name, preEnd, requireEndOnly)) {\n        continue;\n      }\n\n      currentStatus = modifier.set(coords, interaction, statuses[modifierName]);\n\n      if (currentStatus.locked) {\n        coords.x += currentStatus.dx;\n        coords.y += currentStatus.dy;\n\n        result.dx += currentStatus.dx;\n        result.dy += currentStatus.dy;\n\n        result.locked = true;\n      }\n    }\n\n    // a move should be fired if the modified coords of\n    // the last modifier status that was calculated changes\n    result.shouldMove = !currentStatus || currentStatus.changed;\n\n    return result;\n  },\n\n  resetStatuses: function (statuses) {\n    for (var _iterator2 = modifiers.names, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var modifierName = _ref2;\n\n      statuses[modifierName] = modifiers[modifierName].reset(statuses[modifierName] || {});\n    }\n\n    return statuses;\n  }\n};\n\nmodule.exports = modifiers;\n\n},{\"../utils/extend\":25}],16:[function(require,module,exports){\nvar modifiers = require('./base');\nvar utils = require('../utils');\nvar defaultOptions = require('../defaultOptions');\n\nvar restrict = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    restriction: null,\n    elementRect: null\n  },\n\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\n    var restrictOptions = interactable.options[actionName].restrict;\n\n    return restrictOptions && restrictOptions.enabled && (preEnd || !restrictOptions.endOnly) && (!requireEndOnly || restrictOptions.endOnly);\n  },\n\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\n    var elementRect = interactable.options[interaction.prepared.name].restrict.elementRect;\n    var offset = {};\n\n    if (rect && elementRect) {\n      offset.left = startOffset.left - rect.width * elementRect.left;\n      offset.top = startOffset.top - rect.height * elementRect.top;\n\n      offset.right = startOffset.right - rect.width * (1 - elementRect.right);\n      offset.bottom = startOffset.bottom - rect.height * (1 - elementRect.bottom);\n    } else {\n      offset.left = offset.top = offset.right = offset.bottom = 0;\n    }\n\n    return offset;\n  },\n\n  set: function (pageCoords, interaction, status) {\n    var target = interaction.target;\n    var restrictOptions = target && target.options[interaction.prepared.name].restrict;\n    var restriction = restrictOptions && restrictOptions.restriction;\n\n    if (!restriction) {\n      return status;\n    }\n\n    var page = status.useStatusXY ? { x: status.x, y: status.y } : utils.extend({}, pageCoords);\n\n    page.x -= interaction.inertiaStatus.resumeDx;\n    page.y -= interaction.inertiaStatus.resumeDy;\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    var rect = undefined;\n    var restrictedX = undefined;\n    var restrictedY = undefined;\n\n    if (utils.isString(restriction)) {\n      if (restriction === 'parent') {\n        restriction = utils.parentElement(interaction.element);\n      } else if (restriction === 'self') {\n        restriction = target.getRect(interaction.element);\n      } else {\n        restriction = utils.closest(interaction.element, restriction);\n      }\n\n      if (!restriction) {\n        return status;\n      }\n    }\n\n    if (utils.isFunction(restriction)) {\n      restriction = restriction(page.x, page.y, interaction.element);\n    }\n\n    if (utils.isElement(restriction)) {\n      restriction = utils.getElementRect(restriction);\n    }\n\n    rect = restriction;\n\n    var offset = interaction.modifierOffsets.restrict;\n\n    if (!restriction) {\n      restrictedX = page.x;\n      restrictedY = page.y;\n    }\n    // object is assumed to have\n    // x, y, width, height or\n    // left, top, right, bottom\n    else if ('x' in restriction && 'y' in restriction) {\n        restrictedX = Math.max(Math.min(rect.x + rect.width - offset.right, page.x), rect.x + offset.left);\n        restrictedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top);\n      } else {\n        restrictedX = Math.max(Math.min(rect.right - offset.right, page.x), rect.left + offset.left);\n        restrictedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top + offset.top);\n      }\n\n    status.dx = restrictedX - page.x;\n    status.dy = restrictedY - page.y;\n\n    status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.restrictedX = restrictedX;\n    status.restrictedY = restrictedY;\n\n    return status;\n  },\n\n  reset: function (status) {\n    status.dx = status.dy = 0;\n    status.modifiedX = status.modifiedY = NaN;\n    status.locked = false;\n    status.changed = true;\n\n    return status;\n  },\n\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\n    var options = interactable.options[actionName].restrict;\n    var elementRect = options && options.elementRect;\n\n    if (modifiers.restrict.shouldDo(interactable, actionName) && !(phase === 'start' && elementRect && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy\n        };\n      }\n    }\n  }\n};\n\nmodifiers.restrict = restrict;\nmodifiers.names.push('restrict');\n\ndefaultOptions.perAction.restrict = restrict.defaults;\n\nmodule.exports = restrict;\n\n},{\"../defaultOptions\":11,\"../utils\":28,\"./base\":15}],17:[function(require,module,exports){\nvar modifiers = require('./base');\nvar interact = require('../interact');\nvar utils = require('../utils');\nvar defaultOptions = require('../defaultOptions');\n\nvar snap = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range: Infinity,\n    targets: null,\n    offsets: null,\n\n    relativePoints: null\n  },\n\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\n    var snapOptions = interactable.options[actionName].snap;\n\n    return snapOptions && snapOptions.enabled && (preEnd || !snapOptions.endOnly) && (!requireEndOnly || snapOptions.endOnly);\n  },\n\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\n    var offsets = [];\n    var origin = utils.getOriginXY(interactable, element);\n    var snapOptions = interactable.options[interaction.prepared.name].snap;\n    var snapOffset = snapOptions && snapOptions.offset === 'startCoords' ? {\n      x: interaction.startCoords.page.x - origin.x,\n      y: interaction.startCoords.page.y - origin.y\n    } : snapOptions && snapOptions.offset || { x: 0, y: 0 };\n\n    if (rect && snapOptions && snapOptions.relativePoints && snapOptions.relativePoints.length) {\n      for (var _iterator = snapOptions.relativePoints, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var relativeX = _ref.x;\n        var relativeY = _ref.y;\n\n        offsets.push({\n          x: startOffset.left - rect.width * relativeX + snapOffset.x,\n          y: startOffset.top - rect.height * relativeY + snapOffset.y\n        });\n      }\n    } else {\n      offsets.push(snapOffset);\n    }\n\n    return offsets;\n  },\n\n  set: function (pageCoords, interaction, status) {\n    var snapOptions = interaction.target.options[interaction.prepared.name].snap;\n    var targets = [];\n    var target = undefined;\n    var page = undefined;\n    var i = undefined;\n\n    if (status.useStatusXY) {\n      page = { x: status.x, y: status.y };\n    } else {\n      var origin = utils.getOriginXY(interaction.target, interaction.element);\n\n      page = utils.extend({}, pageCoords);\n\n      page.x -= origin.x;\n      page.y -= origin.y;\n    }\n\n    status.realX = page.x;\n    status.realY = page.y;\n\n    page.x -= interaction.inertiaStatus.resumeDx;\n    page.y -= interaction.inertiaStatus.resumeDy;\n\n    var offsets = interaction.modifierOffsets.snap;\n    var len = snapOptions.targets ? snapOptions.targets.length : 0;\n\n    for (var _iterator2 = offsets, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var offsetX = _ref2.x;\n      var offsetY = _ref2.y;\n\n      var relativeX = page.x - offsetX;\n      var relativeY = page.y - offsetY;\n\n      for (var _iterator3 = snapOptions.targets, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var snapTarget = _ref3;\n\n        if (utils.isFunction(snapTarget)) {\n          target = snapTarget(relativeX, relativeY, interaction);\n        } else {\n          target = snapTarget;\n        }\n\n        if (!target) {\n          continue;\n        }\n\n        targets.push({\n          x: utils.isNumber(target.x) ? target.x + offsetX : relativeX,\n          y: utils.isNumber(target.y) ? target.y + offsetY : relativeY,\n\n          range: utils.isNumber(target.range) ? target.range : snapOptions.range\n        });\n      }\n    }\n\n    var closest = {\n      target: null,\n      inRange: false,\n      distance: 0,\n      range: 0,\n      dx: 0,\n      dy: 0\n    };\n\n    for (i = 0, len = targets.length; i < len; i++) {\n      target = targets[i];\n\n      var range = target.range;\n      var dx = target.x - page.x;\n      var dy = target.y - page.y;\n      var distance = utils.hypot(dx, dy);\n      var inRange = distance <= range;\n\n      // Infinite targets count as being out of range\n      // compared to non infinite ones that are in range\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n        inRange = false;\n      }\n\n      if (!closest.target || (inRange\n      // is the closest target in range?\n      ? closest.inRange && range !== Infinity\n      // the pointer is relatively deeper in this target\n      ? distance / range < closest.distance / closest.range\n      // this target has Infinite range and the closest doesn't\n      : range === Infinity && closest.range !== Infinity ||\n      // OR this target is closer that the previous closest\n      distance < closest.distance :\n      // The other is not in range and the pointer is closer to this target\n      !closest.inRange && distance < closest.distance)) {\n\n        closest.target = target;\n        closest.distance = distance;\n        closest.range = range;\n        closest.inRange = inRange;\n        closest.dx = dx;\n        closest.dy = dy;\n\n        status.range = range;\n      }\n    }\n\n    var snapChanged = undefined;\n\n    if (closest.target) {\n      snapChanged = status.snappedX !== closest.target.x || status.snappedY !== closest.target.y;\n\n      status.snappedX = closest.target.x;\n      status.snappedY = closest.target.y;\n    } else {\n      snapChanged = true;\n\n      status.snappedX = NaN;\n      status.snappedY = NaN;\n    }\n\n    status.dx = closest.dx;\n    status.dy = closest.dy;\n\n    status.changed = snapChanged || closest.inRange && !status.locked;\n    status.locked = closest.inRange;\n\n    return status;\n  },\n\n  reset: function (status) {\n    status.dx = status.dy = 0;\n    status.snappedX = status.snappedY = NaN;\n    status.locked = false;\n    status.changed = true;\n\n    return status;\n  },\n\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\n    var snapOptions = interactable.options[actionName].snap;\n    var relativePoints = snapOptions && snapOptions.relativePoints;\n\n    if (snapOptions && snapOptions.enabled && !(phase === 'start' && relativePoints && relativePoints.length)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n      }\n\n      return {\n        range: status.range,\n        locked: status.locked,\n        x: status.snappedX,\n        y: status.snappedY,\n        realX: status.realX,\n        realY: status.realY,\n        dx: status.dx,\n        dy: status.dy\n      };\n    }\n  }\n};\n\ninteract.createSnapGrid = function (grid) {\n  return function (x, y) {\n    var offsetX = 0;\n    var offsetY = 0;\n\n    if (utils.isObject(grid.offset)) {\n      offsetX = grid.offset.x;\n      offsetY = grid.offset.y;\n    }\n\n    var gridx = Math.round((x - offsetX) / grid.x);\n    var gridy = Math.round((y - offsetY) / grid.y);\n\n    var newX = gridx * grid.x + offsetX;\n    var newY = gridy * grid.y + offsetY;\n\n    return {\n      x: newX,\n      y: newY,\n      range: grid.range\n    };\n  };\n};\n\nmodifiers.snap = snap;\nmodifiers.names.push('snap');\n\ndefaultOptions.perAction.snap = snap.defaults;\n\nmodule.exports = snap;\n\n},{\"../defaultOptions\":11,\"../interact\":13,\"../utils\":28,\"./base\":15}],18:[function(require,module,exports){\nvar scope = require('./scope');\nvar InteractEvent = require('./InteractEvent');\nvar utils = require('./utils');\nvar browser = require('./utils/browser');\nvar signals = require('./utils/signals');\n\nvar simpleSignals = ['interaction-down', 'interaction-up', 'interaction-up', 'interaction-cancel'];\nvar simpleEvents = ['down', 'up', 'tap', 'cancel'];\n\nfunction preventOriginalDefault() {\n  this.originalEvent.preventDefault();\n}\n\nfunction firePointers(interaction, pointer, event, eventTarget, targets, elements, eventType) {\n  var pointerIndex = interaction.mouse ? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n  var pointerEvent = {};\n  var i = undefined;\n  // for tap events\n  var interval = undefined;\n  var createNewDoubleTap = undefined;\n\n  // if it's a doubletap then the event properties would have been\n  // copied from the tap event and provided as the pointer argument\n  if (eventType === 'doubletap') {\n    pointerEvent = pointer;\n  } else {\n    utils.pointerExtend(pointerEvent, event);\n    if (event !== pointer) {\n      utils.pointerExtend(pointerEvent, pointer);\n    }\n\n    pointerEvent.preventDefault = preventOriginalDefault;\n    pointerEvent.stopPropagation = InteractEvent.prototype.stopPropagation;\n    pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n    pointerEvent.interaction = interaction;\n\n    pointerEvent.timeStamp = new Date().getTime();\n    pointerEvent.originalEvent = event;\n    pointerEvent.type = eventType;\n    pointerEvent.pointerId = utils.getPointerId(pointer);\n    pointerEvent.pointerType = interaction.mouse ? 'mouse' : !browser.supportsPointerEvent ? 'touch' : utils.isString(pointer.pointerType) ? pointer.pointerType : [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType];\n  }\n\n  if (eventType === 'tap') {\n    pointerEvent.dt = pointerEvent.timeStamp - interaction.downTimes[pointerIndex];\n\n    interval = pointerEvent.timeStamp - interaction.tapTime;\n    createNewDoubleTap = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap' && interaction.prevTap.target === pointerEvent.target && interval < 500);\n\n    pointerEvent.double = createNewDoubleTap;\n\n    interaction.tapTime = pointerEvent.timeStamp;\n  }\n\n  for (i = 0; i < targets.length; i++) {\n    pointerEvent.currentTarget = elements[i];\n    pointerEvent.interactable = targets[i];\n    targets[i].fire(pointerEvent);\n\n    if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget) {\n      break;\n    }\n  }\n\n  if (createNewDoubleTap) {\n    var doubleTap = {};\n\n    utils.extend(doubleTap, pointerEvent);\n\n    doubleTap.dt = interval;\n    doubleTap.type = 'doubletap';\n\n    collectEventTargets(interaction, doubleTap, event, eventTarget, 'doubletap');\n\n    interaction.prevTap = doubleTap;\n  } else if (eventType === 'tap') {\n    interaction.prevTap = pointerEvent;\n  }\n}\n\nfunction collectEventTargets(interaction, pointer, event, eventTarget, eventType) {\n  var pointerIndex = interaction.mouse ? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (eventType === 'tap' && (interaction.pointerWasMoved\n  // or if the pointerup target is different to the pointerdown target\n   || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n    return;\n  }\n\n  var targets = [];\n  var elements = [];\n  var element = eventTarget;\n\n  function collectSelectors(interactable, selector, context) {\n    var els = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n    if (interactable._iEvents[eventType] && utils.isElement(element) && scope.inContext(interactable, element) && !scope.testIgnore(interactable, element, eventTarget) && scope.testAllow(interactable, element, eventTarget) && utils.matchesSelector(element, selector, els)) {\n\n      targets.push(interactable);\n      elements.push(element);\n    }\n  }\n\n  var interact = scope.interact;\n\n  while (element) {\n    if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n      targets.push(interact(element));\n      elements.push(element);\n    }\n\n    scope.interactables.forEachSelector(collectSelectors);\n\n    element = utils.parentElement(element);\n  }\n\n  // create the tap event even if there are no listeners so that\n  // doubletap can still be created and fired\n  if (targets.length || eventType === 'tap') {\n    firePointers(interaction, pointer, event, eventTarget, targets, elements, eventType);\n  }\n}\n\nsignals.on('interaction-move', function (_ref) {\n  var interaction = _ref.interaction;\n  var pointer = _ref.pointer;\n  var event = _ref.event;\n  var eventTarget = _ref.eventTarget;\n  var duplicateMove = _ref.duplicateMove;\n\n  var pointerIndex = interaction.mouse ? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearTimeout(interaction.holdTimers[pointerIndex]);\n    }\n\n    collectEventTargets(interaction, pointer, event, eventTarget, 'move');\n  }\n});\n\nsignals.on('interaction-down', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var pointer = _ref2.pointer;\n  var event = _ref2.event;\n  var eventTarget = _ref2.eventTarget;\n  var pointerIndex = _ref2.pointerIndex;\n\n  // copy event to be used in timeout for IE8\n  var eventCopy = browser.isIE8 ? utils.extend({}, event) : event;\n\n  interaction.holdTimers[pointerIndex] = setTimeout(function () {\n\n    collectEventTargets(interaction, browser.isIE8 ? eventCopy : pointer, eventCopy, eventTarget, 'hold');\n  }, scope.defaultOptions._holdDuration);\n});\n\nfunction createSignalListener(event) {\n  return function (arg) {\n    collectEventTargets(arg.interaction, arg.pointer, arg.event, arg.eventTarget, event);\n  };\n}\n\nfor (var i = 0; i < simpleSignals.length; i++) {\n  signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n}\n\nsignals.on('interaction-new', function (interaction) {\n  interaction.prevTap = null; // the most recent tap event on this interaction\n  interaction.tapTime = 0; // time of the most recent tap event\n});\n\nutils.merge(scope.eventTypes, ['down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold']);\n\nmodule.exports = scope.pointerEvents = {\n  firePointers: firePointers,\n  collectEventTargets: collectEventTargets,\n  preventOriginalDefault: preventOriginalDefault\n};\n\n},{\"./InteractEvent\":2,\"./scope\":19,\"./utils\":28,\"./utils/browser\":21,\"./utils/signals\":34}],19:[function(require,module,exports){\nvar scope = {};\nvar utils = require('./utils');\nvar signals = require('./utils/signals');\n\nscope.defaultOptions = require('./defaultOptions');\nscope.events = require('./utils/events');\nscope.signals = require('./utils/signals');\n\nutils.extend(scope, require('./utils/window'));\nutils.extend(scope, require('./utils/domObjects'));\n\nscope.documents = []; // all documents being listened to\nscope.eventTypes = []; // all event types specific to interact.js\n\nscope.withinInteractionLimit = function (interactable, element, action) {\n  var options = interactable.options;\n  var maxActions = options[action.name].max;\n  var maxPerElement = options[action.name].maxPerElement;\n  var activeInteractions = 0;\n  var targetCount = 0;\n  var targetElementCount = 0;\n\n  for (var i = 0, len = scope.interactions.length; i < len; i++) {\n    var interaction = scope.interactions[i];\n    var otherAction = interaction.prepared.name;\n\n    if (!interaction.interacting()) {\n      continue;\n    }\n\n    activeInteractions++;\n\n    if (activeInteractions >= scope.maxInteractions) {\n      return false;\n    }\n\n    if (interaction.target !== interactable) {\n      continue;\n    }\n\n    targetCount += otherAction === action.name | 0;\n\n    if (targetCount >= maxActions) {\n      return false;\n    }\n\n    if (interaction.element === element) {\n      targetElementCount++;\n\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n        return false;\n      }\n    }\n  }\n\n  return scope.maxInteractions > 0;\n};\n\nscope.endAllInteractions = function (event) {\n  for (var i = 0; i < scope.interactions.length; i++) {\n    scope.interactions[i].pointerEnd(event, event);\n  }\n};\n\nscope.prefixedPropREs = utils.prefixedPropREs;\n\nsignals.on('listen-to-document', function (_ref) {\n  var doc = _ref.doc;\n\n  // if document is already known\n  if (utils.contains(scope.documents, doc)) {\n    // don't call any further signal listeners\n    return false;\n  }\n});\n\nmodule.exports = scope;\n\n},{\"./defaultOptions\":11,\"./utils\":28,\"./utils/domObjects\":22,\"./utils/events\":24,\"./utils/signals\":34,\"./utils/window\":35}],20:[function(require,module,exports){\nfunction indexOf(array, target) {\n  for (var i = 0, len = array.length; i < len; i++) {\n    if (array[i] === target) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction contains(array, target) {\n  return indexOf(array, target) !== -1;\n}\n\nfunction merge(target, source) {\n  for (var i = 0; i < source.length; i++) {\n    target.push(source[i]);\n  }\n\n  return target;\n}\n\nmodule.exports = {\n  indexOf: indexOf,\n  contains: contains,\n  merge: merge\n};\n\n},{}],21:[function(require,module,exports){\nvar win = require('./window');\nvar isType = require('./isType');\nvar domObjects = require('./domObjects');\n\nvar browser = {\n    // Does the browser support touch input?\n    supportsTouch: !!('ontouchstart' in win.window || win.window.DocumentTouch && domObjects.document instanceof win.DocumentTouch),\n\n    // Does the browser support PointerEvents\n    supportsPointerEvent: !!domObjects.PointerEvent,\n\n    isIE8: 'attachEvent' in win.window && !('addEventListener' in win.window),\n\n    // Opera Mobile must be handled differently\n    isOperaMobile: navigator.appName === 'Opera' && browser.supportsTouch && navigator.userAgent.match('Presto'),\n\n    // scrolling doesn't change the result of getClientRects on iOS 7\n    isIOS7: /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion),\n\n    isIe9OrOlder: domObjects.document.all && !win.window.atob,\n\n    // prefix matchesSelector\n    prefixedMatchesSelector: 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector',\n\n    useMatchesSelectorPolyfill: false,\n\n    pEventTypes: domObjects.PointerEvent ? domObjects.PointerEvent === win.window.MSPointerEvent ? { up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n        out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' } : { up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n        out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' } : null\n};\n\nbrowser.useMatchesSelectorPolyfill = !isType.isFunction(Element.prototype[browser.prefixedMatchesSelector]);\n\nmodule.exports = browser;\n\n},{\"./domObjects\":22,\"./isType\":30,\"./window\":35}],22:[function(require,module,exports){\nvar domObjects = {};\nvar win = require('./window').window;\n\nfunction blank() {}\n\ndomObjects.document = win.document;\ndomObjects.DocumentFragment = win.DocumentFragment || blank;\ndomObjects.SVGElement = win.SVGElement || blank;\ndomObjects.SVGSVGElement = win.SVGSVGElement || blank;\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\ndomObjects.HTMLElement = win.HTMLElement || win.Element;\n\ndomObjects.Event = win.Event;\ndomObjects.Touch = win.Touch || blank;\ndomObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;\n\nmodule.exports = domObjects;\n\n},{\"./window\":35}],23:[function(require,module,exports){\nvar win = require('./window');\nvar browser = require('./browser');\nvar isType = require('./isType');\nvar domObjects = require('./domObjects');\n\nvar domUtils = {\n  nodeContains: function (parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  },\n\n  closest: function (child, selector) {\n    var parent = domUtils.parentElement(child);\n\n    while (isType.isElement(parent)) {\n      if (domUtils.matchesSelector(parent, selector)) {\n        return parent;\n      }\n\n      parent = domUtils.parentElement(parent);\n    }\n\n    return null;\n  },\n\n  parentElement: function (node) {\n    var parent = node.parentNode;\n\n    if (isType.isDocFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && isType.isDocFrag(parent)) {\n        continue;\n      }\n\n      return parent;\n    }\n\n    return parent;\n  },\n\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n  matchesSelectorPolyfill: browser.useMatchesSelectorPolyfill ? function (element, selector, elems) {\n    elems = elems || element.parentNode.querySelectorAll(selector);\n\n    for (var i = 0, len = elems.length; i < len; i++) {\n      if (elems[i] === element) {\n        return true;\n      }\n    }\n\n    return false;\n  } : null,\n\n  matchesSelector: function (element, selector, nodeList) {\n    if (browser.useMatchesSelectorPolyfill) {\n      return domUtils.matchesSelectorPolyfill(element, selector, nodeList);\n    }\n\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (win.window !== win.realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[browser.prefixedMatchesSelector](selector);\n  },\n\n  // Test for the element that's \"above\" all other qualifiers\n  indexOfDeepestElement: function (elements) {\n    var deepestZoneParents = [];\n    var dropzoneParents = [];\n    var dropzone = undefined;\n    var deepestZone = elements[0];\n    var index = deepestZone ? 0 : -1;\n    var parent = undefined;\n    var child = undefined;\n    var i = undefined;\n    var n = undefined;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n          deepestZone = dropzone;\n          index = i;\n          continue;\n        }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (deepestZone instanceof domObjects.HTMLElement && dropzone instanceof domObjects.SVGElement && !(dropzone instanceof domObjects.SVGSVGElement)) {\n\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      } else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        } else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  },\n\n  matchesUpTo: function (element, selector, limit) {\n    while (domUtils.isElement(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = domUtils.parentElement(element);\n\n      if (element === limit) {\n        return domUtils.matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  },\n\n  getActualElement: function (element) {\n    return element instanceof domObjects.SVGElementInstance ? element.correspondingUseElement : element;\n  },\n\n  getScrollXY: function (relevantWindow) {\n    relevantWindow = relevantWindow || win.window;\n    return {\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop\n    };\n  },\n\n  getElementClientRect: function (element) {\n    var clientRect = element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];\n\n    return clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top\n    };\n  },\n\n  getElementRect: function (element) {\n    var clientRect = domUtils.getElementClientRect(element);\n\n    if (!browser.isIOS7 && clientRect) {\n      var _scroll = domUtils.getScrollXY(win.getWindow(element));\n\n      clientRect.left += _scroll.x;\n      clientRect.right += _scroll.x;\n      clientRect.top += _scroll.y;\n      clientRect.bottom += _scroll.y;\n    }\n\n    return clientRect;\n  }\n};\n\nmodule.exports = domUtils;\n\n},{\"./browser\":21,\"./domObjects\":22,\"./isType\":30,\"./window\":35}],24:[function(require,module,exports){\nvar arr = require('./arr');\nvar isType = require('./isType');\nvar domUtils = require('./domUtils');\nvar indexOf = arr.indexOf;\nvar contains = arr.contains;\nvar getWindow = require('./window').getWindow;\n\nvar useAttachEvent = 'attachEvent' in window && !('addEventListener' in window);\nvar addEvent = useAttachEvent ? 'attachEvent' : 'addEventListener';\nvar removeEvent = useAttachEvent ? 'detachEvent' : 'removeEventListener';\nvar on = useAttachEvent ? 'on' : '';\n\nvar elements = [];\nvar targets = [];\nvar attachedListeners = [];\n\n// {\n//   type: {\n//     selectors: ['selector', ...],\n//     contexts : [document, ...],\n//     listeners: [[listener, useCapture], ...]\n//   }\n//  }\nvar delegatedEvents = {};\n\nvar documents = [];\n\nfunction add(element, type, listener, useCapture) {\n  var elementIndex = indexOf(elements, element);\n  var target = targets[elementIndex];\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0\n    };\n\n    elementIndex = elements.push(element) - 1;\n    targets.push(target);\n\n    attachedListeners.push(useAttachEvent ? {\n      supplied: [],\n      wrapped: [],\n      useCount: []\n    } : null);\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = [];\n    target.typeCount++;\n  }\n\n  if (!contains(target.events[type], listener)) {\n    var ret = undefined;\n\n    if (useAttachEvent) {\n      var _attachedListeners$elementIndex = attachedListeners[elementIndex];\n      var supplied = _attachedListeners$elementIndex.supplied;\n      var wrapped = _attachedListeners$elementIndex.wrapped;\n      var useCount = _attachedListeners$elementIndex.useCount;\n\n      var listenerIndex = indexOf(supplied, listener);\n\n      var wrappedListener = wrapped[listenerIndex] || function (event) {\n        if (!event.immediatePropagationStopped) {\n          event.target = event.srcElement;\n          event.currentTarget = element;\n\n          event.preventDefault = event.preventDefault || preventDef;\n          event.stopPropagation = event.stopPropagation || stopProp;\n          event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n          if (/mouse|click/.test(event.type)) {\n            event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n            event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n          }\n\n          listener(event);\n        }\n      };\n\n      ret = element[addEvent](on + type, wrappedListener, !!useCapture);\n\n      if (listenerIndex === -1) {\n        supplied.push(listener);\n        wrapped.push(wrappedListener);\n        useCount.push(1);\n      } else {\n        useCount[listenerIndex]++;\n      }\n    } else {\n      ret = element[addEvent](type, listener, !!useCapture);\n    }\n    target.events[type].push(listener);\n\n    return ret;\n  }\n}\n\nfunction remove(element, type, listener, useCapture) {\n  var elementIndex = indexOf(elements, element);\n  var target = targets[elementIndex];\n\n  if (!target || !target.events) {\n    return;\n  }\n\n  var wrappedListener = listener;\n  var listeners = undefined;\n  var listenerIndex = undefined;\n\n  if (useAttachEvent) {\n    listeners = attachedListeners[elementIndex];\n    listenerIndex = indexOf(listeners.supplied, listener);\n    wrappedListener = listeners.wrapped[listenerIndex];\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all');\n      }\n    }\n    return;\n  }\n\n  if (target.events[type]) {\n    var len = target.events[type].length;\n\n    if (listener === 'all') {\n      for (var i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], !!useCapture);\n      }\n      return;\n    } else {\n      for (var i = 0; i < len; i++) {\n        if (target.events[type][i] === listener) {\n          element[removeEvent](on + type, wrappedListener, !!useCapture);\n          target.events[type].splice(i, 1);\n\n          if (useAttachEvent && listeners) {\n            listeners.useCount[listenerIndex]--;\n            if (listeners.useCount[listenerIndex] === 0) {\n              listeners.supplied.splice(listenerIndex, 1);\n              listeners.wrapped.splice(listenerIndex, 1);\n              listeners.useCount.splice(listenerIndex, 1);\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      target.events[type] = null;\n      target.typeCount--;\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1);\n    elements.splice(elementIndex, 1);\n    attachedListeners.splice(elementIndex, 1);\n  }\n}\n\nfunction addDelegate(selector, context, type, listener, useCapture) {\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      selectors: [],\n      contexts: [],\n      listeners: []\n    };\n\n    // add delegate listener functions\n    for (var i = 0; i < documents.length; i++) {\n      add(documents[i], type, delegateListener);\n      add(documents[i], type, delegateUseCapture, true);\n    }\n  }\n\n  var delegated = delegatedEvents[type];\n  var index = undefined;\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n      break;\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length;\n\n    delegated.selectors.push(selector);\n    delegated.contexts.push(context);\n    delegated.listeners.push([]);\n  }\n\n  // keep listener and useCapture flag\n  delegated.listeners[index].push([listener, useCapture]);\n}\n\nfunction removeDelegate(selector, context, type, listener, useCapture) {\n  var delegated = delegatedEvents[type];\n  var matchFound = false;\n  var index = undefined;\n\n  if (!delegated) {\n    return;\n  }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n\n      var listeners = delegated.listeners[index];\n\n      // each item of the listeners array is an array: [function, useCaptureFlag]\n      for (var i = listeners.length - 1; i >= 0; i--) {\n        var fn = listeners[i][0];\n        var useCap = listeners[i][1];\n\n        // check if the listener functions and useCapture flags match\n        if (fn === listener && useCap === useCapture) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1);\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1);\n            delegated.contexts.splice(index, 1);\n            delegated.listeners.splice(index, 1);\n\n            // remove delegate function from context\n            remove(context, type, delegateListener);\n            remove(context, type, delegateUseCapture, true);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null;\n            }\n          }\n\n          // only remove one listener\n          matchFound = true;\n          break;\n        }\n      }\n\n      if (matchFound) {\n        break;\n      }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener(event, useCapture) {\n  var fakeEvent = {};\n  var delegated = delegatedEvents[event.type];\n  var eventTarget = domUtils.getActualElement(event.path ? event.path[0] : event.target);\n  var element = eventTarget;\n\n  useCapture = useCapture ? true : false;\n\n  // duplicate the event so that currentTarget can be changed\n  for (var prop in event) {\n    fakeEvent[prop] = event[prop];\n  }\n\n  fakeEvent.originalEvent = event;\n  fakeEvent.preventDefault = preventOriginalDefault;\n\n  // climb up document tree looking for selector matches\n  while (isType.isElement(element)) {\n    for (var i = 0; i < delegated.selectors.length; i++) {\n      var selector = delegated.selectors[i];\n      var context = delegated.contexts[i];\n\n      if (domUtils.matchesSelector(element, selector) && domUtils.nodeContains(context, eventTarget) && domUtils.nodeContains(context, element)) {\n\n        var listeners = delegated.listeners[i];\n\n        fakeEvent.currentTarget = element;\n\n        for (var j = 0; j < listeners.length; j++) {\n          if (listeners[j][1] === useCapture) {\n            listeners[j][0](fakeEvent);\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentElement(element);\n  }\n}\n\nfunction delegateUseCapture(event) {\n  return delegateListener.call(this, event, true);\n}\n\nfunction preventDef() {\n  this.returnValue = false;\n}\n\nfunction preventOriginalDefault() {\n  this.originalEvent.preventDefault();\n}\n\nfunction stopProp() {\n  this.cancelBubble = true;\n}\n\nfunction stopImmProp() {\n  this.cancelBubble = true;\n  this.immediatePropagationStopped = true;\n}\n\nmodule.exports = {\n  add: add,\n  remove: remove,\n\n  addDelegate: addDelegate,\n  removeDelegate: removeDelegate,\n\n  delegateListener: delegateListener,\n  delegateUseCapture: delegateUseCapture,\n  delegatedEvents: delegatedEvents,\n  documents: documents,\n\n  useAttachEvent: useAttachEvent,\n\n  _elements: elements,\n  _targets: targets,\n  _attachedListeners: attachedListeners\n};\n\n},{\"./arr\":20,\"./domUtils\":23,\"./isType\":30,\"./window\":35}],25:[function(require,module,exports){\nmodule.exports = function extend(dest, source) {\n  for (var prop in source) {\n    dest[prop] = source[prop];\n  }\n  return dest;\n};\n\n},{}],26:[function(require,module,exports){\nvar _require = require('./domUtils');\n\nvar closest = _require.closest;\nvar parentElement = _require.parentElement;\nvar getElementRect = _require.getElementRect;\n\nvar _require2 = require('./isType');\n\nvar isElement = _require2.isElement;\nvar isFunction = _require2.isFunction;\nvar trySelector = _require2.trySelector;\n\nmodule.exports = function (interactable, element) {\n  var origin = interactable.options.origin;\n\n  if (origin === 'parent') {\n    origin = parentElement(element);\n  } else if (origin === 'self') {\n    origin = interactable.getRect(element);\n  } else if (trySelector(origin)) {\n    origin = closest(element, origin) || { x: 0, y: 0 };\n  }\n\n  if (isFunction(origin)) {\n    origin = origin(interactable && element);\n  }\n\n  if (isElement(origin)) {\n    origin = getElementRect(origin);\n  }\n\n  origin.x = 'x' in origin ? origin.x : origin.left;\n  origin.y = 'y' in origin ? origin.y : origin.top;\n\n  return origin;\n};\n\n},{\"./domUtils\":23,\"./isType\":30}],27:[function(require,module,exports){\nmodule.exports = function (x, y) {\n  return Math.sqrt(x * x + y * y);\n};\n\n},{}],28:[function(require,module,exports){\nvar utils = module.exports;\nvar extend = require('./extend');\nvar win = require('./window');\n\nutils.blank = function () {};\n\nutils.warnOnce = function (method, message) {\n  var warned = false;\n\n  return function () {\n    if (!warned) {\n      win.window.console.warn(message);\n      warned = true;\n    }\n\n    return method.apply(this, arguments);\n  };\n};\n\n// http://stackoverflow.com/a/5634528/2280888\nutils._getQBezierValue = function (t, p1, p2, p3) {\n  var iT = 1 - t;\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n};\n\nutils.getQuadraticCurvePoint = function (startX, startY, cpX, cpY, endX, endY, position) {\n  return {\n    x: utils._getQBezierValue(position, startX, cpX, endX),\n    y: utils._getQBezierValue(position, startY, cpY, endY)\n  };\n};\n\n// http://gizma.com/easing/\nutils.easeOutQuad = function (t, b, c, d) {\n  t /= d;\n  return -c * t * (t - 2) + b;\n};\n\nutils.extend = extend;\nutils.hypot = require('./hypot');\nutils.raf = require('./raf');\nutils.browser = require('./browser');\nutils.getOriginXY = require('./getOriginXY');\n\nextend(utils, require('./arr'));\nextend(utils, require('./isType'));\nextend(utils, require('./domUtils'));\nextend(utils, require('./pointerUtils'));\n\n},{\"./arr\":20,\"./browser\":21,\"./domUtils\":23,\"./extend\":25,\"./getOriginXY\":26,\"./hypot\":27,\"./isType\":30,\"./pointerUtils\":32,\"./raf\":33,\"./window\":35}],29:[function(require,module,exports){\nvar scope = require('../scope');\nvar utils = require('./index');\nvar browser = require('./browser');\n\nvar finder = {\n  methodOrder: ['inertiaResume', 'mouse', 'hasPointer', 'idle'],\n\n  search: function (pointer, eventType, eventTarget) {\n    var mouseEvent = /mouse/i.test(pointer.pointerType || eventType)\n    // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n     || pointer.pointerType === 4;\n    var pointerId = utils.getPointerId(pointer);\n    var details = { pointer: pointer, pointerId: pointerId, mouseEvent: mouseEvent, eventType: eventType, eventTarget: eventTarget };\n\n    for (var _iterator = finder.methodOrder, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var method = _ref;\n\n      var interaction = finder[method](details);\n\n      if (interaction) {\n        return interaction;\n      }\n    }\n  },\n\n  // try to resume inertia with a new pointer\n  inertiaResume: function (_ref7) {\n    var mouseEvent = _ref7.mouseEvent;\n    var eventType = _ref7.eventType;\n    var eventTarget = _ref7.eventTarget;\n\n    if (!/down|start/i.test(eventType)) {\n      return null;\n    }\n\n    for (var _iterator2 = scope.interactions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var interaction = _ref2;\n\n      var element = eventTarget;\n\n      if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume && interaction.mouse === mouseEvent) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction;\n          }\n          element = utils.parentElement(element);\n        }\n      }\n    }\n\n    return null;\n  },\n\n  // if it's a mouse interaction\n  mouse: function (_ref8) {\n    var mouseEvent = _ref8.mouseEvent;\n    var eventType = _ref8.eventType;\n\n    if (!mouseEvent && (browser.supportsTouch || browser.supportsPointerEvent)) {\n      return null;\n    }\n\n    // Find a mouse interaction that's not in inertia phase\n    for (var _iterator3 = scope.interactions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var interaction = _ref3;\n\n      if (interaction.mouse && !interaction.inertiaStatus.active) {\n        return interaction;\n      }\n    }\n\n    // Find any interaction specifically for mouse.\n    // If the eventType is a mousedown, and inertia is active\n    // ignore the interaction\n    for (var _iterator4 = scope.interactions, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var interaction = _ref4;\n\n      if (interaction.mouse && !(/down/.test(eventType) && interaction.inertiaStatus.active)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n\n  // get interaction that has this pointer\n  hasPointer: function (_ref9) {\n    var pointerId = _ref9.pointerId;\n\n    for (var _iterator5 = scope.interactions, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n      var _ref5;\n\n      if (_isArray5) {\n        if (_i5 >= _iterator5.length) break;\n        _ref5 = _iterator5[_i5++];\n      } else {\n        _i5 = _iterator5.next();\n        if (_i5.done) break;\n        _ref5 = _i5.value;\n      }\n\n      var interaction = _ref5;\n\n      if (utils.contains(interaction.pointerIds, pointerId)) {\n        return interaction;\n      }\n    }\n  },\n\n  // get first idle interaction\n  idle: function (_ref10) {\n    var mouseEvent = _ref10.mouseEvent;\n\n    for (var _iterator6 = scope.interactions, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n      var _ref6;\n\n      if (_isArray6) {\n        if (_i6 >= _iterator6.length) break;\n        _ref6 = _iterator6[_i6++];\n      } else {\n        _i6 = _iterator6.next();\n        if (_i6.done) break;\n        _ref6 = _i6.value;\n      }\n\n      var interaction = _ref6;\n\n      if ((!interaction.prepared.name || interaction.target.options.gesture.enabled) && !interaction.interacting() && !(!mouseEvent && interaction.mouse)) {\n\n        return interaction;\n      }\n    }\n\n    return null;\n  }\n};\n\nmodule.exports = finder;\n\n},{\"../scope\":19,\"./browser\":21,\"./index\":28}],30:[function(require,module,exports){\nvar win = require('./window');\nvar isWindow = require('./isWindow');\nvar domObjects = require('./domObjects');\n\nvar isType = {\n  isElement: function (o) {\n    if (!o || typeof o !== 'object') {\n      return false;\n    }\n\n    var _window = win.getWindow(o) || win.window;\n\n    return (/object|function/.test(typeof _window.Element) ? o instanceof _window.Element //DOM2\n      : o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  },\n\n  isArray: null,\n\n  isWindow: function (thing) {\n    return thing === win.window || isWindow(thing);\n  },\n\n  isDocFrag: function (thing) {\n    return !!thing && thing instanceof domObjects.DocumentFragment;\n  },\n\n  isObject: function (thing) {\n    return !!thing && typeof thing === 'object';\n  },\n\n  isFunction: function (thing) {\n    return typeof thing === 'function';\n  },\n\n  isNumber: function (thing) {\n    return typeof thing === 'number';\n  },\n\n  isBool: function (thing) {\n    return typeof thing === 'boolean';\n  },\n\n  isString: function (thing) {\n    return typeof thing === 'string';\n  },\n\n  trySelector: function (value) {\n    if (!isType.isString(value)) {\n      return false;\n    }\n\n    // an exception will be raised if it is invalid\n    domObjects.document.querySelector(value);\n    return true;\n  }\n};\n\nisType.isArray = function (thing) {\n  return isType.isObject(thing) && typeof thing.length !== 'undefined' && isType.isFunction(thing.splice);\n};\n\nmodule.exports = isType;\n\n},{\"./domObjects\":22,\"./isWindow\":31,\"./window\":35}],31:[function(require,module,exports){\nmodule.exports = function (thing) {\n  return !!(thing && thing.Window) && thing instanceof thing.Window;\n};\n\n},{}],32:[function(require,module,exports){\nvar hypot = require('./hypot');\nvar browser = require('./browser');\nvar dom = require('./domObjects');\nvar isType = require('./isType');\n\nvar pointerUtils = {\n  copyCoords: function (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  },\n\n  setEventDeltas: function (targetObj, prev, cur) {\n    var now = new Date().getTime();\n\n    targetObj.page.x = cur.page.x - prev.page.x;\n    targetObj.page.y = cur.page.y - prev.page.y;\n    targetObj.client.x = cur.client.x - prev.client.x;\n    targetObj.client.y = cur.client.y - prev.client.y;\n    targetObj.timeStamp = now - prev.timeStamp;\n\n    // set pointer velocity\n    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\n    targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx = targetObj.page.x / dt;\n    targetObj.page.vy = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx = targetObj.client.x / dt;\n    targetObj.client.vy = targetObj.client.y / dt;\n  },\n\n  isNativePointer: function (pointer) {\n    return pointer instanceof dom.Event || pointer instanceof dom.Touch;\n  },\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  getXY: function (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  },\n\n  getPageXY: function (pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      pointerUtils.getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    } else {\n      pointerUtils.getXY('page', pointer, page);\n    }\n\n    return page;\n  },\n\n  getClientXY: function (pointer, client) {\n    client = client || {};\n\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      pointerUtils.getXY('screen', pointer, client);\n    } else {\n      pointerUtils.getXY('client', pointer, client);\n    }\n\n    return client;\n  },\n\n  getPointerId: function (pointer) {\n    return isType.isNumber(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\n  },\n\n  prefixedPropREs: {\n    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n  },\n\n  pointerExtend: function (dest, source) {\n    for (var prop in source) {\n      var prefixedPropREs = pointerUtils.prefixedPropREs;\n      var deprecated = false;\n\n      // skip deprecated prefixed properties\n      for (var vendor in prefixedPropREs) {\n        if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n          deprecated = true;\n          break;\n        }\n      }\n\n      if (!deprecated) {\n        dest[prop] = source[prop];\n      }\n    }\n    return dest;\n  },\n\n  getTouchPair: function (event) {\n    var touches = [];\n\n    // array of touches is supplied\n    if (isType.isArray(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n        if (event.type === 'touchend') {\n          if (event.touches.length === 1) {\n            touches[0] = event.touches[0];\n            touches[1] = event.changedTouches[0];\n          } else if (event.touches.length === 0) {\n            touches[0] = event.changedTouches[0];\n            touches[1] = event.changedTouches[1];\n          }\n        } else {\n          touches[0] = event.touches[0];\n          touches[1] = event.touches[1];\n        }\n      }\n\n    return touches;\n  },\n\n  pointerAverage: function (pointers) {\n    var average = {\n      pageX: 0,\n      pageY: 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0\n    };\n\n    for (var _iterator = pointers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var pointer = _ref;\n\n      for (var prop in average) {\n        average[prop] += pointer[prop];\n      }\n    }\n    for (var prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  },\n\n  touchBBox: function (event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    var touches = pointerUtils.getTouchPair(event);\n    var minX = Math.min(touches[0].pageX, touches[1].pageX);\n    var minY = Math.min(touches[0].pageY, touches[1].pageY);\n    var maxX = Math.max(touches[0].pageX, touches[1].pageX);\n    var maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  },\n\n  touchDistance: function (event, deltaSource) {\n    deltaSource = deltaSource;\n\n    var sourceX = deltaSource + 'X';\n    var sourceY = deltaSource + 'Y';\n    var touches = pointerUtils.getTouchPair(event);\n\n    var dx = touches[0][sourceX] - touches[1][sourceX];\n    var dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  },\n\n  touchAngle: function (event, prevAngle, deltaSource) {\n    deltaSource = deltaSource;\n\n    var sourceX = deltaSource + 'X';\n    var sourceY = deltaSource + 'Y';\n    var touches = pointerUtils.getTouchPair(event);\n    var dx = touches[0][sourceX] - touches[1][sourceX];\n    var dy = touches[0][sourceY] - touches[1][sourceY];\n    var angle = 180 * Math.atan(dy / dx) / Math.PI;\n\n    if (isType.isNumber(prevAngle)) {\n      var dr = angle - prevAngle;\n      var drClamped = dr % 360;\n\n      if (drClamped > 315) {\n        angle -= 360 + angle / 360 | 0 * 360;\n      } else if (drClamped > 135) {\n        angle -= 180 + angle / 360 | 0 * 360;\n      } else if (drClamped < -315) {\n        angle += 360 + angle / 360 | 0 * 360;\n      } else if (drClamped < -135) {\n        angle += 180 + angle / 360 | 0 * 360;\n      }\n    }\n\n    return angle;\n  }\n};\n\nmodule.exports = pointerUtils;\n\n},{\"./browser\":21,\"./domObjects\":22,\"./hypot\":27,\"./isType\":30}],33:[function(require,module,exports){\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\nvar lastTime = 0;\nvar request = undefined;\nvar cancel = undefined;\n\nfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n  request = window[vendors[x] + 'RequestAnimationFrame'];\n  cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  request = function (callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  cancel = function (id) {\n    clearTimeout(id);\n  };\n}\n\nmodule.exports = {\n  request: request,\n  cancel: cancel\n};\n\n},{}],34:[function(require,module,exports){\nvar _require = require('./arr');\n\nvar indexOf = _require.indexOf;\n\nvar listeners = {\n  // signalName: [listeners],\n};\n\nvar signals = {\n  on: function (name, listener) {\n    if (!listeners[name]) {\n      listeners[name] = [listener];\n      return;\n    }\n\n    listeners[name].push(listener);\n  },\n  off: function (name, listener) {\n    if (!listeners[name]) {\n      return;\n    }\n\n    var index = indexOf(listeners[name], listener);\n\n    if (index !== -1) {\n      listeners[name].splice(index, 1);\n    }\n  },\n  fire: function (name, arg) {\n    var targetListeners = listeners[name];\n\n    if (!targetListeners) {\n      return;\n    }\n\n    for (var i = 0; i < targetListeners.length; i++) {\n      if (targetListeners[i](arg, name) === false) {\n        return;\n      }\n    }\n  },\n  listeners: listeners\n};\n\nmodule.exports = signals;\n\n},{\"./arr\":20}],35:[function(require,module,exports){\nvar win = module.exports;\nvar isWindow = require('./isWindow');\n\nfunction init(window) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  win.realWindow = window;\n\n  // create a TextNode\n  var el = window.document.createTextNode('');\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n    // return wrapped window\n    win.window = window.wrap(window);\n  }\n\n  // no Shadow DOM polyfil or native implementation\n  win.window = window;\n}\n\nif (typeof window === 'undefined') {\n  win.window = undefined;\n  win.realWindow = undefined;\n} else {\n  init(window);\n}\n\nwin.getWindow = function getWindow(node) {\n  if (isWindow(node)) {\n    return node;\n  }\n\n  var rootNode = node.ownerDocument || node;\n\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\n};\n\nwin.init = init;\n\n},{\"./isWindow\":31}]},{},[1])(1)\n});\n//# sourceMappingURL=interact.js.map\n","const hypot       = require('./utils/hypot');\nconst extend      = require('./utils/extend');\nconst getOriginXY = require('./utils/getOriginXY');\nconst signals     = require('./utils/signals');\nconst modifiers   = require('./modifiers/base');\nconst scope       = require('./scope');\n\nclass InteractEvent {\n  constructor (interaction, event, action, phase, element, related) {\n    const target      = interaction.target;\n    const deltaSource = (target && target.options || scope.defaultOptions).deltaSource;\n    const sourceX     = deltaSource + 'X';\n    const sourceY     = deltaSource + 'Y';\n    const origin      = getOriginXY(target, element);\n    const starting    = phase === 'start';\n    const ending      = phase === 'end';\n    const coords      = starting? interaction.startCoords : interaction.curCoords;\n\n    element = element || interaction.element;\n\n    const page   = extend({}, coords.page);\n    const client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    this.ctrlKey       = event.ctrlKey;\n    this.altKey        = event.altKey;\n    this.shiftKey      = event.shiftKey;\n    this.metaKey       = event.metaKey;\n    this.button        = event.button;\n    this.buttons       = event.buttons;\n    this.target        = element;\n    this.relatedTarget = related || null;\n    this.t0            = interaction.downTimes[interaction.downTimes.length - 1];\n    this.type          = action + (phase || '');\n    this.interaction   = interaction;\n    this.interactable  = target;\n\n    for (let i = 0; i < modifiers.names.length; i++) {\n      const modifierName = modifiers.names[i];\n      const modifier = modifiers[modifierName];\n\n      this[modifierName] = modifier.modifyCoords(page, client, target, interaction.modifierStatuses[modifierName], action, phase);\n    }\n\n    this.pageX     = page.x;\n    this.pageY     = page.y;\n    this.clientX   = client.x;\n    this.clientY   = client.y;\n\n    this.x0        = interaction.startCoords.page.x - origin.x;\n    this.y0        = interaction.startCoords.page.y - origin.y;\n    this.clientX0  = interaction.startCoords.client.x - origin.x;\n    this.clientY0  = interaction.startCoords.client.y - origin.y;\n\n    const signalArg = {\n      interaction,\n      event,\n      action,\n      phase,\n      element,\n      related,\n      page,\n      client,\n      coords,\n      starting,\n      ending,\n      deltaSource,\n      iEvent: this,\n    };\n\n    const inertiaStatus = interaction.inertiaStatus;\n\n    if (inertiaStatus.active) {\n      this.detail = 'inertia';\n    }\n\n    signals.fire('interactevent-new', signalArg);\n    signals.fire('interactevent-' + action, signalArg);\n\n    if (starting) {\n      this.timeStamp = interaction.downTimes[0];\n      this.dt        = 0;\n      this.duration  = 0;\n      this.speed     = 0;\n      this.velocityX = 0;\n      this.velocityY = 0;\n    }\n    else if (phase === 'inertiastart') {\n      this.timeStamp = interaction.prevEvent.timeStamp;\n      this.dt        = interaction.prevEvent.dt;\n      this.duration  = interaction.prevEvent.duration;\n      this.speed     = interaction.prevEvent.speed;\n      this.velocityX = interaction.prevEvent.velocityX;\n      this.velocityY = interaction.prevEvent.velocityY;\n    }\n    else {\n      this.timeStamp = new Date().getTime();\n      this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n      this.duration  = this.timeStamp - interaction.downTimes[0];\n\n      if (event instanceof InteractEvent) {\n        const dx = this[sourceX] - interaction.prevEvent[sourceX];\n        const dy = this[sourceY] - interaction.prevEvent[sourceY];\n        const dt = this.dt / 1000;\n\n        this.speed = hypot(dx, dy) / dt;\n        this.velocityX = dx / dt;\n        this.velocityY = dy / dt;\n      }\n      // if normal move or end event, use previous user event coords\n      else {\n        // speed and velocity in pixels per second\n        this.speed = interaction.pointerDelta[deltaSource].speed;\n        this.velocityX = interaction.pointerDelta[deltaSource].vx;\n        this.velocityY = interaction.pointerDelta[deltaSource].vy;\n      }\n    }\n\n    if ((ending || phase === 'inertiastart')\n        && interaction.prevEvent.speed > 600\n        && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n      let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n      const overlap = 22.5;\n\n      if (angle < 0) {\n        angle += 360;\n      }\n\n      const left = 135 - overlap <= angle && angle < 225 + overlap;\n      const up   = 225 - overlap <= angle && angle < 315 + overlap;\n\n      const right = !left && (315 - overlap <= angle || angle <  45 + overlap);\n      const down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n      this.swipe = {\n        up,\n        down,\n        left,\n        right,\n        angle,\n        speed: interaction.prevEvent.speed,\n        velocity: {\n          x: interaction.prevEvent.velocityX,\n          y: interaction.prevEvent.velocityY,\n        },\n      };\n    }\n  }\n\n  preventDefault () {}\n\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  }\n\n  stopPropagation () {\n    this.propagationStopped = true;\n  }\n}\n\nsignals.on('interactevent-new', function ({ iEvent, interaction, action, phase, ending, starting,\n                                            page, client, deltaSource }) {\n  // end event dx, dy is difference between start and end points\n  if (ending) {\n    if (deltaSource === 'client') {\n      iEvent.dx = client.x - interaction.startCoords.client.x;\n      iEvent.dy = client.y - interaction.startCoords.client.y;\n    }\n    else {\n      iEvent.dx = page.x - interaction.startCoords.page.x;\n      iEvent.dy = page.y - interaction.startCoords.page.y;\n    }\n  }\n  else if (starting) {\n    iEvent.dx = 0;\n    iEvent.dy = 0;\n  }\n  // copy properties from previousmove if starting inertia\n  else if (phase === 'inertiastart') {\n    iEvent.dx = interaction.prevEvent.dx;\n    iEvent.dy = interaction.prevEvent.dy;\n  }\n  else {\n    if (deltaSource === 'client') {\n      iEvent.dx = client.x - interaction.prevEvent.clientX;\n      iEvent.dy = client.y - interaction.prevEvent.clientY;\n    }\n    else {\n      iEvent.dx = page.x - interaction.prevEvent.pageX;\n      iEvent.dy = page.y - interaction.prevEvent.pageY;\n    }\n  }\n\n  const options = interaction.target.options;\n  const inertiaStatus = interaction.inertiaStatus;\n\n  if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n      && !inertiaStatus.active\n      && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\n    inertiaStatus.resumeDx += iEvent.dx;\n    inertiaStatus.resumeDy += iEvent.dy;\n\n    iEvent.dx = iEvent.dy = 0;\n  }\n});\n\nmodule.exports = InteractEvent;\n","const isType  = require('./utils/isType');\nconst events  = require('./utils/events');\nconst signals = require('./utils/signals');\nconst extend  = require('./utils/extend');\nconst actions = require('./actions/base');\nconst scope   = require('./scope');\n\nconst { getElementRect }    = require('./utils/domUtils');\nconst { indexOf, contains } = require('./utils/arr');\n\n// all set interactables\nscope.interactables = [];\n\n/*\\\n * Interactable\n [ property ]\n **\n * Object type returned by @interact\n\\*/\nclass Interactable {\n  constructor (element, options) {\n    this._element = element;\n    this._context = scope.document;\n    this._iEvents = this._iEvents || {};\n\n    let _window;\n\n    if (isType.trySelector(element)) {\n      this.selector = element;\n\n      const context = options && options.context;\n\n      _window = context? scope.getWindow(context) : scope.window;\n\n      if (context && (_window.Node\n        ? context instanceof _window.Node\n        : (isType.isElement(context) || context === _window.document))) {\n\n        this._context = context;\n      }\n    }\n    else {\n      _window = scope.getWindow(element);\n    }\n\n    this._doc = _window.document;\n\n    signals.fire('interactable-new', {\n      element,\n      options,\n      interactable: this,\n      win: _window,\n    });\n\n    if (this._doc !== scope.document) {\n      signals.fire('listen-to-document', {\n        doc: this._doc,\n        win: _window,\n      });\n    }\n\n    scope.interactables.push(this);\n\n    this.set(options);\n  }\n\n  setOnEvents (action, phases) {\n    const onAction = 'on' + action;\n\n    if (isType.isFunction(phases.onstart)       ) { this[onAction + 'start'        ] = phases.onstart         ; }\n    if (isType.isFunction(phases.onmove)        ) { this[onAction + 'move'         ] = phases.onmove          ; }\n    if (isType.isFunction(phases.onend)         ) { this[onAction + 'end'          ] = phases.onend           ; }\n    if (isType.isFunction(phases.oninertiastart)) { this[onAction + 'inertiastart' ] = phases.oninertiastart  ; }\n\n    return this;\n  }\n\n  setPerAction (action, options) {\n    // for all the default per-action options\n    for (const option in options) {\n      // if this option exists for this action\n      if (option in scope.defaultOptions[action]) {\n        // if the option in the options arg is an object value\n        if (isType.isObject(options[option])) {\n          // duplicate the object\n          this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n          if (isType.isObject(scope.defaultOptions.perAction[option]) && 'enabled' in scope.defaultOptions.perAction[option]) {\n            this.options[action][option].enabled = options[option].enabled === false? false : true;\n          }\n        }\n        else if (isType.isBool(options[option]) && isType.isObject(scope.defaultOptions.perAction[option])) {\n          this.options[action][option].enabled = options[option];\n        }\n        else if (options[option] !== undefined) {\n          // or if it's not undefined, do a plain assignment\n          this.options[action][option] = options[option];\n        }\n      }\n    }\n  }\n\n  getAction (pointer, event, interaction, element) {\n    const action = this.defaultActionChecker(pointer, event, interaction, element);\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction);\n    }\n\n    return action;\n  }\n\n  /*\\\n   * Interactable.actionChecker\n   [ method ]\n   *\n   * Gets or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n   = (Function | Interactable) The checker function or this Interactable\n   *\n   | interact('.resize-drag')\n   |   .resizable(true)\n   |   .draggable(true)\n   |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   |\n   |   if (interact.matchesSelector(event.target, '.drag-handle') {\n   |     // force drag with handle target\n   |     action.name = drag;\n   |   }\n   |   else {\n   |     // resize from the top and right edges\n   |     action.name  = 'resize';\n   |     action.edges = { top: true, right: true };\n   |   }\n   |\n   |   return action;\n   | });\n  \\*/\n  actionChecker (checker) {\n    if (isType.isFunction(checker)) {\n      this.options.actionChecker = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.actionChecker;\n\n      return this;\n    }\n\n    return this.options.actionChecker;\n  }\n\n  /*\\\n   * Interactable.getRect\n   [ method ]\n   *\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using @Interactable.rectChecker.\n   *\n   - element (Element) #optional The element to measure.\n   = (object) The object's bounding rectangle.\n   o {\n   o     top   : 0,\n   o     left  : 0,\n   o     bottom: 0,\n   o     right : 0,\n   o     width : 0,\n   o     height: 0\n   o }\n  \\*/\n  getRect (element) {\n    element = element || this._element;\n\n    if (this.selector && !(isType.isElement(element))) {\n      element = this._context.querySelector(this.selector);\n    }\n\n    return getElementRect(element);\n  }\n\n  /*\\\n   * Interactable.rectChecker\n   [ method ]\n   *\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n   = (function | object) The checker function or this Interactable\n  \\*/\n  rectChecker (checker) {\n    if (isType.isFunction(checker)) {\n      this.getRect = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.getRect;\n\n      return this;\n    }\n\n    return this.getRect;\n  }\n\n  /*\\\n   * Interactable.styleCursor\n   [ method ]\n   *\n   * Returns or sets whether the action that would be performed when the\n   * mouse on the element are checked on `mousemove` so that the cursor\n   * may be styled appropriately\n   *\n   - newValue (boolean) #optional\n   = (boolean | Interactable) The current setting or this Interactable\n  \\*/\n  styleCursor (newValue) {\n    if (isType.isBool(newValue)) {\n      this.options.styleCursor = newValue;\n\n      return this;\n    }\n\n    if (newValue === null) {\n      delete this.options.styleCursor;\n\n      return this;\n    }\n\n    return this.options.styleCursor;\n  }\n\n  /*\\\n   * Interactable.preventDefault\n   [ method ]\n   *\n   * Returns or sets whether to prevent the browser's default behaviour\n   * in response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   - newValue (string) #optional `true`, `false` or `'auto'`\n   = (string | Interactable) The current setting or this Interactable\n  \\*/\n  preventDefault (newValue) {\n    if (/^(always|never|auto)$/.test(newValue)) {\n      this.options.preventDefault = newValue;\n      return this;\n    }\n\n    if (isType.isBool(newValue)) {\n      this.options.preventDefault = newValue? 'always' : 'never';\n      return this;\n    }\n\n    return this.options.preventDefault;\n  }\n\n  /*\\\n   * Interactable.origin\n   [ method ]\n   *\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n   * OR\n   - origin (Element) #optional An HTML or SVG Element whose rect will be used\n   **\n   = (object) The current origin or this Interactable\n  \\*/\n  origin (newValue) {\n    if (isType.trySelector(newValue)) {\n      this.options.origin = newValue;\n      return this;\n    }\n    else if (isType.isObject(newValue)) {\n      this.options.origin = newValue;\n      return this;\n    }\n\n    return this.options.origin;\n  }\n\n  /*\\\n   * Interactable.deltaSource\n   [ method ]\n   *\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n   = (string | object) The current deltaSource or this Interactable\n  \\*/\n  deltaSource (newValue) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue;\n\n      return this;\n    }\n\n    return this.options.deltaSource;\n  }\n\n  /*\\\n   * Interactable.context\n   [ method ]\n   *\n   * Gets the selector context Node of the Interactable. The default is `window.document`.\n   *\n   = (Node) The context Node of this Interactable\n   **\n  \\*/\n  context () {\n    return this._context;\n  }\n\n  /*\\\n   * Interactable.ignoreFrom\n   [ method ]\n   *\n   * If the target of the `mousedown`, `pointerdown` or `touchstart`\n   * event or any of it's parents match the given CSS selector or\n   * Element, no drag/resize/gesture is started.\n   *\n   - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n   = (string | Element | object) The current ignoreFrom value or this Interactable\n   **\n   | interact(element, { ignoreFrom: document.getElementById('no-action') });\n   | // or\n   | interact(element).ignoreFrom('input, textarea, a');\n  \\*/\n  ignoreFrom (newValue) {\n    if (isType.trySelector(newValue)) {            // CSS selector to match event.target\n      this.options.ignoreFrom = newValue;\n      return this;\n    }\n\n    if (isType.isElement(newValue)) {              // specific element\n      this.options.ignoreFrom = newValue;\n      return this;\n    }\n\n    return this.options.ignoreFrom;\n  }\n\n  /*\\\n   * Interactable.allowFrom\n   [ method ]\n   *\n   * A drag/resize/gesture is started only If the target of the\n   * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n   * parents match the given CSS selector or Element.\n   *\n   - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n   = (string | Element | object) The current allowFrom value or this Interactable\n   **\n   | interact(element, { allowFrom: document.getElementById('drag-handle') });\n   | // or\n   | interact(element).allowFrom('.handle');\n  \\*/\n  allowFrom (newValue) {\n    if (isType.trySelector(newValue)) {            // CSS selector to match event.target\n      this.options.allowFrom = newValue;\n      return this;\n    }\n\n    if (isType.isElement(newValue)) {              // specific element\n      this.options.allowFrom = newValue;\n      return this;\n    }\n\n    return this.options.allowFrom;\n  }\n\n  /*\\\n   * Interactable.element\n   [ method ]\n   *\n   * If this is not a selector Interactable, it returns the element this\n   * interactable represents\n   *\n   = (Element) HTML / SVG Element\n  \\*/\n  element () {\n    return this._element;\n  }\n\n  /*\\\n   * Interactable.fire\n   [ method ]\n   *\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n   = (Interactable) this Interactable\n  \\*/\n  fire (iEvent) {\n    if (!(iEvent && iEvent.type) || !contains(scope.eventTypes, iEvent.type)) {\n      return this;\n    }\n\n    let listeners;\n    const onEvent = 'on' + iEvent.type;\n\n    // Interactable#on() listeners\n    if (iEvent.type in this._iEvents) {\n      listeners = this._iEvents[iEvent.type];\n\n      for (let i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n        listeners[i](iEvent);\n      }\n    }\n\n    // interactable.onevent listener\n    if (isType.isFunction(this[onEvent])) {\n      this[onEvent](iEvent);\n    }\n\n    // interact.on() listeners\n    if (iEvent.type in scope.globalEvents && (listeners = scope.globalEvents[iEvent.type]))  {\n\n      for (let i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n        listeners[i](iEvent);\n      }\n    }\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.on\n   [ method ]\n   *\n   * Binds a listener for an InteractEvent or DOM event.\n   *\n   - eventType  (string | array | object) The types of events to listen for\n   - listener   (function) The function event (s)\n   - useCapture (boolean) #optional useCapture flag for addEventListener\n   = (object) This Interactable\n  \\*/\n  on (eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (let i = 0; i < eventType.length; i++) {\n        this.on(eventType[i], listener, useCapture);\n      }\n\n      return this;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (const prop in eventType) {\n        this.on(prop, eventType[prop], listener);\n      }\n\n      return this;\n    }\n\n    if (eventType === 'wheel') {\n      eventType = scope.wheelEvent;\n    }\n\n    // convert to boolean\n    useCapture = useCapture? true: false;\n\n    if (contains(scope.eventTypes, eventType)) {\n      // if this type of event was never bound to this Interactable\n      if (!(eventType in this._iEvents)) {\n        this._iEvents[eventType] = [listener];\n      }\n      else {\n        this._iEvents[eventType].push(listener);\n      }\n    }\n    // delegated event for selector\n    else if (this.selector) {\n      events.addDelegate(this.selector, this._context, eventType, listener, useCapture);\n    }\n    else {\n      events.add(this._element, eventType, listener, useCapture);\n    }\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.off\n   [ method ]\n   *\n   * Removes an InteractEvent or DOM event listener\n   *\n   - eventType  (string | array | object) The types of events that were listened for\n   - listener   (function) The listener function to be removed\n   - useCapture (boolean) #optional useCapture flag for removeEventListener\n   = (object) This Interactable\n  \\*/\n  off (eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (let i = 0; i < eventType.length; i++) {\n        this.off(eventType[i], listener, useCapture);\n      }\n\n      return this;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (const prop in eventType) {\n        this.off(prop, eventType[prop], listener);\n      }\n\n      return this;\n    }\n\n\n    // convert to boolean\n    useCapture = useCapture? true: false;\n\n    if (eventType === 'wheel') {\n      eventType = scope.wheelEvent;\n    }\n\n    // if it is an action event type\n    if (contains(scope.eventTypes, eventType)) {\n      const eventList = this._iEvents[eventType];\n      const index     = eventList? indexOf(eventList, listener) : -1;\n\n      if (index !== -1) {\n        this._iEvents[eventType].splice(index, 1);\n      }\n    }\n    // delegated event\n    else if (this.selector) {\n      events.removeDelegate(this.selector, this._context, eventType, listener, useCapture);\n    }\n    // remove listener from this Interatable's element\n    else {\n      events.remove(this._element, eventType, listener, useCapture);\n    }\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.set\n   [ method ]\n   *\n   * Reset the options of this Interactable\n   - options (object) The new settings to apply\n   = (object) This Interactable\n  \\*/\n  set (options) {\n    if (!isType.isObject(options)) {\n      options = {};\n    }\n\n    this.options = extend({}, scope.defaultOptions.base);\n\n    const perActions = extend({}, scope.defaultOptions.perAction);\n\n    for (const actionName in actions.methodDict) {\n      const methodName = actions.methodDict[actionName];\n\n      this.options[actionName] = extend({}, scope.defaultOptions[actionName]);\n\n      this.setPerAction(actionName, perActions);\n\n      this[methodName](options[actionName]);\n    }\n\n    const settings = [\n      'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n      'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n      'rectChecker', 'styleCursor',\n    ];\n\n    for (let i = 0, len = settings.length; i < len; i++) {\n      const setting = settings[i];\n\n      this.options[setting] = scope.defaultOptions.base[setting];\n\n      if (setting in options) {\n        this[setting](options[setting]);\n      }\n    }\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.unset\n   [ method ]\n   *\n   * Remove this interactable from the list of interactables and remove\n   * it's action capabilities and event listeners\n   *\n   = (object) @interact\n  \\*/\n  unset () {\n    events.remove(this._element, 'all');\n\n    if (!isType.isString(this.selector)) {\n      events.remove(this, 'all');\n      if (this.options.styleCursor) {\n        this._element.style.cursor = '';\n      }\n    }\n    else {\n      // remove delegated events\n      for (const type in events.delegatedEvents) {\n        const delegated = events.delegatedEvents[type];\n\n        for (let i = 0; i < delegated.selectors.length; i++) {\n          if (delegated.selectors[i] === this.selector\n              && delegated.contexts[i] === this._context) {\n\n            delegated.selectors.splice(i, 1);\n            delegated.contexts .splice(i, 1);\n            delegated.listeners.splice(i, 1);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegated[type] = null;\n            }\n          }\n\n          events.remove(this._context, type, events.delegateListener);\n          events.remove(this._context, type, events.delegateUseCapture, true);\n\n          break;\n        }\n      }\n    }\n\n    signals.fire('interactable-unset', { interactable: this });\n\n    scope.interactables.splice(isType.indexOf(scope.interactables, this), 1);\n\n    return scope.interact;\n  }\n}\n\nInteractable.prototype.defaultActionChecker = actions.defaultChecker;\n\nmodule.exports = Interactable;\n","const scope          = require('./scope');\nconst utils          = require('./utils');\nconst InteractEvent  = require('./InteractEvent');\nconst events         = require('./utils/events');\nconst signals        = require('./utils/signals');\nconst browser        = require('./utils/browser');\nconst finder         = require('./utils/interactionFinder');\nconst actions        = require('./actions/base');\nconst modifiers      = require('./modifiers/base');\nconst animationFrame = utils.raf;\n\nconst listeners   = {};\nconst methodNames = [\n  'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n  'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n  'addPointer', 'removePointer', 'recordPointer',\n];\n\n// for ignoring browser's simulated mouse events\nlet prevTouchTime = 0;\n\n// all active and idle interactions\nscope.interactions = [];\n\nclass Interaction {\n  constructor () {\n    this.target        = null; // current interactable being interacted with\n    this.element       = null; // the target element of the interactable\n\n    this.matches       = [];   // all selectors that are matched by target element\n    this.matchElements = [];   // corresponding elements\n\n    this.prepared      = {     // action that's ready to be fired on next move event\n      name : null,\n      axis : null,\n      edges: null,\n    };\n\n    this.inertiaStatus = {\n      active   : false,\n      smoothEnd: false,\n      ending   : false,\n\n      startEvent: null,\n      upCoords  : {},\n\n      xe: 0, ye: 0,\n      sx: 0, sy: 0,\n\n      t0: 0,\n      vx0: 0, vys: 0,\n      duration: 0,\n\n      resumeDx: 0,\n      resumeDy: 0,\n\n      lambda_v0: 0,\n      one_ve_v0: 0,\n      i  : null,\n    };\n\n    this.boundInertiaFrame   = () => this.inertiaFrame  ();\n    this.boundSmoothEndFrame = () => this.smoothEndFrame();\n\n    // keep track of added pointers\n    this.pointers    = [];\n    this.pointerIds  = [];\n    this.downTargets = [];\n    this.downTimes   = [];\n    this.holdTimers  = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      timeStamp: 0,\n    };\n\n    this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget    = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null;      // previous action event\n\n    this.startOffset      = { left: 0, right: 0, top: 0, bottom: 0 };\n    this.modifierOffsets  = {};\n    this.modifierStatuses = modifiers.resetStatuses({});\n\n    this.pointerIsDown   = false;\n    this.pointerWasMoved = false;\n    this._interacting    = false;\n\n    this.mouse = false;\n\n    signals.fire('interaction-new', this);\n\n    scope.interactions.push(this);\n  }\n\n  setEventXY (targetObj, pointers) {\n    const pointer = (pointers.length > 1\n                     ? utils.pointerAverage(pointers)\n                     : pointers[0]);\n\n    const tmpXY = {};\n\n    utils.getPageXY(pointer, tmpXY, this);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    utils.getClientXY(pointer, tmpXY, this);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = new Date().getTime();\n  }\n\n  pointerOver (pointer, event, eventTarget) {\n    if (this.prepared.name || !this.mouse) { return; }\n\n    const curMatches = [];\n    const curMatchElements = [];\n    const prevTargetElement = this.element;\n\n    this.addPointer(pointer);\n\n    if (this.target\n        && (scope.testIgnore(this.target, this.element, eventTarget)\n        || !scope.testAllow(this.target, this.element, eventTarget))) {\n      // if the eventTarget should be ignored or shouldn't be allowed\n      // clear the previous target\n      this.target = null;\n      this.element = null;\n      this.matches = [];\n      this.matchElements = [];\n    }\n\n    const elementInteractable = scope.interactables.get(eventTarget);\n    let elementAction = (elementInteractable\n                         && !scope.testIgnore(elementInteractable, eventTarget, eventTarget)\n                         && scope.testAllow(elementInteractable, eventTarget, eventTarget)\n                         && validateAction(\n                           elementInteractable.getAction(pointer, event, this, eventTarget),\n                           elementInteractable));\n\n    if (elementAction && !scope.withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n      elementAction = null;\n    }\n\n    function pushCurMatches (interactable, selector) {\n      if (interactable\n          && scope.inContext(interactable, eventTarget)\n          && !scope.testIgnore(interactable, eventTarget, eventTarget)\n          && scope.testAllow(interactable, eventTarget, eventTarget)\n          && utils.matchesSelector(eventTarget, selector)) {\n\n        curMatches.push(interactable);\n        curMatchElements.push(eventTarget);\n      }\n    }\n\n    if (elementAction) {\n      this.target = elementInteractable;\n      this.element = eventTarget;\n      this.matches = [];\n      this.matchElements = [];\n    }\n    else {\n      scope.interactables.forEachSelector(pushCurMatches);\n\n      if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n        this.matches = curMatches;\n        this.matchElements = curMatchElements;\n\n        this.pointerHover(pointer, event, this.matches, this.matchElements);\n        events.add(eventTarget,\n                   scope.PointerEvent? browser.pEventTypes.move : 'mousemove',\n                   listeners.pointerHover);\n      }\n      else if (this.target) {\n        if (utils.nodeContains(prevTargetElement, eventTarget)) {\n          this.pointerHover(pointer, event, this.matches, this.matchElements);\n          events.add(this.element,\n                     scope.PointerEvent? browser.pEventTypes.move : 'mousemove',\n                     listeners.pointerHover);\n        }\n        else {\n          this.target = null;\n          this.element = null;\n          this.matches = [];\n          this.matchElements = [];\n        }\n      }\n    }\n  }\n\n  // Check what action would be performed on pointerMove target if a mouse\n  // button were pressed and change the cursor accordingly\n  pointerHover (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n    const target = this.target;\n\n    if (!this.prepared.name && this.mouse) {\n\n      let action;\n\n      // update pointer coords for defaultActionChecker to use\n      this.setEventXY(this.curCoords, [pointer]);\n\n      if (matches) {\n        action = this.validateSelector(pointer, event, matches, matchElements);\n      }\n      else if (target) {\n        action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n      }\n\n      if (target && target.options.styleCursor) {\n        if (action) {\n          target._doc.documentElement.style.cursor = actions[action.name].getCursor(action);\n        }\n        else {\n          target._doc.documentElement.style.cursor = '';\n        }\n      }\n    }\n    else if (this.prepared.name) {\n      this.checkAndPreventDefault(event, target, this.element);\n    }\n  }\n\n  pointerOut (pointer, event, eventTarget) {\n    if (this.prepared.name) { return; }\n\n    // Remove temporary event listeners for selector Interactables\n    if (!scope.interactables.get(eventTarget)) {\n      events.remove(eventTarget,\n                    scope.PointerEvent? browser.pEventTypes.move : 'mousemove',\n                    listeners.pointerHover);\n    }\n\n    if (this.target && this.target.options.styleCursor && !this.interacting()) {\n      this.target._doc.documentElement.style.cursor = '';\n    }\n  }\n\n  selectorDown (pointer, event, eventTarget, curEventTarget) {\n    const pointerIndex = this.addPointer(pointer);\n    let element = eventTarget;\n    let action;\n\n    this.pointerIsDown = true;\n\n    signals.fire('interaction-down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      interaction: this,\n    });\n\n    // Check if the down event hits the current inertia target\n    if (this.inertiaStatus.active && this.target.selector) {\n      // climb up the DOM tree from the event target\n      while (utils.isElement(element)) {\n\n        // if this element is the current inertia target element\n        if (element === this.element\n            // and the prospective action is the same as the ongoing one\n            && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\n          // stop inertia so that the next move will be a normal one\n          animationFrame.cancel(this.inertiaStatus.i);\n          this.inertiaStatus.active = false;\n\n          return;\n        }\n        element = utils.parentElement(element);\n      }\n    }\n\n    // do nothing if interacting\n    if (this.interacting()) {\n      return;\n    }\n\n    const pushMatches = (interactable, selector, context) => {\n      const elements = (browser.useMatchesSelectorPolyfill\n        ? context.querySelectorAll(selector)\n        : undefined);\n\n      if (scope.inContext(interactable, element)\n          && !scope.testIgnore(interactable, element, eventTarget)\n        && scope.testAllow(interactable, element, eventTarget)\n        && utils.matchesSelector(element, selector, elements)) {\n\n        this.matches.push(interactable);\n        this.matchElements.push(element);\n      }\n    };\n\n    // update pointer coords for defaultActionChecker to use\n    this.setEventXY(this.curCoords, [pointer]);\n    this.downEvent = event;\n\n    while (utils.isElement(element) && !action) {\n      this.matches = [];\n      this.matchElements = [];\n\n      scope.interactables.forEachSelector(pushMatches);\n\n      action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n      element = utils.parentElement(element);\n    }\n\n    if (action) {\n      this.prepared.name  = action.name;\n      this.prepared.axis  = action.axis;\n      this.prepared.edges = action.edges;\n\n      return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n    }\n    else {\n      // do these now since pointerDown isn't being called from here\n      this.downTimes[pointerIndex] = new Date().getTime();\n      this.downTargets[pointerIndex] = eventTarget;\n      utils.pointerExtend(this.downPointer, pointer);\n\n      utils.copyCoords(this.prevCoords, this.curCoords);\n      this.pointerWasMoved = false;\n    }\n  }\n\n  // Determine action to be performed on next pointerMove and add appropriate\n  // style and event Listeners\n  pointerDown (pointer, event, eventTarget, curEventTarget, forceAction) {\n    if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n      this.checkAndPreventDefault(event, this.target, this.element);\n\n      return;\n    }\n\n    this.pointerIsDown = true;\n    this.downEvent = event;\n\n    const pointerIndex = this.addPointer(pointer);\n    let action;\n\n    // If it is the second touch of a multi-touch gesture, keep the\n    // target the same and get a new action if a target was set by the\n    // first touch\n    if (this.pointerIds.length > 1 && this.target._element === this.element) {\n      const newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\n      if (scope.withinInteractionLimit(this.target, this.element, newAction)) {\n        action = newAction;\n      }\n\n      this.prepared.name = null;\n    }\n    // Otherwise, set the target if there is no action prepared\n    else if (!this.prepared.name) {\n      const interactable = scope.interactables.get(curEventTarget);\n\n      if (interactable\n          && !scope.testIgnore(interactable, curEventTarget, eventTarget)\n          && scope.testAllow(interactable, curEventTarget, eventTarget)\n          && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n          && scope.withinInteractionLimit(interactable, curEventTarget, action)) {\n        this.target = interactable;\n        this.element = curEventTarget;\n      }\n    }\n\n    const target = this.target;\n    const options = target && target.options;\n\n    if (target && (forceAction || !this.prepared.name)) {\n      action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\n      this.setEventXY(this.startCoords, this.pointers);\n\n      if (!action) { return; }\n\n      if (options.styleCursor) {\n        target._doc.documentElement.style.cursor = actions[action.name].getCursor(action);\n      }\n\n      this.resizeAxes = action.name === 'resize'? action.axis : null;\n\n      if (action === 'gesture' && this.pointerIds.length < 2) {\n        action = null;\n      }\n\n      this.prepared.name  = action.name;\n      this.prepared.axis  = action.axis;\n      this.prepared.edges = action.edges;\n\n      modifiers.resetStatuses(this.modifierStatuses);\n\n      this.downTimes[pointerIndex] = new Date().getTime();\n      this.downTargets[pointerIndex] = eventTarget;\n      utils.pointerExtend(this.downPointer, pointer);\n\n      utils.copyCoords(this.prevCoords, this.startCoords);\n      this.pointerWasMoved = false;\n\n      this.checkAndPreventDefault(event, target, this.element);\n    }\n    // if inertia is active try to resume action\n    else if (this.inertiaStatus.active\n             && curEventTarget === this.element\n             && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\n      animationFrame.cancel(this.inertiaStatus.i);\n      this.inertiaStatus.active = false;\n\n      this.checkAndPreventDefault(event, target, this.element);\n    }\n  }\n\n  setStartOffsets (action, interactable, element) {\n    const rect = interactable.getRect(element);\n\n    if (rect) {\n      this.startOffset.left = this.startCoords.page.x - rect.left;\n      this.startOffset.top  = this.startCoords.page.y - rect.top;\n\n      this.startOffset.right  = rect.right  - this.startCoords.page.x;\n      this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n      if (!('width'  in rect)) { rect.width  = rect.right  - rect.left; }\n      if (!('height' in rect)) { rect.height = rect.bottom - rect.top ; }\n    }\n    else {\n      this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n    }\n\n    modifiers.setOffsets(this, interactable, element, rect, this.modifierOffsets);\n  }\n\n  /*\\\n   * Interaction.start\n   [ method ]\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate number\n   * of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   - action       (object)  The action to be performed - drag, resize, etc.\n   - interactable (Interactable) The Interactable to target\n   - element      (Element) The DOM Element to target\n   = (object) interact\n   **\n   | interact(target)\n   |   .draggable({\n   |     // disable the default drag start by down->move\n   |     manualStart: true\n   |   })\n   |   // start dragging after the user holds the pointer down\n   |   .on('hold', function (event) {\n   |     var interaction = event.interaction;\n   |\n   |     if (!interaction.interacting()) {\n   |       interaction.start({ name: 'drag' },\n   |                         event.interactable,\n   |                         event.currentTarget);\n   |     }\n   | });\n   \\*/\n  start (action, interactable, element) {\n    if (this.interacting()\n        || !this.pointerIsDown\n        || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n      return;\n    }\n\n    // if this interaction had been removed after stopping\n    // add it back\n    if (utils.indexOf(scope.interactions, this) === -1) {\n      scope.interactions.push(this);\n    }\n\n    // set the startCoords if there was no prepared action\n    if (!this.prepared.name) {\n      this.setEventXY(this.startCoords, this.pointers);\n    }\n\n    this.prepared.name  = action.name;\n    this.prepared.axis  = action.axis;\n    this.prepared.edges = action.edges;\n    this.target         = interactable;\n    this.element        = element;\n\n    this.setStartOffsets(action.name, interactable, element, this.modifierOffsets);\n\n    modifiers.setAll(this, this.startCoords.page, this.modifierStatuses);\n\n    this.prevEvent = actions[this.prepared.name].start(this, this.downEvent);\n  }\n\n  pointerMove (pointer, event, eventTarget, curEventTarget, preEnd) {\n    if (this.inertiaStatus.active) {\n      const pageUp   = this.inertiaStatus.upCoords.page;\n      const clientUp = this.inertiaStatus.upCoords.client;\n\n      this.setEventXY(this.curCoords, [ {\n        pageX  : pageUp.x   + this.inertiaStatus.sx,\n        pageY  : pageUp.y   + this.inertiaStatus.sy,\n        clientX: clientUp.x + this.inertiaStatus.sx,\n        clientY: clientUp.y + this.inertiaStatus.sy,\n      } ]);\n    }\n    else {\n      this.recordPointer(pointer);\n      this.setEventXY(this.curCoords, this.pointers);\n    }\n\n    const duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n    && this.curCoords.page.y === this.prevCoords.page.y\n    && this.curCoords.client.x === this.prevCoords.client.x\n    && this.curCoords.client.y === this.prevCoords.client.y);\n\n    let dx;\n    let dy;\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.curCoords.client.x - this.startCoords.client.x;\n      dy = this.curCoords.client.y - this.startCoords.client.y;\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > scope.pointerMoveTolerance;\n    }\n\n    signals.fire('interaction-move', {\n      pointer,\n      event,\n      eventTarget,\n      dx,\n      dy,\n      interaction: this,\n      duplicate: duplicateMove,\n    });\n\n    if (!this.pointerIsDown) { return; }\n\n    if (duplicateMove && this.pointerWasMoved && !preEnd) {\n      this.checkAndPreventDefault(event, this.target, this.element);\n      return;\n    }\n\n    // set pointer coordinate, time changes and speeds\n    utils.setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n    if (!this.prepared.name) { return; }\n\n    if (this.pointerWasMoved\n        // ignore movement while inertia is active\n        && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\n      // if just starting an action, calculate the pointer speed now\n      if (!this.interacting()) {\n        utils.setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n        actions[this.prepared.name].beforeStart(this, pointer, event, eventTarget, curEventTarget, dx, dy);\n      }\n\n      const starting = !!this.prepared.name && !this.interacting();\n\n      if (starting\n          && (this.target.options[this.prepared.name].manualStart\n          || !scope.withinInteractionLimit(this.target, this.element, this.prepared))) {\n        this.stop(event);\n        return;\n      }\n\n      if (this.prepared.name && this.target) {\n        if (starting) {\n          this.start(this.prepared, this.target, this.element);\n        }\n\n        const modifierResult = modifiers.setAll(this, this.curCoords.page, this.modifierStatuses, preEnd);\n\n        // move if snapping or restriction doesn't prevent it\n        if (modifierResult.shouldMove || starting) {\n          this.prevEvent = actions[this.prepared.name].move(this, event);\n        }\n\n        this.checkAndPreventDefault(event, this.target, this.element);\n      }\n    }\n\n    utils.copyCoords(this.prevCoords, this.curCoords);\n\n    signals.fire('interaction-move-done', {\n      pointer,\n      event,\n      interaction: this,\n    });\n  }\n\n  pointerUp (pointer, event, eventTarget, curEventTarget) {\n    const pointerIndex = this.mouse? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    clearTimeout(this.holdTimers[pointerIndex]);\n\n    signals.fire('interaction-up', {\n      pointer,\n      event,\n      eventTarget,\n      curEventTarget,\n      interaction: this,\n    });\n\n\n    this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n    this.removePointer(pointer);\n  }\n\n  pointerCancel (pointer, event, eventTarget, curEventTarget) {\n    const pointerIndex = this.mouse? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    clearTimeout(this.holdTimers[pointerIndex]);\n\n    signals.fire('interaction-cancel', {\n      pointer,\n      event,\n      eventTarget,\n      interaction: this,\n    });\n\n    this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n    this.removePointer(pointer);\n  }\n\n  // End interact move events and stop auto-scroll unless inertia is enabled\n  pointerEnd (pointer, event, eventTarget, curEventTarget) {\n    const target = this.target;\n    const options = target && target.options;\n    const inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia;\n    const inertiaStatus = this.inertiaStatus;\n\n    if (this.interacting()) {\n\n      if (inertiaStatus.active && !inertiaStatus.ending) { return; }\n\n      const now = new Date().getTime();\n      const statuses = {};\n      const page = utils.extend({}, this.curCoords.page);\n      let pointerSpeed;\n      let inertiaPossible = false;\n      let inertia = false;\n      let smoothEnd = false;\n      let modifierResult;\n\n      if (this.dragging) {\n        if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n        else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n        else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n      }\n      else {\n        pointerSpeed = this.pointerDelta.client.speed;\n      }\n\n      // check if inertia should be started\n      inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n                         && this.prepared.name !== 'gesture'\n                         && event !== inertiaStatus.startEvent);\n\n      inertia = (inertiaPossible\n                && (now - this.curCoords.timeStamp) < 50\n                && pointerSpeed > inertiaOptions.minSpeed\n                && pointerSpeed > inertiaOptions.endSpeed);\n\n      // smoothEnd\n      if (inertiaPossible && !inertia) {\n        modifiers.resetStatuses(statuses);\n\n        modifierResult = modifiers.setAll(this, page, statuses, true);\n\n        if (modifierResult.shouldMove && modifierResult.locked) {\n          smoothEnd = true;\n        }\n      }\n\n      if (inertia || smoothEnd) {\n        utils.copyCoords(inertiaStatus.upCoords, this.curCoords);\n\n        this.pointers[0] = inertiaStatus.startEvent =\n          new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\n        inertiaStatus.t0 = now;\n\n        target.fire(inertiaStatus.startEvent);\n\n        if (inertia) {\n          inertiaStatus.vx0 = this.pointerDelta.client.vx;\n          inertiaStatus.vy0 = this.pointerDelta.client.vy;\n          inertiaStatus.v0 = pointerSpeed;\n\n          this.calcInertia(inertiaStatus);\n\n          utils.extend(page, this.curCoords.page);\n\n          page.x += inertiaStatus.xe;\n          page.y += inertiaStatus.ye;\n\n          modifiers.resetStatuses(statuses);\n\n          modifierResult = modifiers.setAll(this, page, statuses, true, true);\n\n          inertiaStatus.modifiedXe += modifierResult.dx;\n          inertiaStatus.modifiedYe += modifierResult.dy;\n\n          inertiaStatus.i = animationFrame.request(this.boundInertiaFrame);\n        }\n        else {\n          inertiaStatus.smoothEnd = true;\n          inertiaStatus.xe = modifierResult.dx;\n          inertiaStatus.ye = modifierResult.dy;\n\n          inertiaStatus.sx = inertiaStatus.sy = 0;\n\n          inertiaStatus.i = animationFrame.request(this.boundSmoothEndFrame);\n        }\n\n        inertiaStatus.active = true;\n        return;\n      }\n\n      for (let i = 0; i < modifiers.names.length; i++) {\n        // if the endOnly option is true for any modifier\n        if (modifiers[modifiers.names[i]].shouldDo(target, this.prepared.name, true, true)) {\n          // fire a move event at the snapped coordinates\n          this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n          break;\n        }\n      }\n    }\n\n    if (this.interacting()) {\n      actions[this.prepared.name].end(this, event);\n    }\n\n    this.stop(event);\n  }\n\n  currentAction () {\n    return this._interacting? this.prepared.name: null;\n  }\n\n  interacting () {\n    return this._interacting;\n  }\n\n  stop (event) {\n    signals.fire('interaction-stop', { interaction: this });\n\n    if (this._interacting) {\n      signals.fire('interaction-stop-active', { interaction: this });\n\n      this.matches = [];\n      this.matchElements = [];\n\n      const target = this.target;\n\n      if (target.options.styleCursor) {\n        target._doc.documentElement.style.cursor = '';\n      }\n\n      // prevent Default only if were previously interacting\n      if (event && utils.isFunction(event.preventDefault)) {\n        this.checkAndPreventDefault(event, target, this.element);\n      }\n\n      actions[this.prepared.name].stop(this, event);\n    }\n\n    this.target = this.element = null;\n\n    this.pointerIsDown = this._interacting = false;\n    this.prepared.name = this.prevEvent = null;\n    this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\n    modifiers.resetStatuses(this.modifierStatuses);\n\n    // remove pointers if their ID isn't in this.pointerIds\n    for (let i = 0; i < this.pointers.length; i++) {\n      if (utils.indexOf(this.pointerIds, utils.getPointerId(this.pointers[i])) === -1) {\n        this.pointers.splice(i, 1);\n      }\n    }\n  }\n\n  inertiaFrame () {\n    const inertiaStatus = this.inertiaStatus;\n    const options = this.target.options[this.prepared.name].inertia;\n    const lambda = options.resistance;\n    const t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n    if (t < inertiaStatus.te) {\n\n      const progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\n      if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n        inertiaStatus.sx = inertiaStatus.xe * progress;\n        inertiaStatus.sy = inertiaStatus.ye * progress;\n      }\n      else {\n        const quadPoint = utils.getQuadraticCurvePoint(0, 0,\n                                                       inertiaStatus.xe,\n                                                       inertiaStatus.ye,\n                                                       inertiaStatus.modifiedXe,\n                                                       inertiaStatus.modifiedYe,\n                                                       progress);\n\n        inertiaStatus.sx = quadPoint.x;\n        inertiaStatus.sy = quadPoint.y;\n      }\n\n      this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n      inertiaStatus.i = animationFrame.request(this.boundInertiaFrame);\n    }\n    else {\n      inertiaStatus.ending = true;\n\n      inertiaStatus.sx = inertiaStatus.modifiedXe;\n      inertiaStatus.sy = inertiaStatus.modifiedYe;\n\n      this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n      this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n      inertiaStatus.active = inertiaStatus.ending = false;\n    }\n  }\n\n  smoothEndFrame () {\n    const inertiaStatus = this.inertiaStatus;\n    const t = new Date().getTime() - inertiaStatus.t0;\n    const duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n    if (t < duration) {\n      inertiaStatus.sx = utils.easeOutQuad(t, 0, inertiaStatus.xe, duration);\n      inertiaStatus.sy = utils.easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\n      this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n      inertiaStatus.i = animationFrame.request(this.boundSmoothEndFrame);\n    }\n    else {\n      inertiaStatus.ending = true;\n\n      inertiaStatus.sx = inertiaStatus.xe;\n      inertiaStatus.sy = inertiaStatus.ye;\n\n      this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n      this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n      inertiaStatus.smoothEnd =\n        inertiaStatus.active = inertiaStatus.ending = false;\n    }\n  }\n\n  addPointer (pointer) {\n    const id = utils.getPointerId(pointer);\n    let index = this.mouse? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) {\n      index = this.pointerIds.length;\n    }\n\n    this.pointerIds[index] = id;\n    this.pointers[index] = pointer;\n\n    return index;\n  }\n\n  removePointer (pointer) {\n    const id = utils.getPointerId(pointer);\n    const index = this.mouse? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) { return; }\n\n    this.pointers   .splice(index, 1);\n    this.pointerIds .splice(index, 1);\n    this.downTargets.splice(index, 1);\n    this.downTimes  .splice(index, 1);\n    this.holdTimers .splice(index, 1);\n  }\n\n  recordPointer (pointer) {\n    const index = this.mouse? 0: utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    if (index === -1) { return; }\n\n    this.pointers[index] = pointer;\n  }\n\n  validateSelector (pointer, event, matches, matchElements) {\n    for (let i = 0, len = matches.length; i < len; i++) {\n      const match = matches[i];\n      const matchElement = matchElements[i];\n      const action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\n      if (action && scope.withinInteractionLimit(match, matchElement, action)) {\n        this.target = match;\n        this.element = matchElement;\n\n        return action;\n      }\n    }\n  }\n\n  checkAndPreventDefault (event, interactable, element) {\n    if (!(interactable = interactable || this.target)) { return; }\n\n    const options = interactable.options;\n    const prevent = options.preventDefault;\n\n    if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n      // do not preventDefault on pointerdown if the prepared action is a drag\n      // and dragging can only start from a certain direction - this allows\n      // a touch to pan the viewport if a drag isn't in the right direction\n      if (/down|start/i.test(event.type)\n          && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\n        return;\n      }\n\n      // with manualStart, only preventDefault while interacting\n      if (options[this.prepared.name] && options[this.prepared.name].manualStart\n          && !this.interacting()) {\n        return;\n      }\n\n      event.preventDefault();\n      return;\n    }\n\n    if (prevent === 'always') {\n      event.preventDefault();\n      return;\n    }\n  }\n\n  calcInertia (status) {\n    const inertiaOptions = this.target.options[this.prepared.name].inertia;\n    const lambda = inertiaOptions.resistance;\n    const inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n    status.x0 = this.prevEvent.pageX;\n    status.y0 = this.prevEvent.pageY;\n    status.t0 = status.startEvent.timeStamp / 1000;\n    status.sx = status.sy = 0;\n\n    status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n    status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n    status.te = inertiaDur;\n\n    status.lambda_v0 = lambda / status.v0;\n    status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n  }\n\n  _updateEventTargets (target, currentTarget) {\n    this._eventTarget    = target;\n    this._curEventTarget = currentTarget;\n  }\n}\n\n// Check if the current target supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction (action, interactable) {\n  if (utils.isObject(action) && interactable.options[action.name].enabled) {\n    return action;\n  }\n\n  return null;\n}\n\nfor (let i = 0, len = methodNames.length; i < len; i++) {\n  const method = methodNames[i];\n\n  listeners[method] = doOnInteractions(method);\n}\n\nfunction doOnInteractions (method) {\n  return (function (event) {\n    const eventTarget = utils.getActualElement(event.path ? event.path[0] : event.target);\n    const curEventTarget = utils.getActualElement(event.currentTarget);\n    const matches = []; // [ [pointer, interaction], ...]\n\n    if (browser.supportsTouch && /touch/.test(event.type)) {\n      prevTouchTime = new Date().getTime();\n\n      for (const pointer of event.changedTouches) {\n        const interaction = finder.search(pointer, event.type, eventTarget);\n\n        matches.push([pointer, interaction || new Interaction]);\n      }\n    }\n    else {\n      let invalidPointer = false;\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n          invalidPointer = !scope.interactions[i].mouse && scope.interactions[i].pointerIsDown;\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer || (new Date().getTime() - prevTouchTime < 500);\n      }\n\n      if (!invalidPointer) {\n        let interaction = finder.search(event, event.type, eventTarget);\n\n        if (!interaction) {\n\n          interaction = new Interaction();\n          interaction.mouse = (/mouse/i.test(event.pointerType || event.type)\n                               // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                               || event.pointerType === 4);\n        }\n\n        matches.push([event, interaction]);\n      }\n    }\n\n    for (const [pointer, interaction] of matches) {\n      interaction._updateEventTargets(eventTarget, curEventTarget);\n      interaction[method](pointer, event, eventTarget, curEventTarget);\n    }\n  });\n}\n\nsignals.on('interactable-new', function ({ interactable, win }) {\n  const element = interactable._element;\n\n  if (utils.isElement(element, win)) {\n    if (scope.PointerEvent) {\n      events.add(element, browser.pEventTypes.down, listeners.pointerDown );\n      events.add(element, browser.pEventTypes.move, listeners.pointerHover);\n    }\n    else {\n      events.add(element, 'mousedown' , listeners.pointerDown );\n      events.add(element, 'mousemove' , listeners.pointerHover);\n      events.add(element, 'touchstart', listeners.pointerDown );\n      events.add(element, 'touchmove' , listeners.pointerHover);\n    }\n  }\n});\n\nsignals.on('interactable-unset', function ({ interactable, win }) {\n  const element = interactable._element;\n\n  if (!interactable.selector && utils.isElement(element, win)) {\n    if (scope.PointerEvent) {\n      events.remove(element, browser.pEventTypes.down, listeners.pointerDown );\n      events.remove(element, browser.pEventTypes.move, listeners.pointerHover);\n    }\n    else {\n      events.remove(element, 'mousedown' , listeners.pointerDown );\n      events.remove(element, 'mousemove' , listeners.pointerHover);\n      events.remove(element, 'touchstart', listeners.pointerDown );\n      events.remove(element, 'touchmove' , listeners.pointerHover);\n    }\n  }\n});\n\nsignals.on('listen-to-document', function ({ doc, win }) {\n  const pEventTypes = browser.pEventTypes;\n\n  // add delegate event listener\n  for (const eventType in scope.delegatedEvents) {\n    events.add(doc, eventType, events.delegateListener);\n    events.add(doc, eventType, events.delegateUseCapture, true);\n  }\n\n  if (scope.PointerEvent) {\n    events.add(doc, pEventTypes.down  , listeners.selectorDown );\n    events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n    events.add(doc, pEventTypes.over  , listeners.pointerOver  );\n    events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n    events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n    events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n  }\n  else {\n    events.add(doc, 'mousedown', listeners.selectorDown);\n    events.add(doc, 'mousemove', listeners.pointerMove );\n    events.add(doc, 'mouseup'  , listeners.pointerUp   );\n    events.add(doc, 'mouseover', listeners.pointerOver );\n    events.add(doc, 'mouseout' , listeners.pointerOut  );\n\n    events.add(doc, 'touchstart' , listeners.selectorDown );\n    events.add(doc, 'touchmove'  , listeners.pointerMove  );\n    events.add(doc, 'touchend'   , listeners.pointerUp    );\n    events.add(doc, 'touchcancel', listeners.pointerCancel);\n  }\n\n  events.add(win, 'blur', scope.endAllInteractions);\n\n  try {\n    if (win.frameElement) {\n      const parentDoc = win.frameElement.ownerDocument;\n      const parentWindow = parentDoc.defaultView;\n\n      events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);\n      events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);\n      events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);\n      events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);\n      events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);\n      events.add(parentWindow, 'blur'         , scope.endAllInteractions );\n    }\n  }\n  catch (error) {\n    scope.windowParentError = error;\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  events.add(doc, 'dragstart', function (event) {\n    for (const interaction of scope.interactions) {\n\n      if (interaction.element\n          && (interaction.element === event.target\n              || utils.nodeContains(interaction.element, event.target))) {\n\n        interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n        return;\n      }\n    }\n  });\n\n  scope.documents.push(doc);\n  events.documents.push(doc);\n});\n\nsignals.fire('listen-to-document', {\n  win: scope.window,\n  doc: scope.document,\n});\n\nInteraction.doOnInteractions = doOnInteractions;\nInteraction.withinLimit = scope.withinInteractionLimit;\n\nmodule.exports = Interaction;\n","const actions = {\n  defaultChecker: function (pointer, event, interaction, element) {\n    const rect = this.getRect(element);\n    let action = null;\n\n    for (const actionName of actions.names) {\n      action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n      if (action) {\n        return action;\n      }\n    }\n  },\n\n  names: [],\n  methodDict: {},\n};\n\nmodule.exports = actions;\n","const base = require('./base');\nconst drop = require('./drop');\nconst scope = require('../scope');\nconst utils = require('../utils');\nconst browser = require('../utils/browser');\nconst InteractEvent = require('../InteractEvent');\nconst Interactable = require('../Interactable');\nconst defaultOptions = require('../defaultOptions');\n\nconst drag = {\n  defaults: {\n    enabled      : false,\n    manualStart  : true,\n    max          : Infinity,\n    maxPerElement: 1,\n\n    snap      : null,\n    restrict  : null,\n    inertia   : null,\n    autoScroll: null,\n\n    axis: 'xy',\n  },\n\n  checker: function (pointer, event, interactable) {\n    return interactable.options.drag.enabled\n      ? { name: 'drag' }\n      : null;\n  },\n\n  getCursor: function () {\n    return 'move';\n  },\n\n  beforeStart: function (interaction, pointer, event, eventTarget, curEventTarget, dx, dy) {\n    // check if a drag is in the correct axis\n    const absX = Math.abs(dx);\n    const absY = Math.abs(dy);\n    const targetAxis = interaction.target.options.drag.axis;\n    const axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n    // if the movement isn't in the axis of the interactable\n    if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n      // cancel the prepared action\n      interaction.prepared.name = null;\n\n      // then try to get a drag from another ineractable\n\n      let element = eventTarget;\n\n      // check element interactables\n      while (utils.isElement(element)) {\n        const elementInteractable = scope.interactables.get(element);\n\n        if (elementInteractable\n            && elementInteractable !== interaction.target\n            && !elementInteractable.options.drag.manualStart\n            && elementInteractable.getAction(interaction.downPointer, interaction.downEvent, interaction, element).name === 'drag'\n            && checkAxis(axis, elementInteractable)) {\n\n          interaction.prepared.name = 'drag';\n          interaction.target = elementInteractable;\n          interaction.element = element;\n          break;\n        }\n\n        element = utils.parentElement(element);\n      }\n\n      // if there's no drag from element interactables,\n      // check the selector interactables\n      if (!interaction.prepared.name) {\n\n        const getDraggable = function (interactable, selector, context) {\n          const elements = browser.useMatchesSelectorPolyfill\n              ? context.querySelectorAll(selector)\n              : undefined;\n\n          if (interactable === interaction.target) { return; }\n\n          if (scope.inContext(interactable, eventTarget)\n              && !interactable.options.drag.manualStart\n              && !scope.testIgnore(interactable, element, eventTarget)\n              && scope.testAllow(interactable, element, eventTarget)\n              && utils.matchesSelector(element, selector, elements)\n              && interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element).name === 'drag'\n              && checkAxis(axis, interactable)\n              && scope.withinInteractionLimit(interactable, element, 'drag')) {\n\n            return interactable;\n          }\n        };\n\n        element = eventTarget;\n\n        while (utils.isElement(element)) {\n          const selectorInteractable = scope.interactables.forEachSelector(getDraggable);\n\n          if (selectorInteractable) {\n            interaction.prepared.name = 'drag';\n            interaction.target = selectorInteractable;\n            interaction.element = element;\n            break;\n          }\n\n          element = utils.parentElement(element);\n        }\n      }\n    }\n  },\n\n  start: function (interaction, event) {\n    const dragEvent = new InteractEvent(interaction, event, 'drag', 'start', interaction.element);\n\n    interaction._interacting = true;\n    interaction.target.fire(dragEvent);\n\n    drop.start(interaction, event, dragEvent);\n\n    return dragEvent;\n  },\n\n  move: function (interaction, event) {\n    const dragEvent  = new InteractEvent(interaction, event, 'drag', 'move', interaction.element);\n\n    drop.move(interaction, event, dragEvent);\n\n    return dragEvent;\n  },\n\n  end: function (interaction, event) {\n    const endEvent = new InteractEvent(interaction, event, 'drag', 'end', interaction.element);\n\n    drop.end(interaction, event, endEvent);\n\n    interaction.target.fire(endEvent);\n  },\n\n  stop: drop.stop,\n};\n\nfunction checkAxis (axis, interactable) {\n  if (!interactable) { return false; }\n\n  const thisAxis = interactable.options.drag.axis;\n\n  return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n}\n\n/*\\\n * Interactable.draggable\n [ method ]\n *\n * Gets or sets whether drag actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of drag events\n | var isDraggable = interact('ul li').draggable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n = (object) This Interactable\n | interact(element).draggable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // the axis in which the first movement must be\n |     // for the drag sequence to start\n |     // 'xy' by default - any direction\n |     axis: 'x' || 'y' || 'xy',\n |\n |     // max number of drags that can happen concurrently\n |     // with elements of this Interactable. Infinity by default\n |     max: Infinity,\n |\n |     // max number of drags that can target the same element+Interactable\n |     // 1 by default\n |     maxPerElement: 2\n | });\n\\*/\nInteractable.prototype.draggable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drag.enabled = options.enabled === false? false: true;\n    this.setPerAction('drag', options);\n    this.setOnEvents('drag', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.drag.axis = options.axis;\n    }\n    else if (options.axis === null) {\n      delete this.options.drag.axis;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drag.enabled = options;\n\n    return this;\n  }\n\n  return this.options.drag;\n};\n\nbase.drag = drag;\nbase.names.push('drag');\nutils.merge(scope.eventTypes, [\n  'dragstart',\n  'dragmove',\n  'draginertiastart',\n  'dragend',\n]);\nbase.methodDict.drag = 'draggable';\n\ndefaultOptions.drag = drag.defaults;\n\nmodule.exports = drag;\n","const base = require('./base');\nconst utils = require('../utils');\nconst scope = require('../scope');\nconst signals = require('../utils/signals');\nconst Interactable = require('../Interactable');\nconst defaultOptions = require('../defaultOptions');\n\nconst drop = {\n  defaults: {\n    enabled: false,\n    accept : null,\n    overlap: 'pointer',\n  },\n\n  start: function (interaction, event, dragEvent) {\n    // reset active dropzones\n    interaction.activeDrops.dropzones = [];\n    interaction.activeDrops.elements  = [];\n    interaction.activeDrops.rects     = [];\n\n    if (!interaction.dynamicDrop) {\n      setActiveDrops(interaction, interaction.element);\n    }\n\n    const dropEvents = getDropEvents(interaction, event, dragEvent);\n\n    if (dropEvents.activate) {\n      fireActiveDrops(interaction, dropEvents.activate);\n    }\n  },\n\n  move: function (interaction, event, dragEvent) {\n    const draggableElement = interaction.element;\n    const dropOptions = getDrop(dragEvent, event, draggableElement);\n\n    interaction.dropTarget  = dropOptions.dropzone;\n    interaction.dropElement = dropOptions.element;\n\n    const dropEvents = getDropEvents(interaction, event, dragEvent);\n\n    interaction.target.fire(dragEvent);\n\n    if (dropEvents.leave) { interaction.prevDropTarget.fire(dropEvents.leave); }\n    if (dropEvents.enter) {     interaction.dropTarget.fire(dropEvents.enter); }\n    if (dropEvents.move ) {     interaction.dropTarget.fire(dropEvents.move ); }\n\n    interaction.prevDropTarget  = interaction.dropTarget;\n    interaction.prevDropElement = interaction.dropElement;\n  },\n\n  end: function (interaction, event, endEvent) {\n    const draggableElement = interaction.element;\n    const dropResult = getDrop(endEvent, event, draggableElement);\n\n    interaction.dropTarget  = dropResult.dropzone;\n    interaction.dropElement = dropResult.element;\n\n    const dropEvents = getDropEvents(interaction, event, endEvent);\n\n    if (dropEvents.leave) { interaction.prevDropTarget.fire(dropEvents.leave); }\n    if (dropEvents.enter) {     interaction.dropTarget.fire(dropEvents.enter); }\n    if (dropEvents.drop ) {     interaction.dropTarget.fire(dropEvents.drop ); }\n    if (dropEvents.deactivate) {\n      fireActiveDrops(interaction, dropEvents.deactivate);\n    }\n  },\n\n  stop: function (interaction) {\n    interaction.activeDrops.dropzones =\n      interaction.activeDrops.elements =\n      interaction.activeDrops.rects = null;\n  },\n};\n\nfunction collectDrops (interaction, element) {\n  const drops = [];\n  const elements = [];\n\n  element = element || interaction.element;\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const current of scope.interactables) {\n    if (!current.options.drop.enabled) { continue; }\n\n    const accept = current.options.drop.accept;\n\n    // test the draggable element against the dropzone's accept setting\n    if ((utils.isElement(accept) && accept !== element)\n        || (utils.isString(accept)\n        && !utils.matchesSelector(element, accept))) {\n\n      continue;\n    }\n\n    // query for new elements if necessary\n    const dropElements = current.selector\n      ? current._context.querySelectorAll(current.selector)\n      : [current._element];\n\n    for (let i = 0; i < dropElements.length; i++) {\n      const currentElement = dropElements[i];\n\n      if (currentElement !== element) {\n        drops.push(current);\n        elements.push(currentElement);\n      }\n    }\n  }\n\n  return {\n    elements,\n    dropzones: drops,\n  };\n}\n\nfunction fireActiveDrops (interaction, event) {\n  let prevElement;\n\n  // loop through all active dropzones and trigger event\n  for (let i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    const current = interaction.activeDrops.dropzones[i];\n    const currentElement = interaction.activeDrops.elements [i];\n\n    // prevent trigger of duplicate events on same element\n    if (currentElement !== prevElement) {\n      // set current element as event target\n      event.target = currentElement;\n      current.fire(event);\n    }\n    prevElement = currentElement;\n  }\n}\n\n// Collect a new set of possible drops and save them in activeDrops.\n// setActiveDrops should always be called when a drag has just started or a\n// drag event happens while dynamicDrop is true\nfunction setActiveDrops (interaction, dragElement) {\n  // get dropzones and their elements that could receive the draggable\n  const possibleDrops = collectDrops(interaction, dragElement, true);\n\n  interaction.activeDrops.dropzones = possibleDrops.dropzones;\n  interaction.activeDrops.elements  = possibleDrops.elements;\n  interaction.activeDrops.rects     = [];\n\n  for (let i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    interaction.activeDrops.rects[i] =\n      interaction.activeDrops.dropzones[i].getRect(interaction.activeDrops.elements[i]);\n  }\n}\n\nfunction getDrop (dragEvent, event, dragElement) {\n  const interaction = dragEvent.interaction;\n  const validDrops = [];\n\n  if (scope.dynamicDrop) {\n    setActiveDrops(interaction, dragElement);\n  }\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (let j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n    const current        = interaction.activeDrops.dropzones[j];\n    const currentElement = interaction.activeDrops.elements [j];\n    const rect           = interaction.activeDrops.rects    [j];\n\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect)\n      ? currentElement\n      : null);\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = utils.indexOfDeepestElement(validDrops);\n\n  return {\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n    element : interaction.activeDrops.elements [dropIndex] || null,\n  };\n}\n\nfunction getDropEvents (interaction, pointerEvent, dragEvent) {\n  const dropEvents = {\n    enter     : null,\n    leave     : null,\n    activate  : null,\n    deactivate: null,\n    move      : null,\n    drop      : null,\n  };\n\n  if (interaction.dropElement !== interaction.prevDropElement) {\n    // if there was a prevDropTarget, create a dragleave event\n    if (interaction.prevDropTarget) {\n      dropEvents.leave = {\n        dragEvent,\n        interaction,\n        target       : interaction.prevDropElement,\n        dropzone     : interaction.prevDropTarget,\n        relatedTarget: dragEvent.target,\n        draggable    : dragEvent.interactable,\n        timeStamp    : dragEvent.timeStamp,\n        type         : 'dragleave',\n      };\n\n      dragEvent.dragLeave    = interaction.prevDropElement;\n      dragEvent.prevDropzone = interaction.prevDropTarget;\n    }\n    // if the dropTarget is not null, create a dragenter event\n    if (interaction.dropTarget) {\n      dropEvents.enter = {\n        dragEvent,\n        interaction,\n        target       : interaction.dropElement,\n        dropzone     : interaction.dropTarget,\n        relatedTarget: dragEvent.target,\n        draggable    : dragEvent.interactable,\n        timeStamp    : dragEvent.timeStamp,\n        type         : 'dragenter',\n      };\n\n      dragEvent.dragEnter = interaction.dropElement;\n      dragEvent.dropzone = interaction.dropTarget;\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n    dropEvents.drop = {\n      dragEvent,\n      interaction,\n      target       : interaction.dropElement,\n      dropzone     : interaction.dropTarget,\n      relatedTarget: dragEvent.target,\n      draggable    : dragEvent.interactable,\n      timeStamp    : dragEvent.timeStamp,\n      type         : 'drop',\n    };\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = {\n      dragEvent,\n      interaction,\n      target       : null,\n      dropzone     : null,\n      relatedTarget: dragEvent.target,\n      draggable    : dragEvent.interactable,\n      timeStamp    : dragEvent.timeStamp,\n      type         : 'dropactivate',\n    };\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = {\n      dragEvent,\n      interaction,\n      target       : null,\n      dropzone     : null,\n      relatedTarget: dragEvent.target,\n      draggable    : dragEvent.interactable,\n      timeStamp    : dragEvent.timeStamp,\n      type         : 'dropdeactivate',\n    };\n  }\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n    dropEvents.move = {\n      dragEvent,\n      interaction,\n      target       : interaction.dropElement,\n      dropzone     : interaction.dropTarget,\n      relatedTarget: dragEvent.target,\n      draggable    : dragEvent.interactable,\n      dragmove     : dragEvent,\n      timeStamp    : dragEvent.timeStamp,\n      type         : 'dropmove',\n    };\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n\n  return dropEvents;\n}\n\n/*\\\n * Interactable.dropzone\n [ method ]\n *\n * Returns or sets whether elements can be dropped onto this\n * Interactable to trigger drop events\n *\n * Dropzones can receive the following events:\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n *  - `dragmove` when a draggable that has entered the dropzone is moved\n *  - `drop` when a draggable is dropped into this dropzone\n *\n * Use the `accept` option to allow only elements that match the given CSS\n * selector or element. The value can be:\n *\n *  - **an Element** - only that element can be dropped into this dropzone.\n *  - **a string**, - the element being dragged must match it as a CSS selector.\n *  - **`null`** - accept options is cleared - it accepts any element.\n *\n * Use the `overlap` option to set how drops are checked for. The allowed\n * values are:\n *\n *   - `'pointer'`, the pointer must be over the dropzone (default)\n *   - `'center'`, the draggable element's center must be over the dropzone\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n *   over the dropzone\n *\n * Use the `checker` option to specify a function to check if a dragged\n * element is over this Interactable.\n *\n | interact(target)\n | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n |                       event,             // TouchEvent/PointerEvent/MouseEvent\n |                       dropped,           // bool result of the default checker\n |                       dropzone,          // dropzone Interactable\n |                       dropElement,       // dropzone elemnt\n |                       draggable,         // draggable Interactable\n |                       draggableElement) {// draggable element\n |\n |   return dropped && event.target.hasAttribute('allow-drop');\n | }\n *\n *\n - options (boolean | object | null) #optional The new value to be set.\n | interact('.drop').dropzone({\n |   accept: '.can-drop' || document.getElementById('single-drop'),\n |   overlap: 'pointer' || 'center' || zeroToOne\n | }\n = (boolean | object) The current setting or this Interactable\n\\*/\nInteractable.prototype.dropzone = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drop.enabled = options.enabled === false? false: true;\n\n    if (utils.isFunction(options.ondrop)          ) { this.ondrop           = options.ondrop          ; }\n    if (utils.isFunction(options.ondropactivate)  ) { this.ondropactivate   = options.ondropactivate  ; }\n    if (utils.isFunction(options.ondropdeactivate)) { this.ondropdeactivate = options.ondropdeactivate; }\n    if (utils.isFunction(options.ondragenter)     ) { this.ondragenter      = options.ondragenter     ; }\n    if (utils.isFunction(options.ondragleave)     ) { this.ondragleave      = options.ondragleave     ; }\n    if (utils.isFunction(options.ondropmove)      ) { this.ondropmove       = options.ondropmove      ; }\n\n    if (/^(pointer|center)$/.test(options.overlap)) {\n      this.options.drop.overlap = options.overlap;\n    }\n    else if (utils.isNumber(options.overlap)) {\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n    }\n    if ('accept' in options) {\n      this.options.drop.accept = options.accept;\n    }\n    if ('checker' in options) {\n      this.options.drop.checker = options.checker;\n    }\n\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drop.enabled = options;\n\n    return this;\n  }\n\n  return this.options.drop;\n};\n\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n  let dropped = false;\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || this.getRect(dropElement))) {\n    return (this.options.drop.checker\n      ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n      : false);\n  }\n\n  const dropOverlap = this.options.drop.overlap;\n\n  if (dropOverlap === 'pointer') {\n    const origin = utils.getOriginXY(draggable, draggableElement);\n    const page = utils.getPageXY(dragEvent);\n    let horizontal;\n    let vertical;\n\n    page.x += origin.x;\n    page.y += origin.y;\n\n    horizontal = (page.x > rect.left) && (page.x < rect.right);\n    vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n    dropped = horizontal && vertical;\n  }\n\n  const dragRect = draggable.getRect(draggableElement);\n\n  if (dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width  / 2;\n    const cy = dragRect.top  + dragRect.height / 2;\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n  }\n\n  if (utils.isNumber(dropOverlap)) {\n    const overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                          * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top )));\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n    dropped = overlapRatio >= dropOverlap;\n  }\n\n  if (this.options.drop.checker) {\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n  }\n\n  return dropped;\n};\n\nsignals.on('interactable-unset', function ({ interactable }) {\n  interactable.dropzone(false);\n});\n\nsignals.on('interaction-new', function (interaction) {\n  interaction.dropTarget      = null; // the dropzone a drag target might be dropped into\n  interaction.dropElement     = null; // the element at the time of checking\n  interaction.prevDropTarget  = null; // the dropzone that was recently dragged away from\n  interaction.prevDropElement = null; // the element at the time of checking\n\n  interaction.activeDrops = {\n    dropzones: [],      // the dropzones that are mentioned below\n    elements : [],      // elements of dropzones that accept the target draggable\n    rects    : [],      // the rects of the elements mentioned above\n  };\n\n});\n\nsignals.on('interaction-stop', function ({ interaction }) {\n  interaction.dropTarget = interaction.dropElement =\n    interaction.prevDropTarget = interaction.prevDropElement = null;\n});\n\nutils.merge(scope.eventTypes, [\n  'dragenter',\n  'dragleave',\n  'dropactivate',\n  'dropdeactivate',\n  'dropmove',\n  'drop',\n]);\nbase.methodDict.drop = 'dropzone';\n\ndefaultOptions.drop = drop.defaults;\n\nmodule.exports = drop;\n","const base = require('./base');\nconst utils = require('../utils');\nconst InteractEvent = require('../InteractEvent');\nconst Interactable = require('../Interactable');\nconst scope = require('../scope');\nconst signals = require('../utils/signals');\nconst defaultOptions = require('../defaultOptions');\n\nconst gesture = {\n  defaults: {\n    manualStart  : false,\n    enabled      : false,\n    max          : Infinity,\n    maxPerElement: 1,\n\n    restrict: null,\n  },\n\n  checker: function (pointer, event, interactable, element, interaction) {\n    if (interaction.pointerIds.length >= 2) {\n      return { name: 'gesture' };\n    }\n\n    return null;\n  },\n\n  getCursor: function () {\n    return '';\n  },\n\n  beforeStart: utils.blank,\n\n  start: function (interaction, event) {\n    const gestureEvent = new InteractEvent(interaction, event, 'gesture', 'start', interaction.element);\n\n    gestureEvent.ds = 0;\n\n    interaction.gesture.startDistance = interaction.gesture.prevDistance = gestureEvent.distance;\n    interaction.gesture.startAngle = interaction.gesture.prevAngle = gestureEvent.angle;\n    interaction.gesture.scale = 1;\n\n    interaction._interacting = true;\n\n    interaction.target.fire(gestureEvent);\n\n    return gestureEvent;\n  },\n\n  move: function (interaction, event) {\n    if (!interaction.pointerIds.length) {\n      return interaction.prevEvent;\n    }\n\n    let gestureEvent;\n\n    gestureEvent = new InteractEvent(interaction, event, 'gesture', 'move', interaction.element);\n    gestureEvent.ds = gestureEvent.scale - interaction.gesture.scale;\n\n    interaction.target.fire(gestureEvent);\n\n    interaction.gesture.prevAngle = gestureEvent.angle;\n    interaction.gesture.prevDistance = gestureEvent.distance;\n\n    if (gestureEvent.scale !== Infinity\n        && gestureEvent.scale !== null\n        && gestureEvent.scale !== undefined\n        && !isNaN(gestureEvent.scale)) {\n\n      interaction.gesture.scale = gestureEvent.scale;\n    }\n\n    return gestureEvent;\n  },\n\n  end: function (interaction, event) {\n    const endEvent = new InteractEvent(interaction, event, 'gesture', 'end', interaction.element);\n\n    interaction.target.fire(endEvent);\n  },\n\n  stop: utils.blank,\n};\n\n/*\\\n * Interactable.gesturable\n [ method ]\n *\n * Gets or sets whether multitouch gestures can be performed on the\n * Interactable's element\n *\n = (boolean) Indicates if this can be the target of gesture events\n   | var isGestureable = interact(element).gesturable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n = (object) this Interactable\n | interact(element).gesturable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // limit multiple gestures.\n |     // See the explanation in @Interactable.draggable example\n |     max: Infinity,\n |     maxPerElement: 1,\n | });\n\\*/\nInteractable.prototype.gesturable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.gesture.enabled = options.enabled === false? false: true;\n    this.setPerAction('gesture', options);\n    this.setOnEvents('gesture', options);\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.gesture.enabled = options;\n\n    return this;\n  }\n\n  return this.options.gesture;\n};\n\nsignals.on('interactevent-gesture', function (arg) {\n  if (arg.action !== 'gesture') { return; }\n\n  const { interaction, iEvent, starting, ending, deltaSource } = arg;\n  const pointers = interaction.pointers;\n\n  iEvent.touches = [pointers[0], pointers[1]];\n\n  if (starting) {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box      = utils.touchBBox(pointers);\n    iEvent.scale    = 1;\n    iEvent.ds       = 0;\n    iEvent.angle    = utils.touchAngle(pointers, undefined, deltaSource);\n    iEvent.da       = 0;\n  }\n  else if (ending || event instanceof InteractEvent) {\n    iEvent.distance = interaction.prevEvent.distance;\n    iEvent.box      = interaction.prevEvent.box;\n    iEvent.scale    = interaction.prevEvent.scale;\n    iEvent.ds       = iEvent.scale - 1;\n    iEvent.angle    = interaction.prevEvent.angle;\n    iEvent.da       = iEvent.angle - interaction.gesture.startAngle;\n  }\n  else {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box      = utils.touchBBox(pointers);\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance;\n    iEvent.angle    = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n  }\n});\n\nsignals.on('interaction-new', function (interaction) {\n  interaction.gesture = {\n    start: { x: 0, y: 0 },\n\n    startDistance: 0,   // distance between two touches of touchStart\n    prevDistance : 0,\n    distance     : 0,\n\n    scale: 1,           // gesture.distance / gesture.startDistance\n\n    startAngle: 0,      // angle of line joining two touches\n    prevAngle : 0,      // angle of the previous gesture event\n  };\n});\n\nbase.gesture = gesture;\nbase.names.push('gesture');\nutils.merge(scope.eventTypes, [\n  'gesturestart',\n  'gesturemove',\n  'gestureinertiastart',\n  'gestureend',\n]);\nbase.methodDict.gesture = 'gesturable';\n\ndefaultOptions.gesture = gesture.defaults;\n\nmodule.exports = gesture;\n","const base = require('./base');\nconst utils = require('../utils');\nconst browser = require('../utils/browser');\nconst signals = require('../utils/signals');\nconst scope = require('../scope');\nconst InteractEvent = require('../InteractEvent');\nconst Interactable = require('../Interactable');\nconst defaultOptions = require('../defaultOptions');\n\nconst resize = {\n  defaults: {\n    enabled      : false,\n    manualStart  : false,\n    max          : Infinity,\n    maxPerElement: 1,\n\n    snap      : null,\n    restrict  : null,\n    inertia   : null,\n    autoScroll: null,\n\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  },\n\n  checker: function (pointer, event, interactable, element, interaction, rect) {\n    if (!rect) { return null; }\n\n    const page = utils.extend({}, interaction.curCoords.page);\n    const options = interactable.options;\n\n    if (options.resize.enabled) {\n      const resizeOptions = options.resize;\n      const resizeEdges = { left: false, right: false, top: false, bottom: false };\n\n      // if using resize.edges\n      if (utils.isObject(resizeOptions.edges)) {\n        for (const edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge,\n                                              resizeOptions.edges[edge],\n                                              page,\n                                              interaction._eventTarget,\n                                              element,\n                                              rect,\n                                              resizeOptions.margin || scope.margin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: 'resize',\n            edges: resizeEdges,\n          };\n        }\n      }\n      else {\n        const right  = options.resize.axis !== 'y' && page.x > (rect.right  - scope.margin);\n        const bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - scope.margin);\n\n        if (right || bottom) {\n          return {\n            name: 'resize',\n            axes: (right? 'x' : '') + (bottom? 'y' : ''),\n          };\n        }\n      }\n    }\n\n    return null;\n  },\n\n  cursors: (browser.isIe9OrOlder ? {\n    x : 'e-resize',\n    y : 's-resize',\n    xy: 'se-resize',\n\n    top        : 'n-resize',\n    left       : 'w-resize',\n    bottom     : 's-resize',\n    right      : 'e-resize',\n    topleft    : 'se-resize',\n    bottomright: 'se-resize',\n    topright   : 'ne-resize',\n    bottomleft : 'ne-resize',\n  } : {\n    x : 'ew-resize',\n    y : 'ns-resize',\n    xy: 'nwse-resize',\n\n    top        : 'ns-resize',\n    left       : 'ew-resize',\n    bottom     : 'ns-resize',\n    right      : 'ew-resize',\n    topleft    : 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright   : 'nesw-resize',\n    bottomleft : 'nesw-resize',\n  }),\n\n  getCursor: function (action) {\n    if (action.axis) {\n      return resize.cursors[action.name + action.axis];\n    }\n    else if (action.edges) {\n      let cursorKey = '';\n      const edgeNames = ['top', 'bottom', 'left', 'right'];\n\n      for (let i = 0; i < 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i];\n        }\n      }\n\n      return resize.cursors[cursorKey];\n    }\n  },\n\n  beforeStart: utils.blank,\n\n  start: function (interaction, event) {\n    const resizeEvent = new InteractEvent(interaction, event, 'resize', 'start', interaction.element);\n\n    if (interaction.prepared.edges) {\n      const startRect = interaction.target.getRect(interaction.element);\n      const resizeOptions = interaction.target.options.resize;\n\n      /*\n       * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n       * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n       * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n       * on the active edges and the edge being interacted with.\n       */\n      if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n        const linkedEdges = utils.extend({}, interaction.prepared.edges);\n\n        linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n        linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n        linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n        linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n        interaction.prepared._linkedEdges = linkedEdges;\n      }\n      else {\n        interaction.prepared._linkedEdges = null;\n      }\n\n      // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n      if (resizeOptions.preserveAspectRatio) {\n        interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n      }\n\n      interaction.resizeRects = {\n        start     : startRect,\n        current   : utils.extend({}, startRect),\n        restricted: utils.extend({}, startRect),\n        previous  : utils.extend({}, startRect),\n        delta     : {\n          left: 0, right : 0, width : 0,\n          top : 0, bottom: 0, height: 0,\n        },\n      };\n\n      resizeEvent.rect = interaction.resizeRects.restricted;\n      resizeEvent.deltaRect = interaction.resizeRects.delta;\n    }\n\n    interaction.target.fire(resizeEvent);\n\n    interaction._interacting = true;\n\n    return resizeEvent;\n  },\n\n  move: function (interaction, event) {\n    const resizeEvent = new InteractEvent(interaction, event, 'resize', 'move', interaction.element);\n    const resizeOptions = interaction.target.options.resize;\n    const invert = resizeOptions.invert;\n    const invertible = invert === 'reposition' || invert === 'negate';\n\n    let edges = interaction.prepared.edges;\n\n    if (edges) {\n      const start      = interaction.resizeRects.start;\n      const current    = interaction.resizeRects.current;\n      const restricted = interaction.resizeRects.restricted;\n      const delta      = interaction.resizeRects.delta;\n      const previous   = utils.extend(interaction.resizeRects.previous, restricted);\n      const originalEdges = edges;\n\n      let dx = resizeEvent.dx;\n      let dy = resizeEvent.dy;\n\n      // `resize.preserveAspectRatio` takes precedence over `resize.square`\n      if (resizeOptions.preserveAspectRatio) {\n        const resizeStartAspectRatio = interaction.resizeStartAspectRatio;\n\n        edges = interaction.prepared._linkedEdges;\n\n        if ((originalEdges.left && originalEdges.bottom)\n            || (originalEdges.right && originalEdges.top)) {\n          dy = -dx / resizeStartAspectRatio;\n        }\n        else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }\n        else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }\n      }\n      else if (resizeOptions.square) {\n        edges = interaction.prepared._linkedEdges;\n\n        if ((originalEdges.left && originalEdges.bottom)\n            || (originalEdges.right && originalEdges.top)) {\n          dy = -dx;\n        }\n        else if (originalEdges.left || originalEdges.right) { dy = dx; }\n        else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n      }\n\n      // update the 'current' rect without modifications\n      if (edges.top   ) { current.top    += dy; }\n      if (edges.bottom) { current.bottom += dy; }\n      if (edges.left  ) { current.left   += dx; }\n      if (edges.right ) { current.right  += dx; }\n\n      if (invertible) {\n        // if invertible, copy the current rect\n        utils.extend(restricted, current);\n\n        if (invert === 'reposition') {\n          // swap edge values if necessary to keep width/height positive\n          let swap;\n\n          if (restricted.top > restricted.bottom) {\n            swap = restricted.top;\n\n            restricted.top = restricted.bottom;\n            restricted.bottom = swap;\n          }\n          if (restricted.left > restricted.right) {\n            swap = restricted.left;\n\n            restricted.left = restricted.right;\n            restricted.right = swap;\n          }\n        }\n      }\n      else {\n        // if not invertible, restrict to minimum of 0x0 rect\n        restricted.top    = Math.min(current.top, start.bottom);\n        restricted.bottom = Math.max(current.bottom, start.top);\n        restricted.left   = Math.min(current.left, start.right);\n        restricted.right  = Math.max(current.right, start.left);\n      }\n\n      restricted.width  = restricted.right  - restricted.left;\n      restricted.height = restricted.bottom - restricted.top ;\n\n      for (const edge in restricted) {\n        delta[edge] = restricted[edge] - previous[edge];\n      }\n\n      resizeEvent.edges = interaction.prepared.edges;\n      resizeEvent.rect = restricted;\n      resizeEvent.deltaRect = delta;\n    }\n\n    interaction.target.fire(resizeEvent);\n\n    return resizeEvent;\n  },\n\n  end: function (interaction, event) {\n    const endEvent = new InteractEvent(interaction, event, 'resize', 'end', interaction.element);\n\n    interaction.target.fire(endEvent);\n  },\n\n  stop: utils.blank,\n};\n\n/*\\\n * Interactable.resizable\n [ method ]\n *\n * Gets or sets whether resize actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of resize elements\n   | var isResizeable = interact('input[type=text]').resizable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n = (object) This Interactable\n   | interact(element).resizable({\n   |   onstart: function (event) {},\n   |   onmove : function (event) {},\n   |   onend  : function (event) {},\n   |\n   |   edges: {\n   |     top   : true,       // Use pointer coords to check for resize.\n   |     left  : false,      // Disable resizing from left edge.\n   |     bottom: '.resize-s',// Resize if pointer target matches selector\n   |     right : handleEl    // Resize if pointer target is the given Element\n   |   },\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height are adjusted at a 1:1 ratio.\n   |     square: false,\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height maintain the aspect ratio they had when resizing started.\n   |     preserveAspectRatio: false,\n   |\n   |   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   |   // 'negate' will allow the rect to have negative width/height\n   |   // 'reposition' will keep the width/height positive by swapping\n   |   // the top and bottom edges and/or swapping the left and right edges\n   |   invert: 'none' || 'negate' || 'reposition'\n   |\n   |   // limit multiple resizes.\n   |   // See the explanation in the @Interactable.draggable example\n   |   max: Infinity,\n   |   maxPerElement: 1,\n   | });\n  \\*/\nInteractable.prototype.resizable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.resize.enabled = options.enabled === false? false: true;\n    this.setPerAction('resize', options);\n    this.setOnEvents('resize', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.resize.axis = options.axis;\n    }\n    else if (options.axis === null) {\n      this.options.resize.axis = scope.defaultOptions.resize.axis;\n    }\n\n    if (utils.isBool(options.preserveAspectRatio)) {\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n    }\n    else if (utils.isBool(options.square)) {\n      this.options.resize.square = options.square;\n    }\n\n    return this;\n  }\n  if (utils.isBool(options)) {\n    this.options.resize.enabled = options;\n\n    return this;\n  }\n  return this.options.resize;\n};\n\nfunction checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n  // false, '', undefined, null\n  if (!value) { return false; }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width  = utils.isNumber(rect.width )? rect.width  : rect.right  - rect.left;\n    const height = utils.isNumber(rect.height)? rect.height : rect.bottom - rect.top ;\n\n    if (width < 0) {\n      if      (name === 'left' ) { name = 'right'; }\n      else if (name === 'right') { name = 'left' ; }\n    }\n    if (height < 0) {\n      if      (name === 'top'   ) { name = 'bottom'; }\n      else if (name === 'bottom') { name = 'top'   ; }\n    }\n\n    if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n    if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n    if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n    if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n  }\n\n  // the remaining checks require an element\n  if (!utils.isElement(element)) { return false; }\n\n  return utils.isElement(value)\n  // the value is an element to use as a resize handle\n    ? value === element\n    // otherwise check if element matches value as selector\n    : utils.matchesUpTo(element, value, interactableElement);\n}\n\nsignals.on('interaction-new', function (interaction) {\n  interaction.resizeAxes = 'xy';\n});\n\nsignals.on('interactevent-resize', function ({ interaction, iEvent }) {\n  if (!interaction.resizeAxes) { return; }\n\n  const options = interaction.target.options;\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      iEvent.dx = iEvent.dy;\n    }\n    else {\n      iEvent.dy = iEvent.dx;\n    }\n    iEvent.axes = 'xy';\n  }\n  else {\n    iEvent.axes = interaction.resizeAxes;\n\n    if (interaction.resizeAxes === 'x') {\n      iEvent.dy = 0;\n    }\n    else if (interaction.resizeAxes === 'y') {\n      iEvent.dx = 0;\n    }\n  }\n});\n\nbase.resize = resize;\nbase.names.push('resize');\nutils.merge(scope.eventTypes, [\n  'resizestart',\n  'resizemove',\n  'resizeinertiastart',\n  'resizeend',\n]);\nbase.methodDict.resize = 'resizable';\n\ndefaultOptions.resize = resize.defaults;\n\nmodule.exports = resize;\n","const raf            = require('./utils/raf');\nconst getWindow      = require('./utils/window').getWindow;\nconst isWindow       = require('./utils/isType').isWindow;\nconst domUtils       = require('./utils/domUtils');\nconst signals        = require('./utils/signals');\nconst defaultOptions = require('./defaultOptions');\n\nconst autoScroll = {\n  defaults: {\n    enabled  : false,\n    container: null,     // the item that is scrolled (Window or HTMLElement)\n    margin   : 60,\n    speed    : 300,      // the scroll speed in pixels per second\n  },\n\n  interaction: null,\n  i: null,    // the handle returned by window.setInterval\n  x: 0, y: 0, // Direction each pulse is to scroll in\n\n  isScrolling: false,\n  prevTime: 0,\n\n  start: function (interaction) {\n    autoScroll.isScrolling = true;\n    raf.cancel(autoScroll.i);\n\n    autoScroll.interaction = interaction;\n    autoScroll.prevTime = new Date().getTime();\n    autoScroll.i = raf.request(autoScroll.scroll);\n  },\n\n  stop: function () {\n    autoScroll.isScrolling = false;\n    raf.cancel(autoScroll.i);\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll: function () {\n    const options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n    const container = options.container || getWindow(autoScroll.interaction.element);\n    const now = new Date().getTime();\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000;\n    // displacement\n    const s = options.speed * dt;\n\n    if (s >= 1) {\n      if (isWindow(container)) {\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n      }\n      else if (container) {\n        container.scrollLeft += autoScroll.x * s;\n        container.scrollTop  += autoScroll.y * s;\n      }\n\n      autoScroll.prevTime = now;\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i);\n      autoScroll.i = raf.request(autoScroll.scroll);\n    }\n  },\n  check: function (interactable, actionName) {\n    const options = interactable.options;\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n  },\n  onInteractionMove: function ({ interaction, pointer }) {\n    if (!(interaction.interacting()\n          && autoScroll.check(interaction.target, interaction.prepared.name))) {\n      return;\n    }\n\n    if (interaction.inertiaStatus.active) {\n      autoScroll.x = autoScroll.y = 0;\n      return;\n    }\n\n    let top;\n    let right;\n    let bottom;\n    let left;\n\n    const options = interaction.target.options[interaction.prepared.name].autoScroll;\n    const container = options.container || getWindow(interaction.element);\n\n    if (isWindow(container)) {\n      left   = pointer.clientX < autoScroll.margin;\n      top    = pointer.clientY < autoScroll.margin;\n      right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n    }\n    else {\n      const rect = domUtils.getElementClientRect(container);\n\n      left   = pointer.clientX < rect.left   + autoScroll.margin;\n      top    = pointer.clientY < rect.top    + autoScroll.margin;\n      right  = pointer.clientX > rect.right  - autoScroll.margin;\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n    }\n\n    autoScroll.x = (right ? 1: left? -1: 0);\n    autoScroll.y = (bottom? 1:  top? -1: 0);\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin;\n      autoScroll.speed  = options.speed;\n\n      autoScroll.start(interaction);\n    }\n  },\n};\n\nsignals.on('interaction-stop-active', function () {\n  autoScroll.stop();\n});\n\nsignals.on('interaction-move-done', autoScroll.onInteractionMove);\n\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\n\nmodule.exports = autoScroll;\n","module.exports = {\n  base: {\n    accept        : null,\n    actionChecker : null,\n    styleCursor   : true,\n    preventDefault: 'auto',\n    origin        : { x: 0, y: 0 },\n    deltaSource   : 'page',\n    allowFrom     : null,\n    ignoreFrom    : null,\n    checker       : null,\n  },\n\n  perAction: {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n\n    inertia: {\n      enabled          : false,\n      resistance       : 10,    // the lambda in exponential decay\n      minSpeed         : 100,   // target speed must be above this for inertia to start\n      endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n      allowResume      : true,  // allow resuming an action in inertia phase\n      zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n      smoothEndDuration: 300,   // animate to snap/restrict endOnly if there's no inertia\n    },\n  },\n\n  _holdDuration: 600,\n};\n","// browser entry point\n\n// Legacy browser support\nrequire('./legacyBrowsers');\n\n// actions\nrequire('./actions/resize');\nrequire('./actions/drag');\nrequire('./actions/gesture');\n\n// autoScroll\nrequire('./autoScroll');\n\n// pointerEvents\nrequire('./pointerEvents');\n\n// modifiers\nrequire('./modifiers/snap');\nrequire('./modifiers/restrict');\n\nrequire('./Interaction.js');\n\nmodule.exports = require('./interact');\n","/**\n * interact.js v1.2.5\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n\nconst browser      = require('./utils/browser');\nconst events       = require('./utils/events');\nconst utils        = require('./utils');\nconst scope        = require('./scope');\nconst Interactable = require('./Interactable');\n\nscope.dynamicDrop = false;\n\n// Less Precision with touch input\nscope.margin = browser.supportsTouch || browser.supportsPointerEvent? 20: 10;\n\nscope.pointerMoveTolerance = 1;\n\n// Allow this many interactions to happen simultaneously\nscope.maxInteractions = Infinity;\n\n// because Webkit and Opera still use 'mousewheel' event type\nscope.wheelEvent = 'onmousewheel' in scope.document? 'mousewheel': 'wheel';\n\nscope.globalEvents = {};\n\nscope.inContext = function (interactable, element) {\n  return (interactable._context === element.ownerDocument\n          || utils.nodeContains(interactable._context, element));\n};\n\nscope.testIgnore = function (interactable, interactableElement, element) {\n  const ignoreFrom = interactable.options.ignoreFrom;\n\n  if (!ignoreFrom || !utils.isElement(element)) { return false; }\n\n  if (utils.isString(ignoreFrom)) {\n    return utils.matchesUpTo(element, ignoreFrom, interactableElement);\n  }\n  else if (utils.isElement(ignoreFrom)) {\n    return utils.nodeContains(ignoreFrom, element);\n  }\n\n  return false;\n};\n\nscope.testAllow = function (interactable, interactableElement, element) {\n  const allowFrom = interactable.options.allowFrom;\n\n  if (!allowFrom) { return true; }\n\n  if (!utils.isElement(element)) { return false; }\n\n  if (utils.isString(allowFrom)) {\n    return utils.matchesUpTo(element, allowFrom, interactableElement);\n  }\n  else if (utils.isElement(allowFrom)) {\n    return utils.nodeContains(allowFrom, element);\n  }\n\n  return false;\n};\n\nscope.interactables.indexOfElement = function indexOfElement (element, context) {\n  context = context || scope.document;\n\n  for (let i = 0; i < this.length; i++) {\n    const interactable = this[i];\n\n    if ((interactable.selector === element\n      && (interactable._context === context))\n      || (!interactable.selector && interactable._element === element)) {\n\n      return i;\n    }\n  }\n  return -1;\n};\n\nscope.interactables.get = function interactableGet (element, options) {\n  return this[this.indexOfElement(element, options && options.context)];\n};\n\nscope.interactables.forEachSelector = function (callback) {\n  for (let i = 0; i < this.length; i++) {\n    const interactable = this[i];\n\n    if (!interactable.selector) {\n      continue;\n    }\n\n    const ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\n    if (ret !== undefined) {\n      return ret;\n    }\n  }\n};\n\n/*\\\n * interact\n [ method ]\n *\n * The methods of this variable can be used to set elements as\n * interactables and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to\n * configure it.\n *\n - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n = (object) An @Interactable\n *\n > Usage\n | interact(document.getElementById('draggable')).draggable(true);\n |\n | var rectables = interact('rect');\n | rectables\n |     .gesturable(true)\n |     .on('gesturemove', function (event) {\n |         // something cool...\n |     })\n |     .autoScroll(true);\n\\*/\nfunction interact (element, options) {\n  return scope.interactables.get(element, options) || new Interactable(element, options);\n}\n\n/*\\\n * interact.isSet\n [ method ]\n *\n * Check if an element has been set\n - element (Element) The Element being searched for\n = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\\*/\ninteract.isSet = function (element, options) {\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n};\n\n/*\\\n * interact.on\n [ method ]\n *\n * Adds a global listener for an InteractEvent or adds a DOM event to\n * `document`\n *\n - type       (string | array | object) The types of events to listen for\n - listener   (function) The function event (s)\n - useCapture (boolean) #optional useCapture flag for addEventListener\n = (object) interact\n\\*/\ninteract.on = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (const eventType of type) {\n      interact.on(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (const prop in type) {\n      interact.on(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.contains(scope.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!scope.globalEvents[type]) {\n      scope.globalEvents[type] = [listener];\n    }\n    else {\n      scope.globalEvents[type].push(listener);\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n    events.add(scope.document, type, listener, useCapture);\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.off\n [ method ]\n *\n * Removes a global InteractEvent listener or DOM event from `document`\n *\n - type       (string | array | object) The types of events that were listened for\n - listener   (function) The listener function to be removed\n - useCapture (boolean) #optional useCapture flag for removeEventListener\n = (object) interact\n \\*/\ninteract.off = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (const eventType of type) {\n      interact.off(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (const prop in type) {\n      interact.off(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  if (!utils.contains(scope.eventTypes, type)) {\n    events.remove(scope.document, type, listener, useCapture);\n  }\n  else {\n    let index;\n\n    if (type in scope.globalEvents\n        && (index = utils.indexOf(scope.globalEvents[type], listener)) !== -1) {\n      scope.globalEvents[type].splice(index, 1);\n    }\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.debug\n [ method ]\n *\n * Returns an object which exposes internal data\n = (object) An object with properties that outline the current state and expose internal functions and variables\n\\*/\ninteract.debug = function () {\n  return scope;\n};\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage  = utils.pointerAverage;\ninteract.getTouchBBox       = utils.touchBBox;\ninteract.getTouchDistance   = utils.touchDistance;\ninteract.getTouchAngle      = utils.touchAngle;\n\ninteract.getElementRect       = utils.getElementRect;\ninteract.getElementClientRect = utils.getElementClientRect;\ninteract.matchesSelector      = utils.matchesSelector;\ninteract.closest              = utils.closest;\n\n/*\\\n * interact.supportsTouch\n [ method ]\n *\n = (boolean) Whether or not the browser supports touch input\n\\*/\ninteract.supportsTouch = function () {\n  return browser.supportsTouch;\n};\n\n/*\\\n * interact.supportsPointerEvent\n [ method ]\n *\n = (boolean) Whether or not the browser supports PointerEvents\n\\*/\ninteract.supportsPointerEvent = function () {\n  return browser.supportsPointerEvent;\n};\n\n/*\\\n * interact.stop\n [ method ]\n *\n * Cancels all interactions (end events are not fired)\n *\n - event (Event) An event on which to call preventDefault()\n = (object) interact\n\\*/\ninteract.stop = function (event) {\n  for (let i = scope.interactions.length - 1; i >= 0; i--) {\n    scope.interactions[i].stop(event);\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.dynamicDrop\n [ method ]\n *\n * Returns or sets whether the dimensions of dropzone elements are\n * calculated on every dragmove or only on dragstart for the default\n * dropChecker\n *\n - newValue (boolean) #optional True to check on each move. False to check only before start\n = (boolean | interact) The current setting or interact\n\\*/\ninteract.dynamicDrop = function (newValue) {\n  if (utils.isBool(newValue)) {\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\n      //calcRects(dropzones);\n    //}\n\n    scope.dynamicDrop = newValue;\n\n    return interact;\n  }\n  return scope.dynamicDrop;\n};\n\n/*\\\n * interact.pointerMoveTolerance\n [ method ]\n * Returns or sets the distance the pointer must be moved before an action\n * sequence occurs. This also affects tolerance for tap events.\n *\n - newValue (number) #optional The movement from the start position must be greater than this value\n = (number | Interactable) The current setting or interact\n\\*/\ninteract.pointerMoveTolerance = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    scope.pointerMoveTolerance = newValue;\n\n    return this;\n  }\n\n  return scope.pointerMoveTolerance;\n};\n\n/*\\\n * interact.maxInteractions\n [ method ]\n **\n * Returns or sets the maximum number of concurrent interactions allowed.\n * By default only 1 interaction is allowed at a time (for backwards\n * compatibility). To allow multiple interactions on the same Interactables\n * and elements, you need to enable it in the draggable, resizable and\n * gesturable `'max'` and `'maxPerElement'` options.\n **\n - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\\*/\ninteract.maxInteractions = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    scope.maxInteractions = newValue;\n\n    return this;\n  }\n\n  return scope.maxInteractions;\n};\n\nscope.interact = interact;\n\nmodule.exports = interact;\n","const scope   = require('./scope');\nconst events  = require('./utils/events');\nconst signals = require('./utils/signals');\nconst browser = require('./utils/browser');\nconst iFinder = require('./utils/interactionFinder');\n\nconst toString = Object.prototype.toString;\n\nif (!window.Array.isArray) {\n  window.Array.isArray = function (obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n\n// http://www.quirksmode.org/dom/events/click.html\n// >Events leading to dblclick\n//\n// IE8 doesn't fire down event before dblclick.\n// This workaround tries to fire a tap and doubletap after dblclick\nfunction onIE8Dblclick (event) {\n  const interaction = iFinder.search(event, event.type, event.target);\n\n  if (!interaction) { return; }\n\n  if (interaction.prevTap\n      && event.clientX === interaction.prevTap.clientX\n      && event.clientY === interaction.prevTap.clientY\n      && event.target  === interaction.prevTap.target) {\n\n    interaction.downTargets[0] = event.target;\n    interaction.downTimes  [0] = new Date().getTime();\n\n    scope.pointerEvents.collectEventTargets(interaction, event, event, event.target, 'tap');\n  }\n}\n\nif (browser.isIE8) {\n  signals.on('listen-to-document', function ({ doc }) {\n    // For IE's lack of Event#preventDefault\n    events.add(doc, 'selectstart', function (event) {\n      const interaction = scope.interactions[0];\n\n      if (interaction.currentAction()) {\n        interaction.checkAndPreventDefault(event);\n      }\n    });\n\n    if (scope.pointerEvents) {\n      events.add(doc, 'dblclick', onIE8Dblclick);\n    }\n  });\n}\n\nmodule.exports = null;\n","const extend = require('../utils/extend');\n\nconst modifiers = {\n  names: [],\n\n  setOffsets: function (interaction, interactable, element, rect, offsets) {\n    for (let i = 0; i < modifiers.names.length; i++) {\n      const modifierName = modifiers.names[i];\n\n      offsets[modifierName] =\n        modifiers[modifiers.names[i]].setOffset(interaction,\n                                                interactable, element, rect,\n                                                interaction.startOffset);\n    }\n  },\n\n  setAll: function (interaction, coordsArg, statuses, preEnd, requireEndOnly) {\n    const result = {\n      dx: 0,\n      dy: 0,\n      changed: false,\n      locked: false,\n      shouldMove: true,\n    };\n    const target = interaction.target;\n    const coords = extend({}, coordsArg);\n\n    let currentStatus;\n\n    for (const modifierName of modifiers.names) {\n      const modifier = modifiers[modifierName];\n\n      if (!modifier.shouldDo(target, interaction.prepared.name, preEnd, requireEndOnly)) { continue; }\n\n      currentStatus = modifier.set(coords, interaction, statuses[modifierName]);\n\n      if (currentStatus.locked) {\n        coords.x += currentStatus.dx;\n        coords.y += currentStatus.dy;\n\n        result.dx += currentStatus.dx;\n        result.dy += currentStatus.dy;\n\n        result.locked = true;\n      }\n    }\n\n    // a move should be fired if the modified coords of\n    // the last modifier status that was calculated changes\n    result.shouldMove = !currentStatus || currentStatus.changed;\n\n    return result;\n  },\n\n  resetStatuses: function (statuses) {\n    for (const modifierName of modifiers.names) {\n      statuses[modifierName] = modifiers[modifierName].reset(statuses[modifierName] || {});\n    }\n\n    return statuses;\n  },\n};\n\nmodule.exports = modifiers;\n","const modifiers = require('./base');\nconst utils = require('../utils');\nconst defaultOptions = require('../defaultOptions');\n\nconst restrict = {\n  defaults: {\n    enabled    : false,\n    endOnly    : false,\n    restriction: null,\n    elementRect: null,\n  },\n\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\n    const restrictOptions = interactable.options[actionName].restrict;\n\n    return (restrictOptions && restrictOptions.enabled\n            && (preEnd || !restrictOptions.endOnly)\n            && (!requireEndOnly || restrictOptions.endOnly));\n  },\n\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\n    const elementRect = interactable.options[interaction.prepared.name].restrict.elementRect;\n    const offset = {};\n\n    if (rect && elementRect) {\n      offset.left = startOffset.left - (rect.width  * elementRect.left);\n      offset.top  = startOffset.top  - (rect.height * elementRect.top);\n\n      offset.right  = startOffset.right  - (rect.width  * (1 - elementRect.right));\n      offset.bottom = startOffset.bottom - (rect.height * (1 - elementRect.bottom));\n    }\n    else {\n      offset.left = offset.top = offset.right = offset.bottom = 0;\n    }\n\n    return offset;\n  },\n\n  set: function (pageCoords, interaction, status) {\n    const target    = interaction.target;\n    const restrictOptions  = target && target.options[interaction.prepared.name].restrict;\n    let restriction = restrictOptions && restrictOptions.restriction;\n\n    if (!restriction) {\n      return status;\n    }\n\n    const page = status.useStatusXY\n      ? { x: status.x, y: status.y }\n      : utils.extend({}, pageCoords);\n\n    page.x -= interaction.inertiaStatus.resumeDx;\n    page.y -= interaction.inertiaStatus.resumeDy;\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    let rect;\n    let restrictedX;\n    let restrictedY;\n\n    if (utils.isString(restriction)) {\n      if (restriction === 'parent') {\n        restriction = utils.parentElement(interaction.element);\n      }\n      else if (restriction === 'self') {\n        restriction = target.getRect(interaction.element);\n      }\n      else {\n        restriction = utils.closest(interaction.element, restriction);\n      }\n\n      if (!restriction) { return status; }\n    }\n\n    if (utils.isFunction(restriction)) {\n      restriction = restriction(page.x, page.y, interaction.element);\n    }\n\n    if (utils.isElement(restriction)) {\n      restriction = utils.getElementRect(restriction);\n    }\n\n    rect = restriction;\n\n    const offset = interaction.modifierOffsets.restrict;\n\n    if (!restriction) {\n      restrictedX = page.x;\n      restrictedY = page.y;\n    }\n    // object is assumed to have\n    // x, y, width, height or\n    // left, top, right, bottom\n    else if ('x' in restriction && 'y' in restriction) {\n      restrictedX = Math.max(Math.min(rect.x + rect.width  - offset.right , page.x), rect.x + offset.left);\n      restrictedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top );\n    }\n    else {\n      restrictedX = Math.max(Math.min(rect.right  - offset.right , page.x), rect.left + offset.left);\n      restrictedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top  + offset.top );\n    }\n\n    status.dx = restrictedX - page.x;\n    status.dy = restrictedY - page.y;\n\n    status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.restrictedX = restrictedX;\n    status.restrictedY = restrictedY;\n\n    return status;\n  },\n\n  reset: function (status) {\n    status.dx = status.dy = 0;\n    status.modifiedX = status.modifiedY = NaN;\n    status.locked = false;\n    status.changed = true;\n\n    return status;\n  },\n\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\n    const options = interactable.options[actionName].restrict;\n    const elementRect = options && options.elementRect;\n\n    if (modifiers.restrict.shouldDo(interactable, actionName)\n        && !(phase === 'start' && elementRect && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy,\n        };\n      }\n    }\n  },\n};\n\nmodifiers.restrict = restrict;\nmodifiers.names.push('restrict');\n\ndefaultOptions.perAction.restrict = restrict.defaults;\n\nmodule.exports = restrict;\n","const modifiers = require('./base');\nconst interact = require('../interact');\nconst utils = require('../utils');\nconst defaultOptions = require('../defaultOptions');\n\nconst snap = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range  : Infinity,\n    targets: null,\n    offsets: null,\n\n    relativePoints: null,\n  },\n\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\n    const snapOptions = interactable.options[actionName].snap;\n\n    return (snapOptions && snapOptions.enabled\n            && (preEnd || !snapOptions.endOnly)\n            && (!requireEndOnly || snapOptions.endOnly));\n  },\n\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\n    const offsets = [];\n    const origin = utils.getOriginXY(interactable, element);\n    const snapOptions = interactable.options[interaction.prepared.name].snap;\n    const snapOffset = (snapOptions && snapOptions.offset === 'startCoords'\n      ? {\n        x: interaction.startCoords.page.x - origin.x,\n        y: interaction.startCoords.page.y - origin.y,\n      }\n      : snapOptions && snapOptions.offset || { x: 0, y: 0 });\n\n    if (rect && snapOptions && snapOptions.relativePoints && snapOptions.relativePoints.length) {\n      for (const { x: relativeX, y: relativeY } of snapOptions.relativePoints) {\n        offsets.push({\n          x: startOffset.left - (rect.width  * relativeX) + snapOffset.x,\n          y: startOffset.top  - (rect.height * relativeY) + snapOffset.y,\n        });\n      }\n    }\n    else {\n      offsets.push(snapOffset);\n    }\n\n    return offsets;\n  },\n\n  set: function (pageCoords, interaction, status) {\n    const snapOptions = interaction.target.options[interaction.prepared.name].snap;\n    const targets = [];\n    let target;\n    let page;\n    let i;\n\n    if (status.useStatusXY) {\n      page = { x: status.x, y: status.y };\n    }\n    else {\n      const origin = utils.getOriginXY(interaction.target, interaction.element);\n\n      page = utils.extend({}, pageCoords);\n\n      page.x -= origin.x;\n      page.y -= origin.y;\n    }\n\n    status.realX = page.x;\n    status.realY = page.y;\n\n    page.x -= interaction.inertiaStatus.resumeDx;\n    page.y -= interaction.inertiaStatus.resumeDy;\n\n    const offsets = interaction.modifierOffsets.snap;\n    let len = snapOptions.targets? snapOptions.targets.length : 0;\n\n    for (const { x: offsetX, y: offsetY } of offsets) {\n      const relativeX = page.x - offsetX;\n      const relativeY = page.y - offsetY;\n\n      for (const snapTarget of snapOptions.targets) {\n        if (utils.isFunction(snapTarget)) {\n          target = snapTarget(relativeX, relativeY, interaction);\n        }\n        else {\n          target = snapTarget;\n        }\n\n        if (!target) { continue; }\n\n        targets.push({\n          x: utils.isNumber(target.x) ? (target.x + offsetX) : relativeX,\n          y: utils.isNumber(target.y) ? (target.y + offsetY) : relativeY,\n\n          range: utils.isNumber(target.range)? target.range: snapOptions.range,\n        });\n      }\n    }\n\n    const closest = {\n      target: null,\n      inRange: false,\n      distance: 0,\n      range: 0,\n      dx: 0,\n      dy: 0,\n    };\n\n    for (i = 0, len = targets.length; i < len; i++) {\n      target = targets[i];\n\n      const range = target.range;\n      const dx = target.x - page.x;\n      const dy = target.y - page.y;\n      const distance = utils.hypot(dx, dy);\n      let inRange = distance <= range;\n\n      // Infinite targets count as being out of range\n      // compared to non infinite ones that are in range\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n        inRange = false;\n      }\n\n      if (!closest.target || (inRange\n          // is the closest target in range?\n          ? (closest.inRange && range !== Infinity\n          // the pointer is relatively deeper in this target\n          ? distance / range < closest.distance / closest.range\n          // this target has Infinite range and the closest doesn't\n          : (range === Infinity && closest.range !== Infinity)\n          // OR this target is closer that the previous closest\n        || distance < closest.distance)\n          // The other is not in range and the pointer is closer to this target\n          : (!closest.inRange && distance < closest.distance))) {\n\n        closest.target = target;\n        closest.distance = distance;\n        closest.range = range;\n        closest.inRange = inRange;\n        closest.dx = dx;\n        closest.dy = dy;\n\n        status.range = range;\n      }\n    }\n\n    let snapChanged;\n\n    if (closest.target) {\n      snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\n      status.snappedX = closest.target.x;\n      status.snappedY = closest.target.y;\n    }\n    else {\n      snapChanged = true;\n\n      status.snappedX = NaN;\n      status.snappedY = NaN;\n    }\n\n    status.dx = closest.dx;\n    status.dy = closest.dy;\n\n    status.changed = (snapChanged || (closest.inRange && !status.locked));\n    status.locked = closest.inRange;\n\n    return status;\n  },\n\n  reset: function (status) {\n    status.dx = status.dy = 0;\n    status.snappedX = status.snappedY = NaN;\n    status.locked = false;\n    status.changed = true;\n\n    return status;\n  },\n\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\n    const snapOptions = interactable.options[actionName].snap;\n    const relativePoints = snapOptions && snapOptions.relativePoints;\n\n    if (snapOptions && snapOptions.enabled\n        && !(phase === 'start' && relativePoints && relativePoints.length)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n      }\n\n      return {\n        range  : status.range,\n        locked : status.locked,\n        x      : status.snappedX,\n        y      : status.snappedY,\n        realX  : status.realX,\n        realY  : status.realY,\n        dx     : status.dx,\n        dy     : status.dy,\n      };\n    }\n  },\n};\n\ninteract.createSnapGrid = function (grid) {\n  return function (x, y) {\n    let offsetX = 0;\n    let offsetY = 0;\n\n    if (utils.isObject(grid.offset)) {\n      offsetX = grid.offset.x;\n      offsetY = grid.offset.y;\n    }\n\n    const gridx = Math.round((x - offsetX) / grid.x);\n    const gridy = Math.round((y - offsetY) / grid.y);\n\n    const newX = gridx * grid.x + offsetX;\n    const newY = gridy * grid.y + offsetY;\n\n    return {\n      x: newX,\n      y: newY,\n      range: grid.range,\n    };\n  };\n};\n\nmodifiers.snap = snap;\nmodifiers.names.push('snap');\n\ndefaultOptions.perAction.snap = snap.defaults;\n\nmodule.exports = snap;\n","const scope = require('./scope');\nconst InteractEvent = require('./InteractEvent');\nconst utils = require('./utils');\nconst browser = require('./utils/browser');\nconst signals = require('./utils/signals');\n\nconst simpleSignals = [\n  'interaction-down',\n  'interaction-up',\n  'interaction-up',\n  'interaction-cancel',\n];\nconst simpleEvents = [\n  'down',\n  'up',\n  'tap',\n  'cancel',\n];\n\nfunction preventOriginalDefault () {\n  this.originalEvent.preventDefault();\n}\n\nfunction firePointers (interaction, pointer, event, eventTarget, targets, elements, eventType) {\n  const pointerIndex = interaction.mouse? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n  let pointerEvent = {};\n  let i;\n  // for tap events\n  let interval;\n  let createNewDoubleTap;\n\n  // if it's a doubletap then the event properties would have been\n  // copied from the tap event and provided as the pointer argument\n  if (eventType === 'doubletap') {\n    pointerEvent = pointer;\n  }\n  else {\n    utils.pointerExtend(pointerEvent, event);\n    if (event !== pointer) {\n      utils.pointerExtend(pointerEvent, pointer);\n    }\n\n    pointerEvent.preventDefault           = preventOriginalDefault;\n    pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n    pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n    pointerEvent.interaction              = interaction;\n\n    pointerEvent.timeStamp     = new Date().getTime();\n    pointerEvent.originalEvent = event;\n    pointerEvent.type          = eventType;\n    pointerEvent.pointerId     = utils.getPointerId(pointer);\n    pointerEvent.pointerType   = interaction.mouse? 'mouse' : !browser.supportsPointerEvent? 'touch'\n      : utils.isString(pointer.pointerType)\n        ? pointer.pointerType\n        : [undefined, undefined,'touch', 'pen', 'mouse'][pointer.pointerType];\n  }\n\n  if (eventType === 'tap') {\n    pointerEvent.dt = pointerEvent.timeStamp - interaction.downTimes[pointerIndex];\n\n    interval = pointerEvent.timeStamp - interaction.tapTime;\n    createNewDoubleTap = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap'\n                            && interaction.prevTap.target === pointerEvent.target\n                            && interval < 500);\n\n    pointerEvent.double = createNewDoubleTap;\n\n    interaction.tapTime = pointerEvent.timeStamp;\n  }\n\n  for (i = 0; i < targets.length; i++) {\n    pointerEvent.currentTarget = elements[i];\n    pointerEvent.interactable = targets[i];\n    targets[i].fire(pointerEvent);\n\n    if (pointerEvent.immediatePropagationStopped\n        || (pointerEvent.propagationStopped\n            && elements[i + 1] !== pointerEvent.currentTarget)) {\n      break;\n    }\n  }\n\n  if (createNewDoubleTap) {\n    const doubleTap = {};\n\n    utils.extend(doubleTap, pointerEvent);\n\n    doubleTap.dt   = interval;\n    doubleTap.type = 'doubletap';\n\n    collectEventTargets(interaction, doubleTap, event, eventTarget, 'doubletap');\n\n    interaction.prevTap = doubleTap;\n  }\n  else if (eventType === 'tap') {\n    interaction.prevTap = pointerEvent;\n  }\n}\n\nfunction collectEventTargets (interaction, pointer, event, eventTarget, eventType) {\n  const pointerIndex = interaction.mouse? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (eventType === 'tap' && (interaction.pointerWasMoved\n      // or if the pointerup target is different to the pointerdown target\n      || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n    return;\n  }\n\n  const targets = [];\n  const elements = [];\n  let element = eventTarget;\n\n  function collectSelectors (interactable, selector, context) {\n    const els = browser.useMatchesSelectorPolyfill\n        ? context.querySelectorAll(selector)\n        : undefined;\n\n    if (interactable._iEvents[eventType]\n        && utils.isElement(element)\n        && scope.inContext(interactable, element)\n        && !scope.testIgnore(interactable, element, eventTarget)\n        && scope.testAllow(interactable, element, eventTarget)\n        && utils.matchesSelector(element, selector, els)) {\n\n      targets.push(interactable);\n      elements.push(element);\n    }\n  }\n\n  const interact = scope.interact;\n\n  while (element) {\n    if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n      targets.push(interact(element));\n      elements.push(element);\n    }\n\n    scope.interactables.forEachSelector(collectSelectors);\n\n    element = utils.parentElement(element);\n  }\n\n  // create the tap event even if there are no listeners so that\n  // doubletap can still be created and fired\n  if (targets.length || eventType === 'tap') {\n    firePointers(interaction, pointer, event, eventTarget, targets, elements, eventType);\n  }\n}\n\nsignals.on('interaction-move', function ({ interaction, pointer, event, eventTarget, duplicateMove }) {\n  const pointerIndex = (interaction.mouse\n    ? 0\n    : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer)));\n\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearTimeout(interaction.holdTimers[pointerIndex]);\n    }\n\n    collectEventTargets(interaction, pointer, event, eventTarget, 'move');\n  }\n});\n\nsignals.on('interaction-down', function ({ interaction, pointer, event, eventTarget, pointerIndex }) {\n  // copy event to be used in timeout for IE8\n  const eventCopy = browser.isIE8? utils.extend({}, event) : event;\n\n  interaction.holdTimers[pointerIndex] = setTimeout(function () {\n\n    collectEventTargets(interaction,\n                        browser.isIE8? eventCopy : pointer,\n                        eventCopy,\n                        eventTarget,\n                        'hold');\n\n  }, scope.defaultOptions._holdDuration);\n});\n\nfunction createSignalListener (event) {\n  return function (arg) {\n    collectEventTargets(arg.interaction,\n                        arg.pointer,\n                        arg.event,\n                        arg.eventTarget,\n                        event);\n  };\n}\n\nfor (let i = 0; i < simpleSignals.length; i++) {\n  signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n}\n\nsignals.on('interaction-new', function (interaction) {\n  interaction.prevTap = null;  // the most recent tap event on this interaction\n  interaction.tapTime = 0;     // time of the most recent tap event\n});\n\nutils.merge(scope.eventTypes, [\n  'down',\n  'move',\n  'up',\n  'cancel',\n  'tap',\n  'doubletap',\n  'hold',\n]);\n\nmodule.exports = scope.pointerEvents = {\n  firePointers,\n  collectEventTargets,\n  preventOriginalDefault,\n};\n","const scope   = {};\nconst utils   = require('./utils');\nconst signals = require('./utils/signals');\n\nscope.defaultOptions = require('./defaultOptions');\nscope.events         = require('./utils/events');\nscope.signals        = require('./utils/signals');\n\nutils.extend(scope, require('./utils/window'));\nutils.extend(scope, require('./utils/domObjects'));\n\nscope.documents  = [];  // all documents being listened to\nscope.eventTypes = [];  // all event types specific to interact.js\n\nscope.withinInteractionLimit = function (interactable, element, action) {\n  const options = interactable.options;\n  const maxActions = options[action.name].max;\n  const maxPerElement = options[action.name].maxPerElement;\n  let activeInteractions = 0;\n  let targetCount = 0;\n  let targetElementCount = 0;\n\n  for (let i = 0, len = scope.interactions.length; i < len; i++) {\n    const interaction = scope.interactions[i];\n    const otherAction = interaction.prepared.name;\n\n    if (!interaction.interacting()) { continue; }\n\n    activeInteractions++;\n\n    if (activeInteractions >= scope.maxInteractions) {\n      return false;\n    }\n\n    if (interaction.target !== interactable) { continue; }\n\n    targetCount += (otherAction === action.name)|0;\n\n    if (targetCount >= maxActions) {\n      return false;\n    }\n\n    if (interaction.element === element) {\n      targetElementCount++;\n\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n        return false;\n      }\n    }\n  }\n\n  return scope.maxInteractions > 0;\n};\n\nscope.endAllInteractions = function (event) {\n  for (let i = 0; i < scope.interactions.length; i++) {\n    scope.interactions[i].pointerEnd(event, event);\n  }\n};\n\nscope.prefixedPropREs = utils.prefixedPropREs;\n\nsignals.on('listen-to-document', function ({ doc }) {\n  // if document is already known\n  if (utils.contains(scope.documents, doc)) {\n    // don't call any further signal listeners\n    return false;\n  }\n});\n\nmodule.exports = scope;\n","function indexOf (array, target) {\n  for (let i = 0, len = array.length; i < len; i++) {\n    if (array[i] === target) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction contains (array, target) {\n  return indexOf(array, target) !== -1;\n}\n\nfunction merge (target, source) {\n  for (let i = 0; i < source.length; i++) {\n    target.push(source[i]);\n  }\n\n  return target;\n}\n\nmodule.exports = {\n  indexOf,\n  contains,\n  merge,\n};\n","const win        = require('./window');\nconst isType     = require('./isType');\nconst domObjects = require('./domObjects');\n\nconst browser = {\n  // Does the browser support touch input?\n  supportsTouch: !!(('ontouchstart' in win.window) || win.window.DocumentTouch\n                     && domObjects.document instanceof win.DocumentTouch),\n\n  // Does the browser support PointerEvents\n  supportsPointerEvent: !!domObjects.PointerEvent,\n\n  isIE8: ('attachEvent' in win.window) && !('addEventListener' in win.window),\n\n  // Opera Mobile must be handled differently\n  isOperaMobile: (navigator.appName === 'Opera'\n      && browser.supportsTouch\n      && navigator.userAgent.match('Presto')),\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  isIOS7: (/iP(hone|od|ad)/.test(navigator.platform)\n           && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n  isIe9OrOlder: domObjects.document.all && !win.window.atob,\n\n  // prefix matchesSelector\n  prefixedMatchesSelector: 'matches' in Element.prototype\n    ? 'matches': 'webkitMatchesSelector' in Element.prototype\n    ? 'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype\n    ? 'mozMatchesSelector': 'oMatchesSelector' in Element.prototype\n    ? 'oMatchesSelector': 'msMatchesSelector',\n\n  useMatchesSelectorPolyfill: false,\n\n  pEventTypes: (domObjects.PointerEvent\n    ? (domObjects.PointerEvent === win.window.MSPointerEvent\n      ? { up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n          out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' }\n      : { up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n          out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' })\n    : null),\n};\n\nbrowser.useMatchesSelectorPolyfill = !isType.isFunction(Element.prototype[browser.prefixedMatchesSelector]);\n\nmodule.exports = browser;\n","const domObjects = {};\nconst win = require('./window').window;\n\nfunction blank () {}\n\ndomObjects.document           = win.document;\ndomObjects.DocumentFragment   = win.DocumentFragment   || blank;\ndomObjects.SVGElement         = win.SVGElement         || blank;\ndomObjects.SVGSVGElement      = win.SVGSVGElement      || blank;\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\ndomObjects.HTMLElement        = win.HTMLElement        || win.Element;\n\ndomObjects.Event        = win.Event;\ndomObjects.Touch        = win.Touch || blank;\ndomObjects.PointerEvent = (win.PointerEvent || win.MSPointerEvent);\n\nmodule.exports = domObjects;\n","const win        = require('./window');\nconst browser    = require('./browser');\nconst isType     = require('./isType');\nconst domObjects = require('./domObjects');\n\nconst domUtils = {\n  nodeContains: function (parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  },\n\n  closest: function (child, selector) {\n    let parent = domUtils.parentElement(child);\n\n    while (isType.isElement(parent)) {\n      if (domUtils.matchesSelector(parent, selector)) { return parent; }\n\n      parent = domUtils.parentElement(parent);\n    }\n\n    return null;\n  },\n\n  parentElement: function (node) {\n    let parent = node.parentNode;\n\n    if (isType.isDocFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && isType.isDocFrag(parent)) {\n        continue;\n      }\n\n      return parent;\n    }\n\n    return parent;\n  },\n\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n  matchesSelectorPolyfill: browser.useMatchesSelectorPolyfill\n    ? function (element, selector, elems) {\n      elems = elems || element.parentNode.querySelectorAll(selector);\n\n      for (let i = 0, len = elems.length; i < len; i++) {\n        if (elems[i] === element) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    : null,\n\n  matchesSelector: function (element, selector, nodeList) {\n    if (browser.useMatchesSelectorPolyfill) {\n      return domUtils.matchesSelectorPolyfill(element, selector, nodeList);\n    }\n\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (win.window !== win.realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[browser.prefixedMatchesSelector](selector);\n  },\n\n  // Test for the element that's \"above\" all other qualifiers\n  indexOfDeepestElement: function (elements) {\n    let deepestZoneParents = [];\n    let dropzoneParents = [];\n    let dropzone;\n    let deepestZone = elements[0];\n    let index = deepestZone? 0: -1;\n    let parent;\n    let child;\n    let i;\n    let n;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (deepestZone instanceof domObjects.HTMLElement\n          && dropzone instanceof domObjects.SVGElement\n          && !(dropzone instanceof domObjects.SVGSVGElement)) {\n\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      }\n      else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      const parents = [\n        dropzoneParents[n - 1],\n        dropzoneParents[n],\n        deepestZoneParents[n],\n      ];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        }\n        else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  },\n\n  matchesUpTo: function (element, selector, limit) {\n    while (domUtils.isElement(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = domUtils.parentElement(element);\n\n      if (element === limit) {\n        return domUtils.matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  },\n\n  getActualElement: function (element) {\n    return (element instanceof domObjects.SVGElementInstance\n      ? element.correspondingUseElement\n      : element);\n  },\n\n  getScrollXY: function (relevantWindow) {\n    relevantWindow = relevantWindow || win.window;\n    return {\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n    };\n  },\n\n  getElementClientRect: function (element) {\n    const clientRect = (element instanceof domObjects.SVGElement\n      ? element.getBoundingClientRect()\n      : element.getClientRects()[0]);\n\n    return clientRect && {\n      left  : clientRect.left,\n      right : clientRect.right,\n      top   : clientRect.top,\n      bottom: clientRect.bottom,\n      width : clientRect.width  || clientRect.right  - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    };\n  },\n\n  getElementRect: function (element) {\n    const clientRect = domUtils.getElementClientRect(element);\n\n    if (!browser.isIOS7 && clientRect) {\n      const scroll = domUtils.getScrollXY(win.getWindow(element));\n\n      clientRect.left   += scroll.x;\n      clientRect.right  += scroll.x;\n      clientRect.top    += scroll.y;\n      clientRect.bottom += scroll.y;\n    }\n\n    return clientRect;\n  },\n};\n\nmodule.exports = domUtils;\n","const arr       = require('./arr');\nconst isType    = require('./isType');\nconst domUtils  = require('./domUtils');\nconst indexOf   = arr.indexOf;\nconst contains  = arr.contains;\nconst getWindow = require('./window').getWindow;\n\nconst useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window);\nconst addEvent       = useAttachEvent?  'attachEvent': 'addEventListener';\nconst removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener';\nconst on             = useAttachEvent? 'on': '';\n\nconst elements          = [];\nconst targets           = [];\nconst attachedListeners = [];\n\n// {\n//   type: {\n//     selectors: ['selector', ...],\n//     contexts : [document, ...],\n//     listeners: [[listener, useCapture], ...]\n//   }\n//  }\nconst delegatedEvents = {};\n\nconst documents = [];\n\nfunction add (element, type, listener, useCapture) {\n  let elementIndex = indexOf(elements, element);\n  let target = targets[elementIndex];\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0,\n    };\n\n    elementIndex = elements.push(element) - 1;\n    targets.push(target);\n\n    attachedListeners.push((useAttachEvent ? {\n      supplied: [],\n      wrapped : [],\n      useCount: [],\n    } : null));\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = [];\n    target.typeCount++;\n  }\n\n  if (!contains(target.events[type], listener)) {\n    let ret;\n\n    if (useAttachEvent) {\n      const { supplied, wrapped, useCount } = attachedListeners[elementIndex];\n      const listenerIndex = indexOf(supplied, listener);\n\n      const wrappedListener = wrapped[listenerIndex] || function (event) {\n        if (!event.immediatePropagationStopped) {\n          event.target = event.srcElement;\n          event.currentTarget = element;\n\n          event.preventDefault           = event.preventDefault           || preventDef;\n          event.stopPropagation          = event.stopPropagation          || stopProp;\n          event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n          if (/mouse|click/.test(event.type)) {\n            event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n            event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n          }\n\n          listener(event);\n        }\n      };\n\n      ret = element[addEvent](on + type, wrappedListener, !!useCapture);\n\n      if (listenerIndex === -1) {\n        supplied.push(listener);\n        wrapped.push(wrappedListener);\n        useCount.push(1);\n      }\n      else {\n        useCount[listenerIndex]++;\n      }\n    }\n    else {\n      ret = element[addEvent](type, listener, !!useCapture);\n    }\n    target.events[type].push(listener);\n\n    return ret;\n  }\n}\n\nfunction remove (element, type, listener, useCapture) {\n  const elementIndex = indexOf(elements, element);\n  const target = targets[elementIndex];\n\n  if (!target || !target.events) {\n    return;\n  }\n\n  let wrappedListener = listener;\n  let listeners;\n  let listenerIndex;\n\n  if (useAttachEvent) {\n    listeners = attachedListeners[elementIndex];\n    listenerIndex = indexOf(listeners.supplied, listener);\n    wrappedListener = listeners.wrapped[listenerIndex];\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all');\n      }\n    }\n    return;\n  }\n\n  if (target.events[type]) {\n    const len = target.events[type].length;\n\n    if (listener === 'all') {\n      for (let i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], !!useCapture);\n      }\n      return;\n    }\n    else {\n      for (let i = 0; i < len; i++) {\n        if (target.events[type][i] === listener) {\n          element[removeEvent](on + type, wrappedListener, !!useCapture);\n          target.events[type].splice(i, 1);\n\n          if (useAttachEvent && listeners) {\n            listeners.useCount[listenerIndex]--;\n            if (listeners.useCount[listenerIndex] === 0) {\n              listeners.supplied.splice(listenerIndex, 1);\n              listeners.wrapped.splice(listenerIndex, 1);\n              listeners.useCount.splice(listenerIndex, 1);\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      target.events[type] = null;\n      target.typeCount--;\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1);\n    elements.splice(elementIndex, 1);\n    attachedListeners.splice(elementIndex, 1);\n  }\n}\n\nfunction addDelegate (selector, context, type, listener, useCapture) {\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      selectors: [],\n      contexts : [],\n      listeners: [],\n    };\n\n    // add delegate listener functions\n    for (let i = 0; i < documents.length; i++) {\n      add(documents[i], type, delegateListener);\n      add(documents[i], type, delegateUseCapture, true);\n    }\n  }\n\n  const delegated = delegatedEvents[type];\n  let index;\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector\n        && delegated.contexts[index] === context) {\n      break;\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length;\n\n    delegated.selectors.push(selector);\n    delegated.contexts .push(context);\n    delegated.listeners.push([]);\n  }\n\n  // keep listener and useCapture flag\n  delegated.listeners[index].push([listener, useCapture]);\n}\n\nfunction removeDelegate (selector, context, type, listener, useCapture) {\n  const delegated = delegatedEvents[type];\n  let matchFound = false;\n  let index;\n\n  if (!delegated) { return; }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector\n        && delegated.contexts[index] === context) {\n\n      const listeners = delegated.listeners[index];\n\n      // each item of the listeners array is an array: [function, useCaptureFlag]\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        const fn = listeners[i][0];\n        const useCap = listeners[i][1];\n\n        // check if the listener functions and useCapture flags match\n        if (fn === listener && useCap === useCapture) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1);\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1);\n            delegated.contexts .splice(index, 1);\n            delegated.listeners.splice(index, 1);\n\n            // remove delegate function from context\n            remove(context, type, delegateListener);\n            remove(context, type, delegateUseCapture, true);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null;\n            }\n          }\n\n          // only remove one listener\n          matchFound = true;\n          break;\n        }\n      }\n\n      if (matchFound) { break; }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener (event, useCapture) {\n  const fakeEvent = {};\n  const delegated = delegatedEvents[event.type];\n  const eventTarget = (domUtils.getActualElement(event.path\n    ? event.path[0]\n    : event.target));\n  let element = eventTarget;\n\n  useCapture = useCapture? true: false;\n\n  // duplicate the event so that currentTarget can be changed\n  for (const prop in event) {\n    fakeEvent[prop] = event[prop];\n  }\n\n  fakeEvent.originalEvent = event;\n  fakeEvent.preventDefault = preventOriginalDefault;\n\n  // climb up document tree looking for selector matches\n  while (isType.isElement(element)) {\n    for (let i = 0; i < delegated.selectors.length; i++) {\n      const selector = delegated.selectors[i];\n      const context = delegated.contexts[i];\n\n      if (domUtils.matchesSelector(element, selector)\n          && domUtils.nodeContains(context, eventTarget)\n          && domUtils.nodeContains(context, element)) {\n\n        const listeners = delegated.listeners[i];\n\n        fakeEvent.currentTarget = element;\n\n        for (let j = 0; j < listeners.length; j++) {\n          if (listeners[j][1] === useCapture) {\n            listeners[j][0](fakeEvent);\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentElement(element);\n  }\n}\n\nfunction delegateUseCapture (event) {\n  return delegateListener.call(this, event, true);\n}\n\nfunction preventDef () {\n  this.returnValue = false;\n}\n\nfunction preventOriginalDefault () {\n  this.originalEvent.preventDefault();\n}\n\nfunction stopProp () {\n  this.cancelBubble = true;\n}\n\nfunction stopImmProp () {\n  this.cancelBubble = true;\n  this.immediatePropagationStopped = true;\n}\n\nmodule.exports = {\n  add,\n  remove,\n\n  addDelegate,\n  removeDelegate,\n\n  delegateListener,\n  delegateUseCapture,\n  delegatedEvents,\n  documents,\n\n  useAttachEvent,\n\n  _elements: elements,\n  _targets: targets,\n  _attachedListeners: attachedListeners,\n};\n","module.exports = function extend (dest, source) {\n  for (const prop in source) {\n    dest[prop] = source[prop];\n  }\n  return dest;\n};\n","const { closest, parentElement, getElementRect } = require('./domUtils');\nconst { isElement, isFunction, trySelector }     = require('./isType');\n\nmodule.exports = function (interactable, element) {\n  let origin = interactable.options.origin;\n\n  if (origin === 'parent') {\n    origin = parentElement(element);\n  }\n  else if (origin === 'self') {\n    origin = interactable.getRect(element);\n  }\n  else if (trySelector(origin)) {\n    origin = closest(element, origin) || { x: 0, y: 0 };\n  }\n\n  if (isFunction(origin)) {\n    origin = origin(interactable && element);\n  }\n\n  if (isElement(origin))  {\n    origin = getElementRect(origin);\n  }\n\n  origin.x = ('x' in origin)? origin.x : origin.left;\n  origin.y = ('y' in origin)? origin.y : origin.top;\n\n  return origin;\n};\n","module.exports = (x, y) =>  Math.sqrt(x * x + y * y);\n","const utils = module.exports;\nconst extend = require('./extend');\nconst win = require('./window');\n\nutils.blank = function () {};\n\nutils.warnOnce = function (method, message) {\n  let warned = false;\n\n  return function () {\n    if (!warned) {\n      win.window.console.warn(message);\n      warned = true;\n    }\n\n    return method.apply(this, arguments);\n  };\n};\n\n// http://stackoverflow.com/a/5634528/2280888\nutils._getQBezierValue = function (t, p1, p2, p3) {\n  const iT = 1 - t;\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n};\n\nutils.getQuadraticCurvePoint = function (startX, startY, cpX, cpY, endX, endY, position) {\n  return {\n    x:  utils._getQBezierValue(position, startX, cpX, endX),\n    y:  utils._getQBezierValue(position, startY, cpY, endY),\n  };\n};\n\n// http://gizma.com/easing/\nutils.easeOutQuad = function (t, b, c, d) {\n  t /= d;\n  return -c * t*(t-2) + b;\n};\n\nutils.extend      = extend;\nutils.hypot       = require('./hypot');\nutils.raf         = require('./raf');\nutils.browser     = require('./browser');\nutils.getOriginXY = require('./getOriginXY');\n\nextend(utils, require('./arr'));\nextend(utils, require('./isType'));\nextend(utils, require('./domUtils'));\nextend(utils, require('./pointerUtils'));\n","const scope = require('../scope');\nconst utils = require('./index');\nconst browser = require('./browser');\n\nconst finder = {\n  methodOrder: [ 'inertiaResume', 'mouse', 'hasPointer', 'idle' ],\n\n  search: function (pointer, eventType, eventTarget) {\n    const mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n                        // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                        || pointer.pointerType === 4);\n    const pointerId = utils.getPointerId(pointer);\n    const details = { pointer, pointerId, mouseEvent, eventType, eventTarget };\n\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details);\n\n      if (interaction) {\n        return interaction;\n      }\n    }\n  },\n\n  // try to resume inertia with a new pointer\n  inertiaResume: function ({ mouseEvent, eventType, eventTarget }) {\n    if (!/down|start/i.test(eventType)) {\n      return null;\n    }\n\n    for (const interaction of scope.interactions) {\n      let element = eventTarget;\n\n      if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n          && (interaction.mouse === mouseEvent)) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction;\n          }\n          element = utils.parentElement(element);\n        }\n      }\n    }\n\n    return null;\n  },\n\n  // if it's a mouse interaction\n  mouse: function ({ mouseEvent, eventType }) {\n    if (!mouseEvent && (browser.supportsTouch || browser.supportsPointerEvent)) {\n      return null;\n    }\n\n    // Find a mouse interaction that's not in inertia phase\n    for (const interaction of scope.interactions) {\n      if (interaction.mouse && !interaction.inertiaStatus.active) {\n        return interaction;\n      }\n    }\n\n    // Find any interaction specifically for mouse.\n    // If the eventType is a mousedown, and inertia is active\n    // ignore the interaction\n    for (const interaction of scope.interactions) {\n      if (interaction.mouse && !(/down/.test(eventType) && interaction.inertiaStatus.active)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n\n  // get interaction that has this pointer\n  hasPointer: function ({ pointerId }) {\n    for (const interaction of scope.interactions) {\n      if (utils.contains(interaction.pointerIds, pointerId)) {\n        return interaction;\n      }\n    }\n  },\n\n  // get first idle interaction\n  idle: function ({ mouseEvent }) {\n    for (const interaction of scope.interactions) {\n      if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n          && !interaction.interacting()\n          && !(!mouseEvent && interaction.mouse)) {\n\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n};\n\nmodule.exports = finder;\n","const win        = require('./window');\nconst isWindow   = require('./isWindow');\nconst domObjects = require('./domObjects');\n\nconst isType = {\n  isElement  : function (o) {\n    if (!o || (typeof o !== 'object')) { return false; }\n\n    const _window = win.getWindow(o) || win.window;\n\n    return (/object|function/.test(typeof _window.Element)\n      ? o instanceof _window.Element //DOM2\n      : o.nodeType === 1 && typeof o.nodeName === 'string');\n  },\n\n  isArray    : null,\n\n  isWindow   : function (thing) { return thing === win.window || isWindow(thing); },\n\n  isDocFrag  : function (thing) { return !!thing && thing instanceof domObjects.DocumentFragment; },\n\n  isObject   : function (thing) { return !!thing && (typeof thing === 'object'); },\n\n  isFunction : function (thing) { return typeof thing === 'function'; },\n\n  isNumber   : function (thing) { return typeof thing === 'number'  ; },\n\n  isBool     : function (thing) { return typeof thing === 'boolean' ; },\n\n  isString   : function (thing) { return typeof thing === 'string'  ; },\n\n  trySelector: function (value) {\n    if (!isType.isString(value)) { return false; }\n\n    // an exception will be raised if it is invalid\n    domObjects.document.querySelector(value);\n    return true;\n  },\n};\n\nisType.isArray = function (thing) {\n  return (isType.isObject(thing)\n      && (typeof thing.length !== 'undefined')\n      && isType.isFunction(thing.splice));\n};\n\nmodule.exports = isType;\n","module.exports = (thing) => !!(thing && thing.Window) && (thing instanceof thing.Window);\n","const hypot   = require('./hypot');\nconst browser = require('./browser');\nconst dom     = require('./domObjects');\nconst isType  = require('./isType');\n\nconst pointerUtils = {\n  copyCoords: function (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  },\n\n  setEventDeltas: function (targetObj, prev, cur) {\n    const now = new Date().getTime();\n\n    targetObj.page.x    = cur.page.x   - prev.page.x;\n    targetObj.page.y    = cur.page.y   - prev.page.y;\n    targetObj.client.x  = cur.client.x - prev.client.x;\n    targetObj.client.y  = cur.client.y - prev.client.y;\n    targetObj.timeStamp = now          - prev.timeStamp;\n\n    // set pointer velocity\n    const dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\n    targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx      = targetObj.page.x / dt;\n    targetObj.page.vy      = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx    = targetObj.client.x / dt;\n    targetObj.client.vy    = targetObj.client.y / dt;\n  },\n\n  isNativePointer: function  (pointer) {\n    return (pointer instanceof dom.Event || pointer instanceof dom.Touch);\n  },\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  getXY: function (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  },\n\n  getPageXY: function (pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      pointerUtils.getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    }\n    else {\n      pointerUtils.getXY('page', pointer, page);\n    }\n\n    return page;\n  },\n\n  getClientXY: function (pointer, client) {\n    client = client || {};\n\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      pointerUtils.getXY('screen', pointer, client);\n    }\n    else {\n      pointerUtils.getXY('client', pointer, client);\n    }\n\n    return client;\n  },\n\n  getPointerId: function (pointer) {\n    return isType.isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n  },\n\n  prefixedPropREs: {\n    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n  },\n\n  pointerExtend: function (dest, source) {\n    for (const prop in source) {\n      const prefixedPropREs = pointerUtils.prefixedPropREs;\n      let deprecated = false;\n\n      // skip deprecated prefixed properties\n      for (const vendor in prefixedPropREs) {\n        if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n          deprecated = true;\n          break;\n        }\n      }\n\n      if (!deprecated) {\n        dest[prop] = source[prop];\n      }\n    }\n    return dest;\n  },\n\n  getTouchPair: function (event) {\n    const touches = [];\n\n    // array of touches is supplied\n    if (isType.isArray(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n      if (event.type === 'touchend') {\n        if (event.touches.length === 1) {\n          touches[0] = event.touches[0];\n          touches[1] = event.changedTouches[0];\n        }\n        else if (event.touches.length === 0) {\n          touches[0] = event.changedTouches[0];\n          touches[1] = event.changedTouches[1];\n        }\n      }\n      else {\n        touches[0] = event.touches[0];\n        touches[1] = event.touches[1];\n      }\n    }\n\n    return touches;\n  },\n\n  pointerAverage: function (pointers) {\n    const average = {\n      pageX  : 0,\n      pageY  : 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0,\n    };\n\n    for (const pointer of pointers) {\n      for (const prop in average) {\n        average[prop] += pointer[prop];\n      }\n    }\n    for (const prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  },\n\n  touchBBox: function (event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    const touches = pointerUtils.getTouchPair(event);\n    const minX = Math.min(touches[0].pageX, touches[1].pageX);\n    const minY = Math.min(touches[0].pageY, touches[1].pageY);\n    const maxX = Math.max(touches[0].pageX, touches[1].pageX);\n    const maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  },\n\n  touchDistance: function (event, deltaSource) {\n    deltaSource = deltaSource;\n\n    const sourceX = deltaSource + 'X';\n    const sourceY = deltaSource + 'Y';\n    const touches = pointerUtils.getTouchPair(event);\n\n\n    const dx = touches[0][sourceX] - touches[1][sourceX];\n    const dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  },\n\n  touchAngle: function (event, prevAngle, deltaSource) {\n    deltaSource = deltaSource;\n\n    const sourceX = deltaSource + 'X';\n    const sourceY = deltaSource + 'Y';\n    const touches = pointerUtils.getTouchPair(event);\n    const dx = touches[0][sourceX] - touches[1][sourceX];\n    const dy = touches[0][sourceY] - touches[1][sourceY];\n    let angle = 180 * Math.atan(dy / dx) / Math.PI;\n\n    if (isType.isNumber(prevAngle)) {\n      const dr = angle - prevAngle;\n      const drClamped = dr % 360;\n\n      if (drClamped > 315) {\n        angle -= 360 + (angle / 360)|0 * 360;\n      }\n      else if (drClamped > 135) {\n        angle -= 180 + (angle / 360)|0 * 360;\n      }\n      else if (drClamped < -315) {\n        angle += 360 + (angle / 360)|0 * 360;\n      }\n      else if (drClamped < -135) {\n        angle += 180 + (angle / 360)|0 * 360;\n      }\n    }\n\n    return  angle;\n  },\n};\n\nmodule.exports = pointerUtils;\n","const vendors = ['ms', 'moz', 'webkit', 'o'];\nlet lastTime = 0;\nlet request;\nlet cancel;\n\nfor (let x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n  request = window[vendors[x] + 'RequestAnimationFrame'];\n  cancel = window[vendors[x] +'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  request = function (callback) {\n    const currTime = new Date().getTime();\n    const timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    const id = setTimeout(function () { callback(currTime + timeToCall); },\n                          timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  cancel = function (id) {\n    clearTimeout(id);\n  };\n}\n\nmodule.exports = {\n  request,\n  cancel,\n};\n","const { indexOf } = require('./arr');\n\nconst listeners = {\n  // signalName: [listeners],\n};\n\nconst signals = {\n  on: function (name, listener) {\n    if (!listeners[name]) {\n      listeners[name] = [listener];\n      return;\n    }\n\n    listeners[name].push(listener);\n  },\n  off: function (name, listener) {\n    if (!listeners[name]) { return; }\n\n    const index = indexOf(listeners[name], listener);\n\n    if (index !== -1) {\n      listeners[name].splice(index, 1);\n    }\n  },\n  fire: function (name, arg) {\n    const targetListeners = listeners[name];\n\n    if (!targetListeners) { return; }\n\n    for (let i = 0; i < targetListeners.length; i++) {\n      if (targetListeners[i](arg, name) === false) {\n        return;\n      }\n    }\n  },\n  listeners: listeners,\n};\n\nmodule.exports = signals;\n","const win = module.exports;\nconst isWindow = require('./isWindow');\n\nfunction init (window) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  win.realWindow = window;\n\n  // create a TextNode\n  const el = window.document.createTextNode('');\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document\n      && typeof window.wrap === 'function'\n    && window.wrap(el) === el) {\n    // return wrapped window\n    win.window = window.wrap(window);\n  }\n\n  // no Shadow DOM polyfil or native implementation\n  win.window = window;\n}\n\nif (typeof window === 'undefined') {\n  win.window     = undefined;\n  win.realWindow = undefined;\n}\nelse {\n  init(window);\n}\n\nwin.getWindow = function getWindow (node) {\n  if (isWindow(node)) {\n    return node;\n  }\n\n  const rootNode = (node.ownerDocument || node);\n\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\n};\n\nwin.init = init;\n"],"sourceRoot":"/source/"}