{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","interact.js","src/InteractEvent.js","src/Interactable.js","src/Interaction.js","src/actions/drag.js","src/actions/drop.js","src/actions/gesture.js","src/actions/index.js","src/actions/resize.js","src/autoScroll.js","src/autoStart/delay.js","src/autoStart/drag.js","src/autoStart/index.js","src/defaultOptions.js","src/index.js","src/inertia.js","src/interact.js","src/legacyBrowsers.js","src/modifiers/index.js","src/modifiers/restrict.js","src/modifiers/snap.js","src/pointerEvents.js","src/scope.js","src/utils/Signals.js","src/utils/arr.js","src/utils/browser.js","src/utils/domObjects.js","src/utils/domUtils.js","src/utils/events.js","src/utils/extend.js","src/utils/getOriginXY.js","src/utils/hypot.js","src/utils/index.js","src/utils/interactionFinder.js","src/utils/isType.js","src/utils/isWindow.js","src/utils/pointerUtils.js","src/utils/raf.js","src/utils/window.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","interact","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"init","./src/index","./src/utils/window",2,"_classCallCheck","instance","Constructor","TypeError","hypot","extend","getOriginXY","scope","signals","InteractEvent","interaction","event","action","phase","element","related","target","deltaSource","options","defaultOptions","sourceX","sourceY","origin","starting","ending","coords","startCoords","curCoords","page","client","x","y","ctrlKey","altKey","shiftKey","metaKey","button","buttons","relatedTarget","t0","downTimes","type","interactable","signalArg","iEvent","fire","prevEvent","pageX","pageY","clientX","clientY","x0","y0","clientX0","clientY0","timeStamp","dt","duration","speed","velocityX","velocityY","Date","getTime","dx","dy","pointerDelta","vx","vy","angle","Math","atan2","PI","overlap","left","up","right","down","swipe","velocity","prototype","preventDefault","stopImmediatePropagation","immediatePropagationStopped","propagationStopped","stopPropagation","on","_ref","./scope","./utils/Signals","./utils/extend","./utils/getOriginXY","./utils/hypot",3,"isType","events","actions","_require","getElementRect","_require2","indexOf","contains","interactables","Interactable","_context","document","_iEvents","_window","undefined","trySelector","context","getWindow","Node","isElement","_doc","win","doc","push","set","setOnEvents","phases","onAction","isFunction","onstart","onmove","onend","oninertiastart","setPerAction","option","isObject","perAction","enabled","isBool","getRect","isString","querySelector","rectChecker","checker","newValue","test","eventTypes","listeners","onEvent","len","globalEvents","eventType","listener","useCapture","search","trim","split","isArray","prop","wheelEvent","addDelegate","add","off","eventList","index","splice","removeDelegate","remove","base","perActions","actionName","methodDict","methodName","_iterator","settingsMethods","_isArray","Array","_i","Symbol","iterator","next","done","value","setting","unset","delegatedEvents","delegated","selectors","contexts","delegateListener","delegateUseCapture","./actions","./utils/arr","./utils/domUtils","./utils/events","./utils/isType",4,"validateAction","utils","name","doOnInteractions","method","eventTarget","getActualElement","path","curEventTarget","currentTarget","matches","browser","supportsTouch","prevTouchTime","changedTouches","pointer","finder","Interaction","invalidPointer","supportsPointerEvent","interactions","mouse","pointerIsDown","pointerType","_updateEventTargets","methodNames","prepared","axis","edges","pointers","pointerIds","downTargets","holdTimers","prevCoords","downEvent","downPointer","_eventTarget","_curEventTarget","pointerWasMoved","_interacting","setEventXY","targetObj","pointerAverage","tmpXY","getPageXY","getClientXY","pointerDown","pointerIndex","addPointer","interacting","pointerExtend","copyCoords","checkAndPreventDefault","start","copyAction","pointerMove","simulation","recordPointer","duplicateMove","pointerMoveTolerance","setEventDeltas","duplicate","interactingBeforeMove","doMove","_dontFireMove","pointerUp","getPointerId","clearTimeout","end","removePointer","stop","currentAction","id","nodeName","actionOptions","startAxis","delay","manualStart","_ref4","pEventTypes","PointerEvent","move","pointerHover","out","pointerOut","cancel","endAllInteractions","frameElement","parentDoc","ownerDocument","parentWindow","defaultView","error","windowParentError","_iterator2","_isArray2","_i2","_ref2","nodeContains","documents","_ref5","_iterator3","_isArray3","_i3","_ref3","withinLimit","withinInteractionLimit","./Interactable","./utils","./utils/browser","./utils/interactionFinder",5,"drag","defaults","max","Infinity","maxPerElement","snap","restrict","inertia","autoScroll","lockAxis","dragOptions","getCursor","dragEvent","abs","draggable","names","merge","../InteractEvent","../Interactable","../Interaction","../defaultOptions","../scope","../utils","./index",6,"collectDrops","drops","elements","current","drop","accept","matchesSelector","dropElements","querySelectorAll","currentElement","dropzones","fireActiveDrops","prevElement","activeDrops","setActiveDrops","dragElement","possibleDrops","rects","getDrop","validDrops","dynamicDrop","j","rect","dropCheck","dropIndex","indexOfDeepestElement","dropzone","getDropEvents","pointerEvent","dropEvents","enter","leave","activate","deactivate","tmpl","dropElement","dropTarget","prevDropElement","prevDropTarget","dragLeave","prevDropzone","dragEnter","dragmove","fireDropEvents","draggableElement","dropResult","_ref6","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","isNumber","min","dropped","dropOverlap","horizontal","vertical","top","bottom","dragRect","cx","width","cy","height","overlapArea","overlapRatio","_ref7","_ref8",7,"gesture","gestureEvent","ds","startDistance","prevDistance","distance","startAngle","prevAngle","scale","isNaN","gesturable","arg","touches","touchDistance","box","touchBBox","touchAngle","da","prevScale",8,9,"checkResizeEdge","interactableElement","margin","matchesUpTo","resize","square","preserveAspectRatio","NaN","invert","resizeOptions","resizeEdges","edge","axes","cursors","isIe9OrOlder","xy","topleft","bottomright","topright","bottomleft","cursorKey","edgeNames","resizeEvent","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","restricted","previous","delta","deltaRect","invertible","originalEdges","startAspectRatio","swap","resizable","resizeAxes","../utils/browser",10,"raf","isWindow","domUtils","container","isScrolling","prevTime","request","scroll","now","scrollBy","scrollLeft","scrollTop","check","onInteractionMove","innerWidth","innerHeight","getElementClientRect","./Interaction","./defaultOptions","./utils/raf","./utils/window",11,"preventImmediateMove","autoStart","delayTimer","setTimeout","../actions",12,"checkStartAxis","thisAxis","parentElement","absX","absY","currentAxis","getDraggable","selector","useMatchesSelectorPolyfill","inContext","testIgnore","testAllow","getAction","elementInteractable","get","selectorInteractable","forEachSelector","../utils/domUtils","../utils/isType",13,"validateSelector","matchElements","match","matchElement","getActionInfo","pushMatches","actionInfo","prepare","styleCursor","documentElement","style","cursor","defaultActionChecker","actionChecker","ignoreFrom","allowFrom","../utils/Signals",14,"resistance","minSpeed","endSpeed","allowResume","zeroResumeDelta","smoothEndDuration","_holdDuration",15,"./actions/drag","./actions/drop","./actions/gesture","./actions/resize","./autoScroll","./autoStart","./autoStart/delay","./autoStart/drag","./inertia","./interact","./legacyBrowsers","./modifiers/restrict","./modifiers/snap","./pointerEvents",16,"calcInertia","status","inertiaOptions","lambda","inertiaDur","log","v0","startEvent","sx","sy","modifiedXe","xe","vx0","modifiedYe","ye","vy0","te","lambda_v0","one_ve_v0","inertiaFrame","updateInertiaCoords","inertiaStatus","progress","exp","quadPoint","getQuadraticCurvePoint","animationFrame","boundInertiaFrame","active","smoothEndFrame","easeOutQuad","boundSmoothEndFrame","smoothEnd","pageUp","upCoords","clientUp","modifiers","resumed","vys","resumeDx","resumeDy","apply","statuses","pointerSpeed","inertiaPossible","modifierResult","resetStatuses","setAll","shouldMove","locked","detail","./InteractEvent","./modifiers",17,"maxInteractions","indexOfElement","callback","ret","isSet","debug","getPointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","closest",18,"onIE8Dblclick","iFinder","prevTap","pointerEvents","collectEventTargets","toString","Object","obj","String","replace","isIE8",19,"setStartOffsets","startOffset","setOffsets","modifierOffsets","offsets","modifierName","setOffset","coordsArg","preEnd","requireEndOnly","result","changed","currentStatus","modifier","shouldDo","reset","modifierStatuses","modifyCoords","../utils/extend",20,"endOnly","restriction","elementRect","restrictOptions","offset","pageCoords","useStatusXY","restrictedX","restrictedY","modifiedX","modifiedY",21,"range","targets","relativePoints","snapOptions","snapOffset","relativeX","relativeY","realX","realY","offsetX","offsetY","snapTarget","inRange","snapChanged","snappedX","snappedY","createSnapGrid","grid","gridx","round","gridy","newX","newY","../interact",22,"preventOriginalDefault","originalEvent","firePointers","interval","createNewDoubleTap","pointerId","tapTime","doubleTap","collectSelectors","els","createSignalListener","simpleSignals","simpleEvents","eventCopy",23,"maxActions","activeInteractions","targetCount","targetElementCount","otherAction","prefixedPropREs","./utils/domObjects",24,"Signals","targetListeners","./arr",25,"array","source",26,"domObjects","DocumentTouch","isOperaMobile","navigator","appName","userAgent","isIOS7","platform","appVersion","all","atob","prefixedMatchesSelector","Element","MSPointerEvent","over","./domObjects","./isType","./window",27,"blank","DocumentFragment","SVGElement","SVGSVGElement","SVGElementInstance","HTMLElement","Event","Touch",28,"parent","child","parentNode","node","isDocFrag","host","matchesSelectorPolyfill","elems","nodeList","realWindow","deepestZoneParents","dropzoneParents","deepestZone","unshift","ownerSVGElement","parents","lastChild","previousSibling","limit","correspondingUseElement","getScrollXY","relevantWindow","scrollX","scrollY","clientRect","getBoundingClientRect","getClientRects","_scroll","./browser",29,"elementIndex","typeCount","attachedListeners","useAttachEvent","supplied","wrapped","useCount","_attachedListeners$elementIndex","listenerIndex","wrappedListener","srcElement","preventDef","stopProp","stopImmProp","addEvent","removeEvent","hasOwnProperty","matchFound","fn","useCap","fakeEvent","returnValue","cancelBubble","arr","_elements","_targets","_attachedListeners","./domUtils",30,"dest",31,32,"sqrt",33,"warnOnce","message","warned","console","warn","arguments","_getQBezierValue","p1","p2","p3","iT","startX","startY","cpX","cpY","endX","endY","position","b","c","d","src","./extend","./getOriginXY","./hypot","./pointerUtils","./raf",34,"methodOrder","mouseEvent","details","simulationResume","firstNonActive","_iterator4","_isArray4","_i4","hasPointer","_ref9","_iterator5","_isArray5","_i5","idle","_ref10","_iterator6","_isArray6","_i6",35,"nodeType","thing","./isWindow",36,"Window",37,"dom","pointerUtils","prev","cur","isNativePointer","getXY","identifier","webkit","deprecated","vendor","getTouchPair","average","screenX","screenY","minX","minY","maxX","maxY",38,"vendors","lastTime","requestAnimationFrame","currTime","timeToCall",39,"el","createTextNode","wrap","rootNode"],"mappings":"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","file":"interact.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})\n","/*\n * In a (windowless) server environment this file exports a factory function\n * that takes the window to use.\n *\n *     var interact = require('interact.js')(windowObject);\n *\n * See https://github.com/taye/interact.js/issues/187\n */\nif (typeof window === 'undefined') {\n  module.exports = function (window) {\n    require('./src/utils/window').init(window);\n\n    return require('./src/index');\n  };\n}\nelse {\n  module.exports = require('./src/index');\n}\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.interact = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})\n({1:[function(require,module,exports){\n/*\n * In a (windowless) server environment this file exports a factory function\n * that takes the window to use.\n *\n *     var interact = require('interact.js')(windowObject);\n *\n * See https://github.com/taye/interact.js/issues/187\n */\nif (typeof window === 'undefined') {\n  module.exports = function (window) {\n    require('./src/utils/window').init(window);\n\n    return require('./src/index');\n  };\n} else {\n  module.exports = require('./src/index');\n}\n\n},{\"./src/index\":15,\"./src/utils/window\":39}],2:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar hypot = require('./utils/hypot');\nvar extend = require('./utils/extend');\nvar getOriginXY = require('./utils/getOriginXY');\nvar scope = require('./scope');\nvar signals = require('./utils/Signals')['new']();\n\nvar InteractEvent = (function () {\n  function InteractEvent(interaction, event, action, phase, element, related) {\n    _classCallCheck(this, InteractEvent);\n\n    var target = interaction.target;\n    var deltaSource = (target && target.options || scope.defaultOptions).deltaSource;\n    var sourceX = deltaSource + 'X';\n    var sourceY = deltaSource + 'Y';\n    var origin = getOriginXY(target, element);\n    var starting = phase === 'start';\n    var ending = phase === 'end';\n    var coords = starting ? interaction.startCoords : interaction.curCoords;\n\n    element = element || interaction.element;\n\n    var page = extend({}, coords.page);\n    var client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    this.ctrlKey = event.ctrlKey;\n    this.altKey = event.altKey;\n    this.shiftKey = event.shiftKey;\n    this.metaKey = event.metaKey;\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.target = element;\n    this.relatedTarget = related || null;\n    this.t0 = interaction.downTimes[interaction.downTimes.length - 1];\n    this.type = action + (phase || '');\n    this.interaction = interaction;\n    this.interactable = target;\n\n    var signalArg = {\n      interaction: interaction,\n      event: event,\n      action: action,\n      phase: phase,\n      element: element,\n      related: related,\n      page: page,\n      client: client,\n      coords: coords,\n      starting: starting,\n      ending: ending,\n      deltaSource: deltaSource,\n      iEvent: this\n    };\n\n    signals.fire('set-xy', signalArg);\n\n    if (ending) {\n      var prevEvent = interaction.prevEvent;\n\n      // use previous coords when ending\n      this.pageX = prevEvent.pageX;\n      this.pageY = prevEvent.pageY;\n      this.clientX = prevEvent.clientX;\n      this.clientY = prevEvent.clientY;\n    } else {\n      this.pageX = page.x;\n      this.pageY = page.y;\n      this.clientX = client.x;\n      this.clientY = client.y;\n    }\n\n    this.x0 = interaction.startCoords.page.x - origin.x;\n    this.y0 = interaction.startCoords.page.y - origin.y;\n    this.clientX0 = interaction.startCoords.client.x - origin.x;\n    this.clientY0 = interaction.startCoords.client.y - origin.y;\n\n    signals.fire('set-delta', signalArg);\n    signals.fire(action, signalArg);\n\n    if (starting) {\n      this.timeStamp = interaction.downTimes[0];\n      this.dt = 0;\n      this.duration = 0;\n      this.speed = 0;\n      this.velocityX = 0;\n      this.velocityY = 0;\n    } else if (phase === 'inertiastart') {\n      this.timeStamp = interaction.prevEvent.timeStamp;\n      this.dt = interaction.prevEvent.dt;\n      this.duration = interaction.prevEvent.duration;\n      this.speed = interaction.prevEvent.speed;\n      this.velocityX = interaction.prevEvent.velocityX;\n      this.velocityY = interaction.prevEvent.velocityY;\n    } else {\n      this.timeStamp = new Date().getTime();\n      this.dt = this.timeStamp - interaction.prevEvent.timeStamp;\n      this.duration = this.timeStamp - interaction.downTimes[0];\n\n      if (event instanceof InteractEvent) {\n        var dx = this[sourceX] - interaction.prevEvent[sourceX];\n        var dy = this[sourceY] - interaction.prevEvent[sourceY];\n        var dt = this.dt / 1000;\n\n        this.speed = hypot(dx, dy) / dt;\n        this.velocityX = dx / dt;\n        this.velocityY = dy / dt;\n      }\n      // if normal move or end event, use previous user event coords\n      else {\n          // speed and velocity in pixels per second\n          this.speed = interaction.pointerDelta[deltaSource].speed;\n          this.velocityX = interaction.pointerDelta[deltaSource].vx;\n          this.velocityY = interaction.pointerDelta[deltaSource].vy;\n        }\n    }\n\n    if ((ending || phase === 'inertiastart') && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n      var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n      var overlap = 22.5;\n\n      if (angle < 0) {\n        angle += 360;\n      }\n\n      var left = 135 - overlap <= angle && angle < 225 + overlap;\n      var up = 225 - overlap <= angle && angle < 315 + overlap;\n\n      var right = !left && (315 - overlap <= angle || angle < 45 + overlap);\n      var down = !up && 45 - overlap <= angle && angle < 135 + overlap;\n\n      this.swipe = {\n        up: up,\n        down: down,\n        left: left,\n        right: right,\n        angle: angle,\n        speed: interaction.prevEvent.speed,\n        velocity: {\n          x: interaction.prevEvent.velocityX,\n          y: interaction.prevEvent.velocityY\n        }\n      };\n    }\n\n    signals.fire('new', signalArg);\n    signals.fire('new-' + action, signalArg);\n  }\n\n  InteractEvent.prototype.preventDefault = function preventDefault() {};\n\n  InteractEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  };\n\n  InteractEvent.prototype.stopPropagation = function stopPropagation() {\n    this.propagationStopped = true;\n  };\n\n  return InteractEvent;\n})();\n\nsignals.on('set-delta', function (_ref) {\n  var iEvent = _ref.iEvent;\n  var interaction = _ref.interaction;\n  var ending = _ref.ending;\n  var starting = _ref.starting;\n  var page = _ref.page;\n  var client = _ref.client;\n  var deltaSource = _ref.deltaSource;\n\n  // end event dx, dy is difference between start and end points\n  if (ending) {\n    if (deltaSource === 'client') {\n      iEvent.dx = client.x - interaction.startCoords.client.x;\n      iEvent.dy = client.y - interaction.startCoords.client.y;\n    } else {\n      iEvent.dx = page.x - interaction.startCoords.page.x;\n      iEvent.dy = page.y - interaction.startCoords.page.y;\n    }\n  } else if (starting) {\n    iEvent.dx = 0;\n    iEvent.dy = 0;\n  } else {\n    if (deltaSource === 'client') {\n      iEvent.dx = client.x - interaction.prevEvent.clientX;\n      iEvent.dy = client.y - interaction.prevEvent.clientY;\n    } else {\n      iEvent.dx = page.x - interaction.prevEvent.pageX;\n      iEvent.dy = page.y - interaction.prevEvent.pageY;\n    }\n  }\n});\n\nInteractEvent.signals = signals;\n\nmodule.exports = InteractEvent;\n\n},{\"./scope\":23,\"./utils/Signals\":24,\"./utils/extend\":30,\"./utils/getOriginXY\":31,\"./utils/hypot\":32}],3:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar isType = require('./utils/isType');\nvar events = require('./utils/events');\nvar extend = require('./utils/extend');\nvar actions = require('./actions');\nvar scope = require('./scope');\nvar signals = require('./utils/Signals')['new']();\n\nvar _require = require('./utils/domUtils');\n\nvar getElementRect = _require.getElementRect;\n\nvar _require2 = require('./utils/arr');\n\nvar indexOf = _require2.indexOf;\nvar contains = _require2.contains;\n\n// all set interactables\nscope.interactables = [];\n\n/*\\\n * Interactable\n [ property ]\n **\n * Object type returned by @interact\n\\*/\n\nvar Interactable = (function () {\n  function Interactable(target, options) {\n    _classCallCheck(this, Interactable);\n\n    this.target = target;\n    this._context = scope.document;\n    this._iEvents = this._iEvents || {};\n\n    var _window = undefined;\n\n    if (isType.trySelector(target)) {\n      this.target = target;\n\n      var context = options && options.context;\n\n      _window = context ? scope.getWindow(context) : scope.window;\n\n      if (context && (_window.Node ? context instanceof _window.Node : isType.isElement(context) || context === _window.document)) {\n\n        this._context = context;\n      }\n    } else {\n      _window = scope.getWindow(target);\n    }\n\n    this._doc = _window.document;\n\n    signals.fire('new', {\n      target: target,\n      options: options,\n      interactable: this,\n      win: _window\n    });\n\n    if (this._doc !== scope.document) {\n      scope.signals.fire('listen-to-document', {\n        doc: this._doc,\n        win: _window\n      });\n    }\n\n    scope.interactables.push(this);\n\n    this.set(options);\n  }\n\n  Interactable.prototype.setOnEvents = function setOnEvents(action, phases) {\n    var onAction = 'on' + action;\n\n    if (isType.isFunction(phases.onstart)) {\n      this[onAction + 'start'] = phases.onstart;\n    }\n    if (isType.isFunction(phases.onmove)) {\n      this[onAction + 'move'] = phases.onmove;\n    }\n    if (isType.isFunction(phases.onend)) {\n      this[onAction + 'end'] = phases.onend;\n    }\n    if (isType.isFunction(phases.oninertiastart)) {\n      this[onAction + 'inertiastart'] = phases.oninertiastart;\n    }\n\n    return this;\n  };\n\n  Interactable.prototype.setPerAction = function setPerAction(action, options) {\n    // for all the default per-action options\n    for (var option in options) {\n      // if this option exists for this action\n      if (option in scope.defaultOptions[action]) {\n        // if the option in the options arg is an object value\n        if (isType.isObject(options[option])) {\n          // duplicate the object\n          this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n          if (isType.isObject(scope.defaultOptions.perAction[option]) && 'enabled' in scope.defaultOptions.perAction[option]) {\n            this.options[action][option].enabled = options[option].enabled === false ? false : true;\n          }\n        } else if (isType.isBool(options[option]) && isType.isObject(scope.defaultOptions.perAction[option])) {\n          this.options[action][option].enabled = options[option];\n        } else if (options[option] !== undefined) {\n          // or if it's not undefined, do a plain assignment\n          this.options[action][option] = options[option];\n        }\n      }\n    }\n  };\n\n  /*\\\n   * Interactable.getRect\n   [ method ]\n   *\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using @Interactable.rectChecker.\n   *\n   - element (Element) #optional The element to measure.\n   = (object) The object's bounding rectangle.\n   o {\n   o     top   : 0,\n   o     left  : 0,\n   o     bottom: 0,\n   o     right : 0,\n   o     width : 0,\n   o     height: 0\n   o }\n  \\*/\n\n  Interactable.prototype.getRect = function getRect(element) {\n    element = element || this.target;\n\n    if (isType.isString(this.target) && !isType.isElement(element)) {\n      element = this._context.querySelector(this.target);\n    }\n\n    return getElementRect(element);\n  };\n\n  /*\\\n   * Interactable.rectChecker\n   [ method ]\n   *\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n   = (function | object) The checker function or this Interactable\n  \\*/\n\n  Interactable.prototype.rectChecker = function rectChecker(checker) {\n    if (isType.isFunction(checker)) {\n      this.getRect = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.getRect;\n\n      return this;\n    }\n\n    return this.getRect;\n  };\n\n  /*\\\n   * Interactable.preventDefault\n   [ method ]\n   *\n   * Returns or sets whether to prevent the browser's default behaviour\n   * in response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   - newValue (string) #optional `true`, `false` or `'auto'`\n   = (string | Interactable) The current setting or this Interactable\n  \\*/\n\n  Interactable.prototype.preventDefault = function preventDefault(newValue) {\n    if (/^(always|never|auto)$/.test(newValue)) {\n      this.options.preventDefault = newValue;\n      return this;\n    }\n\n    if (isType.isBool(newValue)) {\n      this.options.preventDefault = newValue ? 'always' : 'never';\n      return this;\n    }\n\n    return this.options.preventDefault;\n  };\n\n  /*\\\n   * Interactable.origin\n   [ method ]\n   *\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n   * OR\n   - origin (Element) #optional An HTML or SVG Element whose rect will be used\n   **\n   = (object) The current origin or this Interactable\n  \\*/\n\n  Interactable.prototype.origin = function origin(newValue) {\n    if (isType.trySelector(newValue)) {\n      this.options.origin = newValue;\n      return this;\n    } else if (isType.isObject(newValue)) {\n      this.options.origin = newValue;\n      return this;\n    }\n\n    return this.options.origin;\n  };\n\n  /*\\\n   * Interactable.deltaSource\n   [ method ]\n   *\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n   = (string | object) The current deltaSource or this Interactable\n  \\*/\n\n  Interactable.prototype.deltaSource = function deltaSource(newValue) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue;\n\n      return this;\n    }\n\n    return this.options.deltaSource;\n  };\n\n  /*\\\n   * Interactable.context\n   [ method ]\n   *\n   * Gets the selector context Node of the Interactable. The default is `window.document`.\n   *\n   = (Node) The context Node of this Interactable\n   **\n  \\*/\n\n  Interactable.prototype.context = function context() {\n    return this._context;\n  };\n\n  /*\\\n   * Interactable.fire\n   [ method ]\n   *\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n   = (Interactable) this Interactable\n  \\*/\n\n  Interactable.prototype.fire = function fire(iEvent) {\n    if (!(iEvent && iEvent.type) || !contains(scope.eventTypes, iEvent.type)) {\n      return this;\n    }\n\n    var listeners = undefined;\n    var onEvent = 'on' + iEvent.type;\n\n    // Interactable#on() listeners\n    if (iEvent.type in this._iEvents) {\n      listeners = this._iEvents[iEvent.type];\n\n      for (var i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n        listeners[i](iEvent);\n      }\n    }\n\n    // interactable.onevent listener\n    if (isType.isFunction(this[onEvent])) {\n      this[onEvent](iEvent);\n    }\n\n    // interact.on() listeners\n    if (iEvent.type in scope.globalEvents && (listeners = scope.globalEvents[iEvent.type])) {\n\n      for (var i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n        listeners[i](iEvent);\n      }\n    }\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.on\n   [ method ]\n   *\n   * Binds a listener for an InteractEvent or DOM event.\n   *\n   - eventType  (string | array | object) The types of events to listen for\n   - listener   (function) The function event (s)\n   - useCapture (boolean) #optional useCapture flag for addEventListener\n   = (object) This Interactable\n  \\*/\n\n  Interactable.prototype.on = function on(eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (var i = 0; i < eventType.length; i++) {\n        this.on(eventType[i], listener, useCapture);\n      }\n\n      return this;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (var prop in eventType) {\n        this.on(prop, eventType[prop], listener);\n      }\n\n      return this;\n    }\n\n    if (eventType === 'wheel') {\n      eventType = scope.wheelEvent;\n    }\n\n    // convert to boolean\n    useCapture = useCapture ? true : false;\n\n    if (contains(scope.eventTypes, eventType)) {\n      // if this type of event was never bound to this Interactable\n      if (!(eventType in this._iEvents)) {\n        this._iEvents[eventType] = [listener];\n      } else {\n        this._iEvents[eventType].push(listener);\n      }\n    }\n    // delegated event for selector\n    else if (isType.isString(this.target)) {\n        events.addDelegate(this.target, this._context, eventType, listener, useCapture);\n      } else {\n        events.add(this.target, eventType, listener, useCapture);\n      }\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.off\n   [ method ]\n   *\n   * Removes an InteractEvent or DOM event listener\n   *\n   - eventType  (string | array | object) The types of events that were listened for\n   - listener   (function) The listener function to be removed\n   - useCapture (boolean) #optional useCapture flag for removeEventListener\n   = (object) This Interactable\n  \\*/\n\n  Interactable.prototype.off = function off(eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (var i = 0; i < eventType.length; i++) {\n        this.off(eventType[i], listener, useCapture);\n      }\n\n      return this;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (var prop in eventType) {\n        this.off(prop, eventType[prop], listener);\n      }\n\n      return this;\n    }\n\n    // convert to boolean\n    useCapture = useCapture ? true : false;\n\n    if (eventType === 'wheel') {\n      eventType = scope.wheelEvent;\n    }\n\n    // if it is an action event type\n    if (contains(scope.eventTypes, eventType)) {\n      var eventList = this._iEvents[eventType];\n      var index = eventList ? indexOf(eventList, listener) : -1;\n\n      if (index !== -1) {\n        this._iEvents[eventType].splice(index, 1);\n      }\n    }\n    // delegated event\n    else if (isType.isString(this.target)) {\n        events.removeDelegate(this.target, this._context, eventType, listener, useCapture);\n      }\n      // remove listener from this Interatable's element\n      else {\n          events.remove(this.target, eventType, listener, useCapture);\n        }\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.set\n   [ method ]\n   *\n   * Reset the options of this Interactable\n   - options (object) The new settings to apply\n   = (object) This Interactable\n  \\*/\n\n  Interactable.prototype.set = function set(options) {\n    if (!isType.isObject(options)) {\n      options = {};\n    }\n\n    this.options = extend({}, scope.defaultOptions.base);\n\n    var perActions = extend({}, scope.defaultOptions.perAction);\n\n    for (var actionName in actions.methodDict) {\n      var methodName = actions.methodDict[actionName];\n\n      this.options[actionName] = extend({}, scope.defaultOptions[actionName]);\n\n      this.setPerAction(actionName, perActions);\n\n      this[methodName](options[actionName]);\n    }\n\n    for (var _iterator = Interactable.settingsMethods, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var setting = _ref;\n\n      this.options[setting] = scope.defaultOptions.base[setting];\n\n      if (setting in options) {\n        this[setting](options[setting]);\n      }\n    }\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.unset\n   [ method ]\n   *\n   * Remove this interactable from the list of interactables and remove\n   * it's action capabilities and event listeners\n   *\n   = (object) @interact\n  \\*/\n\n  Interactable.prototype.unset = function unset() {\n    events.remove(this.target, 'all');\n\n    if (isType.isString(this.target)) {\n      // remove delegated events\n      for (var type in events.delegatedEvents) {\n        var delegated = events.delegatedEvents[type];\n\n        for (var i = 0; i < delegated.selectors.length; i++) {\n          if (delegated.selectors[i] === this.target && delegated.contexts[i] === this._context) {\n\n            delegated.selectors.splice(i, 1);\n            delegated.contexts.splice(i, 1);\n            delegated.listeners.splice(i, 1);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegated[type] = null;\n            }\n          }\n\n          events.remove(this._context, type, events.delegateListener);\n          events.remove(this._context, type, events.delegateUseCapture, true);\n\n          break;\n        }\n      }\n    } else {\n      events.remove(this, 'all');\n    }\n\n    signals.fire('unset', { interactable: this });\n\n    scope.interactables.splice(indexOf(scope.interactables, this), 1);\n\n    return scope.interact;\n  };\n\n  return Interactable;\n})();\n\nInteractable.signals = signals;\n\nInteractable.settingsMethods = ['deltaSource', 'origin', 'preventDefault', 'rectChecker'];\n\nmodule.exports = Interactable;\n\n},{\"./actions\":8,\"./scope\":23,\"./utils/Signals\":24,\"./utils/arr\":25,\"./utils/domUtils\":28,\"./utils/events\":29,\"./utils/extend\":30,\"./utils/isType\":35}],4:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar scope = require('./scope');\nvar utils = require('./utils');\nvar Interactable = require('./Interactable');\nvar events = require('./utils/events');\nvar browser = require('./utils/browser');\nvar finder = require('./utils/interactionFinder');\nvar signals = require('./utils/Signals')['new']();\n\nvar listeners = {};\nvar methodNames = ['pointerDown', 'pointerMove', 'pointerUp', 'addPointer', 'removePointer', 'recordPointer'];\n\n// for ignoring browser's simulated mouse events\nvar prevTouchTime = 0;\n\n// all active and idle interactions\nscope.interactions = [];\n\nvar Interaction = (function () {\n  function Interaction() {\n    _classCallCheck(this, Interaction);\n\n    this.target = null; // current interactable being interacted with\n    this.element = null; // the target element of the interactable\n\n    this.prepared = { // action that's ready to be fired on next move event\n      name: null,\n      axis: null,\n      edges: null\n    };\n\n    // keep track of added pointers\n    this.pointers = [];\n    this.pointerIds = [];\n    this.downTargets = [];\n    this.downTimes = [];\n    this.holdTimers = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      client: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      timeStamp: 0\n    };\n\n    this.downEvent = null; // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null; // previous action event\n\n    this.pointerIsDown = false;\n    this.pointerWasMoved = false;\n    this._interacting = false;\n\n    this.mouse = false;\n\n    signals.fire('new', this);\n\n    scope.interactions.push(this);\n  }\n\n  // Check if the current target supports the action.\n  // If so, return the validated action. Otherwise, return null\n\n  Interaction.prototype.setEventXY = function setEventXY(targetObj, pointers) {\n    var pointer = pointers.length > 1 ? utils.pointerAverage(pointers) : pointers[0];\n\n    var tmpXY = {};\n\n    utils.getPageXY(pointer, tmpXY, this);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    utils.getClientXY(pointer, tmpXY, this);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = new Date().getTime();\n  };\n\n  Interaction.prototype.pointerDown = function pointerDown(pointer, event, eventTarget) {\n    var pointerIndex = this.addPointer(pointer);\n\n    this.pointerIsDown = true;\n\n    if (!this.interacting()) {\n      this.setEventXY(this.curCoords, this.pointers);\n    }\n\n    signals.fire('down', {\n      pointer: pointer,\n      event: event,\n      eventTarget: eventTarget,\n      pointerIndex: pointerIndex,\n      interaction: this\n    });\n\n    if (!this.interacting()) {\n      this.pointerIsDown = true;\n      this.downEvent = event;\n\n      this.downTimes[pointerIndex] = new Date().getTime();\n      this.downTargets[pointerIndex] = eventTarget;\n\n      this.pointerWasMoved = false;\n\n      utils.pointerExtend(this.downPointer, pointer);\n      utils.copyCoords(this.prevCoords, this.curCoords);\n    }\n\n    this.checkAndPreventDefault(event);\n  };\n\n  /*\\\n   * Interaction.start\n   [ method ]\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate number\n   * of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   - action       (object)  The action to be performed - drag, resize, etc.\n   - interactable (Interactable) The Interactable to target\n   - element      (Element) The DOM Element to target\n   = (object) interact\n   **\n   | interact(target)\n   |   .draggable({\n   |     // disable the default drag start by down->move\n   |     manualStart: true\n   |   })\n   |   // start dragging after the user holds the pointer down\n   |   .on('hold', function (event) {\n   |     var interaction = event.interaction;\n   |\n   |     if (!interaction.interacting()) {\n   |       interaction.start({ name: 'drag' },\n   |                         event.interactable,\n   |                         event.currentTarget);\n   |     }\n   | });\n   \\*/\n\n  Interaction.prototype.start = function start(action, interactable, element) {\n    if (this.interacting() || !this.pointerIsDown || this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)) {\n      return;\n    }\n\n    // if this interaction had been removed after stopping\n    // add it back\n    if (utils.indexOf(scope.interactions, this) === -1) {\n      scope.interactions.push(this);\n    }\n\n    // set the startCoords if there was no prepared action\n    if (!this.prepared.name) {\n      this.setEventXY(this.startCoords, this.pointers);\n    }\n\n    utils.copyAction(this.prepared, action);\n    this.target = interactable;\n    this.element = element;\n\n    signals.fire('start', { interaction: this });\n\n    signals.fire('start-' + this.prepared.name, {\n      interaction: this,\n      event: this.downEvent\n    });\n  };\n\n  Interaction.prototype.pointerMove = function pointerMove(pointer, event, eventTarget) {\n    if (!this.simulation) {\n      this.recordPointer(pointer);\n      this.setEventXY(this.curCoords, this.pointers);\n    }\n\n    var duplicateMove = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y;\n\n    var dx = undefined;\n    var dy = undefined;\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.curCoords.client.x - this.startCoords.client.x;\n      dy = this.curCoords.client.y - this.startCoords.client.y;\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > scope.pointerMoveTolerance;\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and speeds\n      utils.setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n      var signalArg = {\n        pointer: pointer,\n        event: event,\n        eventTarget: eventTarget,\n        dx: dx,\n        dy: dy,\n        duplicate: duplicateMove,\n        interaction: this,\n        interactingBeforeMove: this.interacting()\n      };\n\n      signals.fire('move', signalArg);\n\n      // if interacting, fire a 'move-{action}' signal\n      if (this.interacting()) {\n        this.doMove(signalArg);\n        this.checkAndPreventDefault(event);\n      }\n\n      if (this.pointerWasMoved) {\n        utils.copyCoords(this.prevCoords, this.curCoords);\n      }\n\n      signals.fire('move-done', signalArg);\n    }\n  };\n\n  /*\\\n   * Interaction.doMove\n   [ method ]\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   *\n   **\n   | interact(target)\n   |   .draggable(true)\n   |   .on('dragmove', function (event) {\n   |     if (someCondition) {\n   |       // change the snap settings\n   |       event.interactable.draggable({ snap: { targets: [] }});\n   |       // fire another move event with re-calculated snap\n   |       event.interaction.doMove();\n   |     }\n   |   });\n   \\*/\n\n  Interaction.prototype.doMove = function doMove(signalArg) {\n    signalArg = utils.extend({\n      pointer: this.pointers[0],\n      event: this.prevEvent,\n      eventTarget: this._eventTarget,\n      interaction: this\n    }, signalArg || {});\n\n    signals.fire('before-action-move', signalArg);\n\n    if (!this._dontFireMove) {\n      signals.fire('move-' + this.prepared.name, signalArg);\n    }\n\n    this._dontFireMove = false;\n  };\n\n  // End interact move events and stop auto-scroll unless simulation is running\n\n  Interaction.prototype.pointerUp = function pointerUp(pointer, event, eventTarget, curEventTarget) {\n    var pointerIndex = this.mouse ? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    clearTimeout(this.holdTimers[pointerIndex]);\n\n    signals.fire(/cancel$/i.test(event.type) ? 'cancel' : 'up', {\n      pointer: pointer,\n      event: event,\n      eventTarget: eventTarget,\n      curEventTarget: curEventTarget,\n      interaction: this\n    });\n\n    if (!this.simulation) {\n      this.end(event);\n      this.removePointer(pointer);\n    }\n  };\n\n  /*\\\n   * Interaction.end\n   [ method ]\n   *\n   * Stop the current action and fire an end event. Inertial movement does\n   * not happen.\n   *\n   - event (PointerEvent) #optional\n   **\n   | interact(target)\n   |   .draggable(true)\n   |   .on('move', function (event) {\n   |     if (event.pageX > 1000) {\n   |       // end the current action\n   |       event.interaction.end();\n   |       // stop all further listeners from being called\n   |       event.stopImmediatePropagation();\n   |     }\n   |   });\n   \\*/\n\n  Interaction.prototype.end = function end(event) {\n    event = event || this.prevEvent;\n\n    if (this.interacting()) {\n      signals.fire('action-end', {\n        event: event,\n        interaction: this\n      });\n    }\n\n    this.stop(event);\n  };\n\n  Interaction.prototype.currentAction = function currentAction() {\n    return this._interacting ? this.prepared.name : null;\n  };\n\n  Interaction.prototype.interacting = function interacting() {\n    return this._interacting;\n  };\n\n  Interaction.prototype.stop = function stop(event) {\n    signals.fire('stop', { interaction: this });\n\n    if (this._interacting) {\n      signals.fire('stop-active', { interaction: this });\n\n      // prevent Default only if were previously interacting\n      if (event && utils.isFunction(event.preventDefault)) {\n        this.checkAndPreventDefault(event);\n      }\n\n      signals.fire('stop-' + this.prepared.name, {\n        event: event,\n        interaction: this\n      });\n    }\n\n    this.target = this.element = null;\n\n    this.pointerIsDown = this._interacting = false;\n    this.prepared.name = this.prevEvent = null;\n  };\n\n  Interaction.prototype.addPointer = function addPointer(pointer) {\n    var id = utils.getPointerId(pointer);\n    var index = this.mouse ? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) {\n      index = this.pointerIds.length;\n    }\n\n    this.pointerIds[index] = id;\n    this.pointers[index] = pointer;\n\n    return index;\n  };\n\n  Interaction.prototype.removePointer = function removePointer(pointer) {\n    var id = utils.getPointerId(pointer);\n    var index = this.mouse ? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) {\n      return;\n    }\n\n    this.pointers.splice(index, 1);\n    this.pointerIds.splice(index, 1);\n    this.downTargets.splice(index, 1);\n    this.downTimes.splice(index, 1);\n    this.holdTimers.splice(index, 1);\n  };\n\n  Interaction.prototype.recordPointer = function recordPointer(pointer) {\n    var index = this.mouse ? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    if (index === -1) {\n      return;\n    }\n\n    this.pointers[index] = pointer;\n  };\n\n  Interaction.prototype.checkAndPreventDefault = function checkAndPreventDefault(event) {\n    var setting = this.target && this.target.options.preventDefault;\n\n    if (!this.target || setting === 'never') {\n      return;\n    }\n\n    if (setting === 'always') {\n      event.preventDefault();\n      return;\n    }\n\n    // setting === 'auto'\n\n    // don't preventDefault on input elements\n    if (/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n      return;\n    }\n\n    var actionOptions = this.target.options[this.prepared.name];\n\n    // Do not preventDefault on pointerdown if the prepared action is delayed\n    // or it is a drag and dragging can only start from a certain direction.\n    // This allows a touch to pan the viewport if the action doesn't actually\n    // start>\n    if (/down|start/i.test(event.type) && (this.prepared.name === 'drag' && actionOptions.startAxis !== 'xy' || actionOptions && actionOptions.delay > 0)) {\n\n      return;\n    }\n\n    // with manualStart, only preventDefault while interacting\n    if (actionOptions && actionOptions.manualStart && !this.interacting()) {\n      return;\n    }\n\n    event.preventDefault();\n  };\n\n  Interaction.prototype._updateEventTargets = function _updateEventTargets(target, currentTarget) {\n    this._eventTarget = target;\n    this._curEventTarget = currentTarget;\n  };\n\n  return Interaction;\n})();\n\nfunction validateAction(action, interactable) {\n  if (utils.isObject(action) && interactable.options[action.name].enabled) {\n    return action;\n  }\n\n  return null;\n}\n\nfor (var i = 0, len = methodNames.length; i < len; i++) {\n  var method = methodNames[i];\n\n  listeners[method] = doOnInteractions(method);\n}\n\nfunction doOnInteractions(method) {\n  return function (event) {\n    var eventTarget = utils.getActualElement(event.path ? event.path[0] : event.target);\n    var curEventTarget = utils.getActualElement(event.currentTarget);\n    var matches = []; // [ [pointer, interaction], ...]\n\n    if (browser.supportsTouch && /touch/.test(event.type)) {\n      prevTouchTime = new Date().getTime();\n\n      for (var i = 0; i < event.changedTouches.length; i++) {\n        var pointer = event.changedTouches[i];\n        var interaction = finder.search(pointer, event.type, eventTarget);\n\n        matches.push([pointer, interaction || new Interaction()]);\n      }\n    } else {\n      var invalidPointer = false;\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (var i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n          invalidPointer = !scope.interactions[i].mouse && scope.interactions[i].pointerIsDown;\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer || new Date().getTime() - prevTouchTime < 500;\n      }\n\n      if (!invalidPointer) {\n        var interaction = finder.search(event, event.type, eventTarget);\n\n        if (!interaction) {\n\n          interaction = new Interaction();\n          interaction.mouse = /mouse/i.test(event.pointerType || event.type)\n          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n           || event.pointerType === 4;\n        }\n\n        matches.push([event, interaction]);\n      }\n    }\n\n    for (var _iterator = matches, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var pointer = _ref[0];\n      var interaction = _ref[1];\n\n      interaction._updateEventTargets(eventTarget, curEventTarget);\n      interaction[method](pointer, event, eventTarget, curEventTarget);\n    }\n  };\n}\n\nscope.signals.on('listen-to-document', function (_ref4) {\n  var doc = _ref4.doc;\n  var win = _ref4.win;\n\n  var pEventTypes = browser.pEventTypes;\n\n  // add delegate event listener\n  for (var eventType in scope.delegatedEvents) {\n    events.add(doc, eventType, events.delegateListener);\n    events.add(doc, eventType, events.delegateUseCapture, true);\n  }\n\n  if (scope.PointerEvent) {\n    events.add(doc, pEventTypes.down, listeners.pointerDown);\n    events.add(doc, pEventTypes.move, listeners.pointerMove);\n    events.add(doc, pEventTypes.move, listeners.pointerHover);\n    events.add(doc, pEventTypes.out, listeners.pointerOut);\n    events.add(doc, pEventTypes.up, listeners.pointerUp);\n    events.add(doc, pEventTypes.cancel, listeners.pointerUp);\n  } else {\n    events.add(doc, 'mousedown', listeners.pointerDown);\n    events.add(doc, 'mousemove', listeners.pointerMove);\n    events.add(doc, 'mousemove', listeners.pointerHover);\n    events.add(doc, 'mouseup', listeners.pointerUp);\n    events.add(doc, 'mouseout', listeners.pointerOut);\n\n    events.add(doc, 'touchstart', listeners.pointerDown);\n    events.add(doc, 'touchmove', listeners.pointerMove);\n    events.add(doc, 'touchend', listeners.pointerUp);\n    events.add(doc, 'touchcancel', listeners.pointerUp);\n  }\n\n  events.add(win, 'blur', scope.endAllInteractions);\n\n  try {\n    if (win.frameElement) {\n      var parentDoc = win.frameElement.ownerDocument;\n      var parentWindow = parentDoc.defaultView;\n\n      events.add(parentDoc, 'mouseup', listeners.pointerUp);\n      events.add(parentDoc, 'touchend', listeners.pointerUp);\n      events.add(parentDoc, 'touchcancel', listeners.pointerUp);\n      events.add(parentDoc, 'pointerup', listeners.pointerUp);\n      events.add(parentDoc, 'MSPointerUp', listeners.pointerUp);\n      events.add(parentWindow, 'blur', scope.endAllInteractions);\n    }\n  } catch (error) {\n    scope.windowParentError = error;\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  events.add(doc, 'dragstart', function (event) {\n    for (var _iterator2 = scope.interactions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var interaction = _ref2;\n\n      if (interaction.element && (interaction.element === event.target || utils.nodeContains(interaction.element, event.target))) {\n\n        interaction.checkAndPreventDefault(event);\n        return;\n      }\n    }\n  });\n\n  scope.documents.push(doc);\n  events.documents.push(doc);\n});\n\nscope.signals.fire('listen-to-document', {\n  win: scope.window,\n  doc: scope.document\n});\n\n// Stop related interactions when an Interactable is unset\nInteractable.signals.on('unset', function (_ref5) {\n  var interactable = _ref5.interactable;\n\n  for (var _iterator3 = scope.interactions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n    var _ref3;\n\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      _ref3 = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      _ref3 = _i3.value;\n    }\n\n    var interaction = _ref3;\n\n    if (interaction.target === interactable && interaction.interacting()) {\n      interaction.end();\n    }\n  }\n});\n\nInteraction.doOnInteractions = doOnInteractions;\nInteraction.withinLimit = scope.withinInteractionLimit;\nInteraction.validateAction = validateAction;\nInteraction.signals = signals;\n\nmodule.exports = Interaction;\n\n},{\"./Interactable\":3,\"./scope\":23,\"./utils\":33,\"./utils/Signals\":24,\"./utils/browser\":26,\"./utils/events\":29,\"./utils/interactionFinder\":34}],5:[function(require,module,exports){\nvar actions = require('./index');\nvar scope = require('../scope');\nvar utils = require('../utils');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\nvar drag = {\n  defaults: {\n    enabled: false,\n    manualStart: true,\n    max: Infinity,\n    maxPerElement: 1,\n\n    snap: null,\n    restrict: null,\n    inertia: null,\n    autoScroll: null,\n\n    startAxis: 'xy',\n    lockAxis: 'xy'\n  },\n\n  checker: function (pointer, event, interactable) {\n    var dragOptions = interactable.options.drag;\n\n    return dragOptions.enabled ? { name: 'drag', axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis } : null;\n  },\n\n  getCursor: function () {\n    return 'move';\n  }\n};\n\nInteraction.signals.on('start-drag', function (_ref) {\n  var interaction = _ref.interaction;\n  var event = _ref.event;\n\n  var dragEvent = new InteractEvent(interaction, event, 'drag', 'start', interaction.element);\n\n  interaction._interacting = true;\n  interaction.target.fire(dragEvent);\n  interaction.prevEvent = dragEvent;\n});\n\nInteraction.signals.on('before-action-move', function (_ref2) {\n  var interaction = _ref2.interaction;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  var axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    interaction.curCoords.page.y = interaction.startCoords.page.y;\n    interaction.curCoords.client.y = interaction.startCoords.client.y;\n\n    interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vx);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\n    interaction.pointerDelta.client.vy = 0;\n    interaction.pointerDelta.page.vy = 0;\n  } else if (axis === 'y') {\n    interaction.curCoords.page.x = interaction.startCoords.page.x;\n    interaction.curCoords.client.x = interaction.startCoords.client.x;\n\n    interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vy);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\n    interaction.pointerDelta.client.vx = 0;\n    interaction.pointerDelta.page.vx = 0;\n  }\n});\n\nInteraction.signals.on('move-drag', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var event = _ref3.event;\n\n  var dragEvent = new InteractEvent(interaction, event, 'drag', 'move', interaction.element);\n\n  var axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    dragEvent.pageY = interaction.startCoords.page.y;\n    dragEvent.clientY = interaction.startCoords.client.y;\n    dragEvent.dy = 0;\n  } else if (axis === 'y') {\n    dragEvent.pageX = interaction.startCoords.page.x;\n    dragEvent.clientX = interaction.startCoords.client.x;\n    dragEvent.dx = 0;\n  }\n\n  interaction.target.fire(dragEvent);\n  interaction.prevEvent = dragEvent;\n\n  // if the action was ended in a dragmove listener\n  if (!interaction.interacting()) {\n    return false;\n  }\n});\n\nInteraction.signals.on('action-end', function (_ref4) {\n  var interaction = _ref4.interaction;\n  var event = _ref4.event;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  var dragEvent = new InteractEvent(interaction, event, 'drag', 'end', interaction.element);\n\n  interaction.target.fire(dragEvent);\n  interaction.prevEvent = dragEvent;\n});\n\n/*\\\n * Interactable.draggable\n [ method ]\n *\n * Gets or sets whether drag actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of drag events\n | var isDraggable = interact('ul li').draggable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n = (object) This Interactable\n | interact(element).draggable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // the axis in which the first movement must be\n |     // for the drag sequence to start\n |     // 'xy' by default - any direction\n |     startAxis: 'x' || 'y' || 'xy',\n |\n |     // 'xy' by default - don't restrict to one axis (move in any direction)\n |     // 'x' or 'y' to restrict movement to either axis\n |     // 'start' to restrict movement to the axis the drag started in\n |     lockAxis: 'x' || 'y' || 'xy' || 'start',\n |\n |     // max number of drags that can happen concurrently\n |     // with elements of this Interactable. Infinity by default\n |     max: Infinity,\n |\n |     // max number of drags that can target the same element+Interactable\n |     // 1 by default\n |     maxPerElement: 2\n | });\n\\*/\nInteractable.prototype.draggable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drag.enabled = options.enabled === false ? false : true;\n    this.setPerAction('drag', options);\n    this.setOnEvents('drag', options);\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis;\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drag.enabled = options;\n\n    return this;\n  }\n\n  return this.options.drag;\n};\n\nactions.drag = drag;\nactions.names.push('drag');\nutils.merge(scope.eventTypes, ['dragstart', 'dragmove', 'draginertiastart', 'dragend']);\nactions.methodDict.drag = 'draggable';\n\ndefaultOptions.drag = drag.defaults;\n\nmodule.exports = drag;\n\n},{\"../InteractEvent\":2,\"../Interactable\":3,\"../Interaction\":4,\"../defaultOptions\":14,\"../scope\":23,\"../utils\":33,\"./index\":8}],6:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar scope = require('../scope');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\nvar drop = {\n  defaults: {\n    enabled: false,\n    accept: null,\n    overlap: 'pointer'\n  }\n};\n\nInteraction.signals.on('start-drag', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  // reset active dropzones\n  interaction.activeDrops.dropzones = [];\n  interaction.activeDrops.elements = [];\n  interaction.activeDrops.rects = [];\n\n  interaction.dropEvents = null;\n\n  if (!interaction.dynamicDrop) {\n    setActiveDrops(interaction, interaction.element);\n  }\n\n  var dragEvent = interaction.prevEvent;\n  var dropEvents = getDropEvents(interaction, event, dragEvent);\n\n  if (dropEvents.activate) {\n    fireActiveDrops(interaction, dropEvents.activate);\n  }\n});\n\nInteractEvent.signals.on('new-drag', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var iEvent = _ref3.iEvent;\n  var event = _ref3.event;\n\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\n    return;\n  }\n\n  var draggableElement = interaction.element;\n  var dragEvent = iEvent;\n  var dropResult = getDrop(dragEvent, event, draggableElement);\n\n  interaction.dropTarget = dropResult.dropzone;\n  interaction.dropElement = dropResult.element;\n\n  interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\n});\n\nInteraction.signals.on('move-drag', function (_ref4) {\n  var interaction = _ref4.interaction;\n\n  fireDropEvents(interaction, interaction.dropEvents);\n});\n\nInteraction.signals.on('action-end', function (_ref5) {\n  var interaction = _ref5.interaction;\n\n  if (interaction.prepared.name === 'drag') {\n    fireDropEvents(interaction, interaction.dropEvents);\n  }\n});\n\nInteraction.signals.on('stop-drag', function (_ref6) {\n  var interaction = _ref6.interaction;\n\n  interaction.activeDrops.dropzones = interaction.activeDrops.elements = interaction.activeDrops.rects = interaction.dropEvents = null;\n});\n\nfunction collectDrops(interaction, element) {\n  var drops = [];\n  var elements = [];\n\n  element = element || interaction.element;\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (var _iterator = scope.interactables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var current = _ref;\n\n    if (!current.options.drop.enabled) {\n      continue;\n    }\n\n    var accept = current.options.drop.accept;\n\n    // test the draggable element against the dropzone's accept setting\n    if (utils.isElement(accept) && accept !== element || utils.isString(accept) && !utils.matchesSelector(element, accept)) {\n\n      continue;\n    }\n\n    // query for new elements if necessary\n    var dropElements = utils.isString(current.target) ? current._context.querySelectorAll(current.target) : [current.target];\n\n    for (var i = 0; i < dropElements.length; i++) {\n      var currentElement = dropElements[i];\n\n      if (currentElement !== element) {\n        drops.push(current);\n        elements.push(currentElement);\n      }\n    }\n  }\n\n  return {\n    elements: elements,\n    dropzones: drops\n  };\n}\n\nfunction fireActiveDrops(interaction, event) {\n  var prevElement = undefined;\n\n  // loop through all active dropzones and trigger event\n  for (var i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    var current = interaction.activeDrops.dropzones[i];\n    var currentElement = interaction.activeDrops.elements[i];\n\n    // prevent trigger of duplicate events on same element\n    if (currentElement !== prevElement) {\n      // set current element as event target\n      event.target = currentElement;\n      current.fire(event);\n    }\n    prevElement = currentElement;\n  }\n}\n\n// Collect a new set of possible drops and save them in activeDrops.\n// setActiveDrops should always be called when a drag has just started or a\n// drag event happens while dynamicDrop is true\nfunction setActiveDrops(interaction, dragElement) {\n  // get dropzones and their elements that could receive the draggable\n  var possibleDrops = collectDrops(interaction, dragElement, true);\n\n  interaction.activeDrops.dropzones = possibleDrops.dropzones;\n  interaction.activeDrops.elements = possibleDrops.elements;\n  interaction.activeDrops.rects = [];\n\n  for (var i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    interaction.activeDrops.rects[i] = interaction.activeDrops.dropzones[i].getRect(interaction.activeDrops.elements[i]);\n  }\n}\n\nfunction getDrop(dragEvent, event, dragElement) {\n  var interaction = dragEvent.interaction;\n  var validDrops = [];\n\n  if (scope.dynamicDrop) {\n    setActiveDrops(interaction, dragElement);\n  }\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (var j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n    var current = interaction.activeDrops.dropzones[j];\n    var currentElement = interaction.activeDrops.elements[j];\n    var rect = interaction.activeDrops.rects[j];\n\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect) ? currentElement : null);\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  var dropIndex = utils.indexOfDeepestElement(validDrops);\n\n  return {\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n    element: interaction.activeDrops.elements[dropIndex] || null\n  };\n}\n\nfunction getDropEvents(interaction, pointerEvent, dragEvent) {\n  var dropEvents = {\n    enter: null,\n    leave: null,\n    activate: null,\n    deactivate: null,\n    move: null,\n    drop: null\n  };\n\n  var tmpl = {\n    dragEvent: dragEvent,\n    interaction: interaction,\n    target: interaction.dropElement,\n    dropzone: interaction.dropTarget,\n    relatedTarget: dragEvent.target,\n    draggable: dragEvent.interactable,\n    timeStamp: dragEvent.timeStamp\n  };\n\n  if (interaction.dropElement !== interaction.prevDropElement) {\n    // if there was a prevDropTarget, create a dragleave event\n    if (interaction.prevDropTarget) {\n      dropEvents.leave = utils.extend({ type: 'dragleave' }, tmpl);\n\n      dragEvent.dragLeave = dropEvents.leave.target = interaction.prevDropElement;\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\n    }\n    // if the dropTarget is not null, create a dragenter event\n    if (interaction.dropTarget) {\n      dropEvents.enter = {\n        dragEvent: dragEvent,\n        interaction: interaction,\n        target: interaction.dropElement,\n        dropzone: interaction.dropTarget,\n        relatedTarget: dragEvent.target,\n        draggable: dragEvent.interactable,\n        timeStamp: dragEvent.timeStamp,\n        type: 'dragenter'\n      };\n\n      dragEvent.dragEnter = interaction.dropElement;\n      dragEvent.dropzone = interaction.dropTarget;\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n    dropEvents.drop = utils.extend({ type: 'drop' }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = utils.extend({ type: 'dropactivate' }, tmpl);\n\n    dropEvents.activate.target = null;\n    dropEvents.activate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = utils.extend({ type: 'dropdeactivate' }, tmpl);\n\n    dropEvents.deactivate.target = null;\n    dropEvents.deactivate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n    dropEvents.move = utils.extend({\n      dragmove: dragEvent,\n      type: 'dropmove'\n    }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n\n  return dropEvents;\n}\n\nfunction fireDropEvents(interaction, dropEvents) {\n  if (dropEvents.leave) {\n    interaction.prevDropTarget.fire(dropEvents.leave);\n  }\n  if (dropEvents.enter) {\n    interaction.dropTarget.fire(dropEvents.enter);\n  }\n  if (dropEvents.drop) {\n    interaction.dropTarget.fire(dropEvents.drop);\n  }\n  if (dropEvents.deactivate) {\n    fireActiveDrops(interaction, dropEvents.deactivate);\n  }\n\n  interaction.prevDropTarget = interaction.dropTarget;\n  interaction.prevDropElement = interaction.dropElement;\n}\n\n/*\\\n * Interactable.dropzone\n [ method ]\n *\n * Returns or sets whether elements can be dropped onto this\n * Interactable to trigger drop events\n *\n * Dropzones can receive the following events:\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n *  - `dragmove` when a draggable that has entered the dropzone is moved\n *  - `drop` when a draggable is dropped into this dropzone\n *\n * Use the `accept` option to allow only elements that match the given CSS\n * selector or element. The value can be:\n *\n *  - **an Element** - only that element can be dropped into this dropzone.\n *  - **a string**, - the element being dragged must match it as a CSS selector.\n *  - **`null`** - accept options is cleared - it accepts any element.\n *\n * Use the `overlap` option to set how drops are checked for. The allowed\n * values are:\n *\n *   - `'pointer'`, the pointer must be over the dropzone (default)\n *   - `'center'`, the draggable element's center must be over the dropzone\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n *   over the dropzone\n *\n * Use the `checker` option to specify a function to check if a dragged\n * element is over this Interactable.\n *\n | interact(target)\n | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n |                       event,             // TouchEvent/PointerEvent/MouseEvent\n |                       dropped,           // bool result of the default checker\n |                       dropzone,          // dropzone Interactable\n |                       dropElement,       // dropzone elemnt\n |                       draggable,         // draggable Interactable\n |                       draggableElement) {// draggable element\n |\n |   return dropped && event.target.hasAttribute('allow-drop');\n | }\n *\n *\n - options (boolean | object | null) #optional The new value to be set.\n | interact('.drop').dropzone({\n |   accept: '.can-drop' || document.getElementById('single-drop'),\n |   overlap: 'pointer' || 'center' || zeroToOne\n | }\n = (boolean | object) The current setting or this Interactable\n\\*/\nInteractable.prototype.dropzone = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drop.enabled = options.enabled === false ? false : true;\n\n    if (utils.isFunction(options.ondrop)) {\n      this.ondrop = options.ondrop;\n    }\n    if (utils.isFunction(options.ondropactivate)) {\n      this.ondropactivate = options.ondropactivate;\n    }\n    if (utils.isFunction(options.ondropdeactivate)) {\n      this.ondropdeactivate = options.ondropdeactivate;\n    }\n    if (utils.isFunction(options.ondragenter)) {\n      this.ondragenter = options.ondragenter;\n    }\n    if (utils.isFunction(options.ondragleave)) {\n      this.ondragleave = options.ondragleave;\n    }\n    if (utils.isFunction(options.ondropmove)) {\n      this.ondropmove = options.ondropmove;\n    }\n\n    if (/^(pointer|center)$/.test(options.overlap)) {\n      this.options.drop.overlap = options.overlap;\n    } else if (utils.isNumber(options.overlap)) {\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n    }\n    if ('accept' in options) {\n      this.options.drop.accept = options.accept;\n    }\n    if ('checker' in options) {\n      this.options.drop.checker = options.checker;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drop.enabled = options;\n\n    return this;\n  }\n\n  return this.options.drop;\n};\n\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n  var dropped = false;\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || this.getRect(dropElement))) {\n    return this.options.drop.checker ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement) : false;\n  }\n\n  var dropOverlap = this.options.drop.overlap;\n\n  if (dropOverlap === 'pointer') {\n    var origin = utils.getOriginXY(draggable, draggableElement);\n    var page = utils.getPageXY(dragEvent);\n    var horizontal = undefined;\n    var vertical = undefined;\n\n    page.x += origin.x;\n    page.y += origin.y;\n\n    horizontal = page.x > rect.left && page.x < rect.right;\n    vertical = page.y > rect.top && page.y < rect.bottom;\n\n    dropped = horizontal && vertical;\n  }\n\n  var dragRect = draggable.getRect(draggableElement);\n\n  if (dropOverlap === 'center') {\n    var cx = dragRect.left + dragRect.width / 2;\n    var cy = dragRect.top + dragRect.height / 2;\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n  }\n\n  if (utils.isNumber(dropOverlap)) {\n    var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));\n\n    var overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n    dropped = overlapRatio >= dropOverlap;\n  }\n\n  if (this.options.drop.checker) {\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n  }\n\n  return dropped;\n};\n\nInteractable.signals.on('unset', function (_ref7) {\n  var interactable = _ref7.interactable;\n\n  interactable.dropzone(false);\n});\n\nInteractable.settingsMethods.push('dropChecker');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.dropTarget = null; // the dropzone a drag target might be dropped into\n  interaction.dropElement = null; // the element at the time of checking\n  interaction.prevDropTarget = null; // the dropzone that was recently dragged away from\n  interaction.prevDropElement = null; // the element at the time of checking\n  interaction.dropEvents = null; // the dropEvents related to the current drag event\n\n  interaction.activeDrops = {\n    dropzones: [], // the dropzones that are mentioned below\n    elements: [], // elements of dropzones that accept the target draggable\n    rects: [] };\n});\n\n// the rects of the elements mentioned above\nInteraction.signals.on('stop', function (_ref8) {\n  var interaction = _ref8.interaction;\n\n  interaction.dropTarget = interaction.dropElement = interaction.prevDropTarget = interaction.prevDropElement = null;\n});\n\nutils.merge(scope.eventTypes, ['dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop']);\nactions.methodDict.drop = 'dropzone';\n\ndefaultOptions.drop = drop.defaults;\n\nmodule.exports = drop;\n\n},{\"../InteractEvent\":2,\"../Interactable\":3,\"../Interaction\":4,\"../defaultOptions\":14,\"../scope\":23,\"../utils\":33,\"./index\":8}],7:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar scope = require('../scope');\nvar defaultOptions = require('../defaultOptions');\n\nvar gesture = {\n  defaults: {\n    manualStart: false,\n    enabled: false,\n    max: Infinity,\n    maxPerElement: 1,\n\n    restrict: null\n  },\n\n  checker: function (pointer, event, interactable, element, interaction) {\n    if (interaction.pointerIds.length >= 2) {\n      return { name: 'gesture' };\n    }\n\n    return null;\n  },\n\n  getCursor: function () {\n    return '';\n  }\n};\n\nInteraction.signals.on('start-gesture', function (_ref) {\n  var interaction = _ref.interaction;\n  var event = _ref.event;\n\n  var gestureEvent = new InteractEvent(interaction, event, 'gesture', 'start', interaction.element);\n\n  gestureEvent.ds = 0;\n\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = gestureEvent.distance;\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = gestureEvent.angle;\n  interaction.gesture.scale = 1;\n\n  interaction._interacting = true;\n\n  interaction.target.fire(gestureEvent);\n  interaction.prevEvent = gestureEvent;\n});\n\nInteraction.signals.on('move-gesture', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  if (!interaction.pointerIds.length) {\n    return interaction.prevEvent;\n  }\n\n  var gestureEvent = undefined;\n\n  gestureEvent = new InteractEvent(interaction, event, 'gesture', 'move', interaction.element);\n  gestureEvent.ds = gestureEvent.scale - interaction.gesture.scale;\n\n  interaction.target.fire(gestureEvent);\n\n  interaction.gesture.prevAngle = gestureEvent.angle;\n  interaction.gesture.prevDistance = gestureEvent.distance;\n\n  if (gestureEvent.scale !== Infinity && gestureEvent.scale !== null && gestureEvent.scale !== undefined && !isNaN(gestureEvent.scale)) {\n\n    interaction.gesture.scale = gestureEvent.scale;\n  }\n\n  interaction.prevEvent = gestureEvent;\n\n  // if the action was ended in a gesturemove listener\n  if (!interaction.interacting()) {\n    return false;\n  }\n});\n\nInteraction.signals.on('action-end', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var event = _ref3.event;\n\n  if (interaction.prepared.name !== 'gesture') {\n    return;\n  }\n\n  var gestureEvent = new InteractEvent(interaction, event, 'gesture', 'end', interaction.element);\n\n  interaction.target.fire(gestureEvent);\n  interaction.prevEvent = gestureEvent;\n});\n\n/*\\\n * Interactable.gesturable\n [ method ]\n *\n * Gets or sets whether multitouch gestures can be performed on the\n * Interactable's element\n *\n = (boolean) Indicates if this can be the target of gesture events\n   | var isGestureable = interact(element).gesturable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n = (object) this Interactable\n | interact(element).gesturable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // limit multiple gestures.\n |     // See the explanation in @Interactable.draggable example\n |     max: Infinity,\n |     maxPerElement: 1,\n | });\n\\*/\nInteractable.prototype.gesturable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.gesture.enabled = options.enabled === false ? false : true;\n    this.setPerAction('gesture', options);\n    this.setOnEvents('gesture', options);\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.gesture.enabled = options;\n\n    return this;\n  }\n\n  return this.options.gesture;\n};\n\nInteractEvent.signals.on('gesture', function (arg) {\n  if (arg.action !== 'gesture') {\n    return;\n  }\n\n  var interaction = arg.interaction;\n  var iEvent = arg.iEvent;\n  var event = arg.event;\n  var starting = arg.starting;\n  var ending = arg.ending;\n  var deltaSource = arg.deltaSource;\n\n  var pointers = interaction.pointers;\n\n  iEvent.touches = [pointers[0], pointers[1]];\n\n  if (starting) {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box = utils.touchBBox(pointers);\n    iEvent.scale = 1;\n    iEvent.ds = 0;\n    iEvent.angle = utils.touchAngle(pointers, undefined, deltaSource);\n    iEvent.da = 0;\n  } else if (ending || event instanceof InteractEvent) {\n    iEvent.distance = interaction.prevEvent.distance;\n    iEvent.box = interaction.prevEvent.box;\n    iEvent.scale = interaction.prevEvent.scale;\n    iEvent.ds = iEvent.scale - 1;\n    iEvent.angle = interaction.prevEvent.angle;\n    iEvent.da = iEvent.angle - interaction.gesture.startAngle;\n  } else {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box = utils.touchBBox(pointers);\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance;\n    iEvent.angle = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n  }\n});\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.gesture = {\n    start: { x: 0, y: 0 },\n\n    startDistance: 0, // distance between two touches of touchStart\n    prevDistance: 0,\n    distance: 0,\n\n    scale: 1, // gesture.distance / gesture.startDistance\n\n    startAngle: 0, // angle of line joining two touches\n    prevAngle: 0 };\n});\n\n// angle of the previous gesture event\nactions.gesture = gesture;\nactions.names.push('gesture');\nutils.merge(scope.eventTypes, ['gesturestart', 'gesturemove', 'gestureinertiastart', 'gestureend']);\nactions.methodDict.gesture = 'gesturable';\n\ndefaultOptions.gesture = gesture.defaults;\n\nmodule.exports = gesture;\n\n},{\"../InteractEvent\":2,\"../Interactable\":3,\"../Interaction\":4,\"../defaultOptions\":14,\"../scope\":23,\"../utils\":33,\"./index\":8}],8:[function(require,module,exports){\nvar actions = {\n  names: [],\n  methodDict: {}\n};\n\nmodule.exports = actions;\n\n},{}],9:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar browser = require('../utils/browser');\nvar scope = require('../scope');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\nvar resize = {\n  defaults: {\n    enabled: false,\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n\n    snap: null,\n    restrict: null,\n    inertia: null,\n    autoScroll: null,\n\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none'\n  },\n\n  checker: function (pointer, event, interactable, element, interaction, rect) {\n    if (!rect) {\n      return null;\n    }\n\n    var page = utils.extend({}, interaction.curCoords.page);\n    var options = interactable.options;\n\n    if (options.resize.enabled) {\n      var resizeOptions = options.resize;\n      var resizeEdges = { left: false, right: false, top: false, bottom: false };\n\n      // if using resize.edges\n      if (utils.isObject(resizeOptions.edges)) {\n        for (var edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._eventTarget, element, rect, resizeOptions.margin || scope.margin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: 'resize',\n            edges: resizeEdges\n          };\n        }\n      } else {\n        var right = options.resize.axis !== 'y' && page.x > rect.right - scope.margin;\n        var bottom = options.resize.axis !== 'x' && page.y > rect.bottom - scope.margin;\n\n        if (right || bottom) {\n          return {\n            name: 'resize',\n            axes: (right ? 'x' : '') + (bottom ? 'y' : '')\n          };\n        }\n      }\n    }\n\n    return null;\n  },\n\n  cursors: browser.isIe9OrOlder ? {\n    x: 'e-resize',\n    y: 's-resize',\n    xy: 'se-resize',\n\n    top: 'n-resize',\n    left: 'w-resize',\n    bottom: 's-resize',\n    right: 'e-resize',\n    topleft: 'se-resize',\n    bottomright: 'se-resize',\n    topright: 'ne-resize',\n    bottomleft: 'ne-resize'\n  } : {\n    x: 'ew-resize',\n    y: 'ns-resize',\n    xy: 'nwse-resize',\n\n    top: 'ns-resize',\n    left: 'ew-resize',\n    bottom: 'ns-resize',\n    right: 'ew-resize',\n    topleft: 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright: 'nesw-resize',\n    bottomleft: 'nesw-resize'\n  },\n\n  getCursor: function (action) {\n    if (action.axis) {\n      return resize.cursors[action.name + action.axis];\n    } else if (action.edges) {\n      var cursorKey = '';\n      var edgeNames = ['top', 'bottom', 'left', 'right'];\n\n      for (var i = 0; i < 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i];\n        }\n      }\n\n      return resize.cursors[cursorKey];\n    }\n  }\n};\n\nInteraction.signals.on('start-resize', function (_ref) {\n  var interaction = _ref.interaction;\n  var event = _ref.event;\n\n  var resizeEvent = new InteractEvent(interaction, event, 'resize', 'start', interaction.element);\n\n  if (interaction.prepared.edges) {\n    var startRect = interaction.target.getRect(interaction.element);\n    var resizeOptions = interaction.target.options.resize;\n\n    /*\n     * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n     * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n     * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n     * on the active edges and the edge being interacted with.\n     */\n    if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n      var linkedEdges = utils.extend({}, interaction.prepared.edges);\n\n      linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;\n      linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;\n      linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;\n      linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;\n\n      interaction.prepared._linkedEdges = linkedEdges;\n    } else {\n      interaction.prepared._linkedEdges = null;\n    }\n\n    // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n    if (resizeOptions.preserveAspectRatio) {\n      interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n    }\n\n    interaction.resizeRects = {\n      start: startRect,\n      current: utils.extend({}, startRect),\n      restricted: utils.extend({}, startRect),\n      previous: utils.extend({}, startRect),\n      delta: {\n        left: 0, right: 0, width: 0,\n        top: 0, bottom: 0, height: 0\n      }\n    };\n\n    resizeEvent.rect = interaction.resizeRects.restricted;\n    resizeEvent.deltaRect = interaction.resizeRects.delta;\n  }\n\n  interaction.target.fire(resizeEvent);\n\n  interaction._interacting = true;\n\n  interaction.prevEvent = resizeEvent;\n});\n\nInteraction.signals.on('move-resize', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  var resizeEvent = new InteractEvent(interaction, event, 'resize', 'move', interaction.element);\n  var resizeOptions = interaction.target.options.resize;\n  var invert = resizeOptions.invert;\n  var invertible = invert === 'reposition' || invert === 'negate';\n\n  var edges = interaction.prepared.edges;\n\n  if (edges) {\n    var start = interaction.resizeRects.start;\n    var current = interaction.resizeRects.current;\n    var restricted = interaction.resizeRects.restricted;\n    var delta = interaction.resizeRects.delta;\n    var previous = utils.extend(interaction.resizeRects.previous, restricted);\n    var originalEdges = edges;\n\n    var dx = resizeEvent.dx;\n    var dy = resizeEvent.dy;\n\n    if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n      // `resize.preserveAspectRatio` takes precedence over `resize.square`\n      var startAspectRatio = resizeOptions.preserveAspectRatio ? interaction.resizeStartAspectRatio : 1;\n\n      edges = interaction.prepared._linkedEdges;\n\n      if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n        dy = -dx / startAspectRatio;\n      } else if (originalEdges.left || originalEdges.right) {\n        dy = dx / startAspectRatio;\n      } else if (originalEdges.top || originalEdges.bottom) {\n        dx = dy * startAspectRatio;\n      }\n    }\n\n    // update the 'current' rect without modifications\n    if (edges.top) {\n      current.top += dy;\n    }\n    if (edges.bottom) {\n      current.bottom += dy;\n    }\n    if (edges.left) {\n      current.left += dx;\n    }\n    if (edges.right) {\n      current.right += dx;\n    }\n\n    if (invertible) {\n      // if invertible, copy the current rect\n      utils.extend(restricted, current);\n\n      if (invert === 'reposition') {\n        // swap edge values if necessary to keep width/height positive\n        var swap = undefined;\n\n        if (restricted.top > restricted.bottom) {\n          swap = restricted.top;\n\n          restricted.top = restricted.bottom;\n          restricted.bottom = swap;\n        }\n        if (restricted.left > restricted.right) {\n          swap = restricted.left;\n\n          restricted.left = restricted.right;\n          restricted.right = swap;\n        }\n      }\n    } else {\n      // if not invertible, restrict to minimum of 0x0 rect\n      restricted.top = Math.min(current.top, start.bottom);\n      restricted.bottom = Math.max(current.bottom, start.top);\n      restricted.left = Math.min(current.left, start.right);\n      restricted.right = Math.max(current.right, start.left);\n    }\n\n    restricted.width = restricted.right - restricted.left;\n    restricted.height = restricted.bottom - restricted.top;\n\n    for (var edge in restricted) {\n      delta[edge] = restricted[edge] - previous[edge];\n    }\n\n    resizeEvent.edges = interaction.prepared.edges;\n    resizeEvent.rect = restricted;\n    resizeEvent.deltaRect = delta;\n  }\n\n  interaction.target.fire(resizeEvent);\n\n  interaction.prevEvent = resizeEvent;\n\n  // if the action was ended in a resizemove listener\n  if (!interaction.interacting()) {\n    return false;\n  }\n});\n\nInteraction.signals.on('action-end', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var event = _ref3.event;\n\n  if (interaction.prepared.name !== 'resize') {\n    return;\n  }\n\n  var resizeEvent = new InteractEvent(interaction, event, 'resize', 'end', interaction.element);\n\n  interaction.target.fire(resizeEvent);\n  interaction.prevEvent = resizeEvent;\n});\n\n/*\\\n * Interactable.resizable\n [ method ]\n *\n * Gets or sets whether resize actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of resize elements\n   | var isResizeable = interact('input[type=text]').resizable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n = (object) This Interactable\n   | interact(element).resizable({\n   |   onstart: function (event) {},\n   |   onmove : function (event) {},\n   |   onend  : function (event) {},\n   |\n   |   edges: {\n   |     top   : true,       // Use pointer coords to check for resize.\n   |     left  : false,      // Disable resizing from left edge.\n   |     bottom: '.resize-s',// Resize if pointer target matches selector\n   |     right : handleEl    // Resize if pointer target is the given Element\n   |   },\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height are adjusted at a 1:1 ratio.\n   |     square: false,\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height maintain the aspect ratio they had when resizing started.\n   |     preserveAspectRatio: false,\n   |\n   |   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   |   // 'negate' will allow the rect to have negative width/height\n   |   // 'reposition' will keep the width/height positive by swapping\n   |   // the top and bottom edges and/or swapping the left and right edges\n   |   invert: 'none' || 'negate' || 'reposition'\n   |\n   |   // limit multiple resizes.\n   |   // See the explanation in the @Interactable.draggable example\n   |   max: Infinity,\n   |   maxPerElement: 1,\n   | });\n  \\*/\nInteractable.prototype.resizable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.resize.enabled = options.enabled === false ? false : true;\n    this.setPerAction('resize', options);\n    this.setOnEvents('resize', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.resize.axis = options.axis;\n    } else if (options.axis === null) {\n      this.options.resize.axis = scope.defaultOptions.resize.axis;\n    }\n\n    if (utils.isBool(options.preserveAspectRatio)) {\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n    } else if (utils.isBool(options.square)) {\n      this.options.resize.square = options.square;\n    }\n\n    return this;\n  }\n  if (utils.isBool(options)) {\n    this.options.resize.enabled = options;\n\n    return this;\n  }\n  return this.options.resize;\n};\n\nfunction checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {\n  // false, '', undefined, null\n  if (!value) {\n    return false;\n  }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    var width = utils.isNumber(rect.width) ? rect.width : rect.right - rect.left;\n    var height = utils.isNumber(rect.height) ? rect.height : rect.bottom - rect.top;\n\n    if (width < 0) {\n      if (name === 'left') {\n        name = 'right';\n      } else if (name === 'right') {\n        name = 'left';\n      }\n    }\n    if (height < 0) {\n      if (name === 'top') {\n        name = 'bottom';\n      } else if (name === 'bottom') {\n        name = 'top';\n      }\n    }\n\n    if (name === 'left') {\n      return page.x < (width >= 0 ? rect.left : rect.right) + margin;\n    }\n    if (name === 'top') {\n      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\n    }\n\n    if (name === 'right') {\n      return page.x > (width >= 0 ? rect.right : rect.left) - margin;\n    }\n    if (name === 'bottom') {\n      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\n    }\n  }\n\n  // the remaining checks require an element\n  if (!utils.isElement(element)) {\n    return false;\n  }\n\n  return utils.isElement(value)\n  // the value is an element to use as a resize handle\n  ? value === element\n  // otherwise check if element matches value as selector\n  : utils.matchesUpTo(element, value, interactableElement);\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.resizeAxes = 'xy';\n});\n\nInteractEvent.signals.on('resize', function (_ref4) {\n  var interaction = _ref4.interaction;\n  var iEvent = _ref4.iEvent;\n\n  if (!interaction.resizeAxes) {\n    return;\n  }\n\n  var options = interaction.target.options;\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      iEvent.dx = iEvent.dy;\n    } else {\n      iEvent.dy = iEvent.dx;\n    }\n    iEvent.axes = 'xy';\n  } else {\n    iEvent.axes = interaction.resizeAxes;\n\n    if (interaction.resizeAxes === 'x') {\n      iEvent.dy = 0;\n    } else if (interaction.resizeAxes === 'y') {\n      iEvent.dx = 0;\n    }\n  }\n});\n\nactions.resize = resize;\nactions.names.push('resize');\nutils.merge(scope.eventTypes, ['resizestart', 'resizemove', 'resizeinertiastart', 'resizeend']);\nactions.methodDict.resize = 'resizable';\n\ndefaultOptions.resize = resize.defaults;\n\nmodule.exports = resize;\n\n},{\"../InteractEvent\":2,\"../Interactable\":3,\"../Interaction\":4,\"../defaultOptions\":14,\"../scope\":23,\"../utils\":33,\"../utils/browser\":26,\"./index\":8}],10:[function(require,module,exports){\nvar raf = require('./utils/raf');\nvar getWindow = require('./utils/window').getWindow;\nvar isWindow = require('./utils/isType').isWindow;\nvar domUtils = require('./utils/domUtils');\nvar Interaction = require('./Interaction');\nvar defaultOptions = require('./defaultOptions');\n\nvar autoScroll = {\n  defaults: {\n    enabled: false,\n    container: null, // the item that is scrolled (Window or HTMLElement)\n    margin: 60,\n    speed: 300 },\n\n  // the scroll speed in pixels per second\n  interaction: null,\n  i: null, // the handle returned by window.setInterval\n  x: 0, y: 0, // Direction each pulse is to scroll in\n\n  isScrolling: false,\n  prevTime: 0,\n\n  start: function (interaction) {\n    autoScroll.isScrolling = true;\n    raf.cancel(autoScroll.i);\n\n    autoScroll.interaction = interaction;\n    autoScroll.prevTime = new Date().getTime();\n    autoScroll.i = raf.request(autoScroll.scroll);\n  },\n\n  stop: function () {\n    autoScroll.isScrolling = false;\n    raf.cancel(autoScroll.i);\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll: function () {\n    var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n    var container = options.container || getWindow(autoScroll.interaction.element);\n    var now = new Date().getTime();\n    // change in time in seconds\n    var dt = (now - autoScroll.prevTime) / 1000;\n    // displacement\n    var s = options.speed * dt;\n\n    if (s >= 1) {\n      if (isWindow(container)) {\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n      } else if (container) {\n        container.scrollLeft += autoScroll.x * s;\n        container.scrollTop += autoScroll.y * s;\n      }\n\n      autoScroll.prevTime = now;\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i);\n      autoScroll.i = raf.request(autoScroll.scroll);\n    }\n  },\n  check: function (interactable, actionName) {\n    var options = interactable.options;\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n  },\n  onInteractionMove: function (_ref) {\n    var interaction = _ref.interaction;\n    var pointer = _ref.pointer;\n\n    if (!(interaction.interacting() && autoScroll.check(interaction.target, interaction.prepared.name))) {\n      return;\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0;\n      return;\n    }\n\n    var top = undefined;\n    var right = undefined;\n    var bottom = undefined;\n    var left = undefined;\n\n    var options = interaction.target.options[interaction.prepared.name].autoScroll;\n    var container = options.container || getWindow(interaction.element);\n\n    if (isWindow(container)) {\n      left = pointer.clientX < autoScroll.margin;\n      top = pointer.clientY < autoScroll.margin;\n      right = pointer.clientX > container.innerWidth - autoScroll.margin;\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n    } else {\n      var rect = domUtils.getElementClientRect(container);\n\n      left = pointer.clientX < rect.left + autoScroll.margin;\n      top = pointer.clientY < rect.top + autoScroll.margin;\n      right = pointer.clientX > rect.right - autoScroll.margin;\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n    }\n\n    autoScroll.x = right ? 1 : left ? -1 : 0;\n    autoScroll.y = bottom ? 1 : top ? -1 : 0;\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin;\n      autoScroll.speed = options.speed;\n\n      autoScroll.start(interaction);\n    }\n  }\n};\n\nInteraction.signals.on('stop-active', function () {\n  autoScroll.stop();\n});\n\nInteraction.signals.on('move-done', autoScroll.onInteractionMove);\n\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\n\nmodule.exports = autoScroll;\n\n},{\"./Interaction\":4,\"./defaultOptions\":14,\"./utils/domUtils\":28,\"./utils/isType\":35,\"./utils/raf\":38,\"./utils/window\":39}],11:[function(require,module,exports){\nvar autoStart = require('./index');\nvar Interaction = require('../Interaction');\nvar actions = require('../actions');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.delayTimer = null;\n});\n\nautoStart.signals.on('prepared', function (_ref2) {\n  var interaction = _ref2.interaction;\n\n  var actionName = interaction.prepared.name;\n\n  if (!actionName) {\n    return;\n  }\n\n  var delay = interaction.target.options[actionName].delay;\n\n  if (delay > 0) {\n    interaction.delayTimer = setTimeout(function () {\n      interaction.start(interaction.prepared, interaction.target, interaction.element);\n    }, delay);\n  }\n});\n\nfor (var _iterator = actions.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n  var _ref;\n\n  if (_isArray) {\n    if (_i >= _iterator.length) break;\n    _ref = _iterator[_i++];\n  } else {\n    _i = _iterator.next();\n    if (_i.done) break;\n    _ref = _i.value;\n  }\n\n  var action = _ref;\n\n  autoStart.signals.on('before-start-' + action, preventImmediateMove);\n}\n\nInteraction.signals.on('move-done', function (_ref3) {\n  var interaction = _ref3.interaction;\n\n  if (interaction.pointerWasMoved) {\n    clearTimeout(interaction.delayTimer);\n  }\n});\n\nfunction preventImmediateMove(_ref4) {\n  var interaction = _ref4.interaction;\n\n  var actionName = interaction.prepared.name;\n\n  if (!actionName) {\n    return;\n  }\n\n  var delay = interaction.target.options[actionName].delay;\n\n  if (delay > 0) {\n    interaction.prepared.name = null;\n  }\n}\n\n},{\"../Interaction\":4,\"../actions\":8,\"./index\":13}],12:[function(require,module,exports){\nvar autoStart = require('./index');\nvar scope = require('../scope');\nvar browser = require('../utils/browser');\n\nvar _require = require('../utils/isType');\n\nvar isElement = _require.isElement;\n\nvar _require2 = require('../utils/domUtils');\n\nvar matchesSelector = _require2.matchesSelector;\nvar parentElement = _require2.parentElement;\n\nautoStart.signals.on('before-start-drag', function (_ref) {\n  var interaction = _ref.interaction;\n  var eventTarget = _ref.eventTarget;\n  var dx = _ref.dx;\n  var dy = _ref.dy;\n\n  // check if a drag is in the correct axis\n  var absX = Math.abs(dx);\n  var absY = Math.abs(dy);\n  var dragOptions = interaction.target.options.drag;\n  var startAxis = dragOptions.startAxis;\n  var currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';\n\n  interaction.prepared.axis = dragOptions.lockAxis === 'start' ? currentAxis : dragOptions.lockAxis;\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    interaction.prepared.name = null;\n\n    // then try to get a drag from another ineractable\n\n    if (!interaction.prepared.name) {\n      (function () {\n\n        var element = eventTarget;\n\n        var getDraggable = function (interactable, selector, context) {\n          var elements = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n          if (interactable === interaction.target) {\n            return;\n          }\n\n          var action = null;\n\n          if (scope.inContext(interactable, eventTarget) && !interactable.options.drag.manualStart && !scope.testIgnore(interactable, element, eventTarget) && scope.testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, elements)) {\n\n            action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n          }\n          if (action && action.name === 'drag' && checkStartAxis(currentAxis, interactable) && scope.withinInteractionLimit(interactable, element, { name: 'drag' })) {\n\n            return interactable;\n          }\n        };\n\n        var action = null;\n\n        // check all interactables\n        while (isElement(element)) {\n          var elementInteractable = scope.interactables.get(element);\n\n          if (elementInteractable && elementInteractable !== interaction.target && !elementInteractable.options.drag.manualStart) {\n\n            action = elementInteractable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n          }\n          if (action && action.name === 'drag' && checkStartAxis(currentAxis, elementInteractable)) {\n\n            interaction.prepared.name = 'drag';\n            interaction.target = elementInteractable;\n            interaction.element = element;\n            break;\n          }\n\n          var selectorInteractable = scope.interactables.forEachSelector(getDraggable);\n\n          if (selectorInteractable) {\n            interaction.prepared.name = 'drag';\n            interaction.target = selectorInteractable;\n            interaction.element = element;\n            break;\n          }\n\n          element = parentElement(element);\n        }\n      })();\n    }\n  }\n});\n\nfunction checkStartAxis(startAxis, interactable) {\n  if (!interactable) {\n    return false;\n  }\n\n  var thisAxis = interactable.options.drag.startAxis;\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis;\n}\n\n},{\"../scope\":23,\"../utils/browser\":26,\"../utils/domUtils\":28,\"../utils/isType\":35,\"./index\":13}],13:[function(require,module,exports){\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar actions = require('../actions');\nvar defaultOptions = require('../defaultOptions');\nvar browser = require('../utils/browser');\nvar scope = require('../scope');\nvar utils = require('../utils');\nvar signals = require('../utils/Signals')['new']();\n\n// mouse move cursor style\nInteraction.signals.on('move', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var pointer = _ref2.pointer;\n  var event = _ref2.event;\n  var eventTarget = _ref2.eventTarget;\n\n  if (!interaction.mouse || interaction.pointerIsDown) {\n    return;\n  }\n\n  var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\nInteraction.signals.on('down', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var pointer = _ref3.pointer;\n  var event = _ref3.event;\n  var eventTarget = _ref3.eventTarget;\n\n  if (interaction.interacting()) {\n    return;\n  }\n\n  var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\nInteraction.signals.on('move', function (arg) {\n  var interaction = arg.interaction;\n  var event = arg.event;\n\n  if (!(interaction.pointerIsDown && interaction.pointerWasMoved && interaction.prepared.name)) {\n    return;\n  }\n\n  // ignore movement while simulation is active\n  if (!interaction.simulation) {\n\n    // if just starting an action, calculate the pointer speed now\n    if (!interaction.interacting()) {\n      utils.setEventDeltas(interaction.pointerDelta, interaction.prevCoords, interaction.curCoords);\n\n      signals.fire('before-start-' + interaction.prepared.name, arg);\n    }\n\n    var starting = !!interaction.prepared.name && !interaction.interacting();\n\n    if (starting && (interaction.target.options[interaction.prepared.name].manualStart || !scope.withinInteractionLimit(interaction.target, interaction.element, interaction.prepared))) {\n      interaction.stop(event);\n      return;\n    }\n\n    if (interaction.prepared.name && interaction.target) {\n      if (starting) {\n        interaction.start(interaction.prepared, interaction.target, interaction.element);\n      }\n    }\n  }\n});\n\nfunction validateSelector(interaction, pointer, event, matches, matchElements) {\n  for (var i = 0, len = matches.length; i < len; i++) {\n    var match = matches[i];\n    var matchElement = matchElements[i];\n    var action = Interaction.validateAction(match.getAction(pointer, event, interaction, matchElement), match);\n\n    if (action && scope.withinInteractionLimit(match, matchElement, action)) {\n      return {\n        action: action,\n        target: match,\n        element: matchElement\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getActionInfo(interaction, pointer, event, eventTarget) {\n  var matches = [];\n  var matchElements = [];\n\n  var element = eventTarget;\n  var action = null;\n\n  function pushMatches(interactable, selector, context) {\n    var elements = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n    if (scope.inContext(interactable, element) && !scope.testIgnore(interactable, element, eventTarget) && scope.testAllow(interactable, element, eventTarget) && utils.matchesSelector(element, selector, elements)) {\n\n      matches.push(interactable);\n      matchElements.push(element);\n    }\n  }\n\n  while (utils.isElement(element)) {\n    matches = [];\n    matchElements = [];\n\n    var elementInteractable = scope.interactables.get(element);\n\n    if (elementInteractable && (action = Interaction.validateAction(elementInteractable.getAction(pointer, event, interaction, element), elementInteractable))) {\n      return {\n        element: element,\n        action: action,\n        target: elementInteractable\n      };\n    } else {\n      scope.interactables.forEachSelector(pushMatches);\n\n      var actionInfo = validateSelector(interaction, pointer, event, matches, matchElements);\n\n      if (actionInfo.action) {\n        return actionInfo;\n      }\n    }\n\n    element = utils.parentElement(element);\n  }\n\n  return {};\n}\n\nfunction prepare(interaction, _ref4) {\n  var action = _ref4.action;\n  var target = _ref4.target;\n  var element = _ref4.element;\n\n  action = action || {};\n\n  if (interaction.target && interaction.target.options.styleCursor) {\n    interaction.target._doc.documentElement.style.cursor = '';\n  }\n\n  interaction.target = target;\n  interaction.element = element;\n  utils.copyAction(interaction.prepared, action);\n\n  if (target && target.options.styleCursor) {\n    var cursor = action ? actions[action.name].getCursor(action) : '';\n    interaction.target._doc.documentElement.style.cursor = cursor;\n  }\n\n  interaction.setEventXY(interaction.startCoords, interaction.pointers);\n\n  signals.fire('prepared', { interaction: interaction });\n}\n\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\n  var action = this.defaultActionChecker(pointer, event, interaction, element);\n\n  if (this.options.actionChecker) {\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\n  }\n\n  return action;\n};\n\n/*\\\n * Interactable.actionChecker\n [ method ]\n *\n * Gets or sets the function used to check action to be performed on\n * pointerDown\n *\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n = (Function | Interactable) The checker function or this Interactable\n *\n | interact('.resize-drag')\n |   .resizable(true)\n |   .draggable(true)\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n |\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\n |     // force drag with handle target\n |     action.name = drag;\n |   }\n |   else {\n |     // resize from the top and right edges\n |     action.name  = 'resize';\n |     action.edges = { top: true, right: true };\n |   }\n |\n |   return action;\n | });\n\\*/\nInteractable.prototype.actionChecker = function (checker) {\n  if (utils.isFunction(checker)) {\n    this.options.actionChecker = checker;\n\n    return this;\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker;\n\n    return this;\n  }\n\n  return this.options.actionChecker;\n};\n\n/*\\\n * Interactable.styleCursor\n [ method ]\n *\n * Returns or sets whether the the cursor should be changed depending on the\n * action that would be performed if the mouse were pressed and dragged.\n *\n - newValue (boolean) #optional\n = (boolean | Interactable) The current setting or this Interactable\n\\*/\nInteractable.prototype.styleCursor = function (newValue) {\n  if (utils.isBool(newValue)) {\n    this.options.styleCursor = newValue;\n\n    return this;\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor;\n\n    return this;\n  }\n\n  return this.options.styleCursor;\n};\n\n/*\\\n * Interactable.ignoreFrom\n [ method ]\n *\n * If the target of the `mousedown`, `pointerdown` or `touchstart`\n * event or any of it's parents match the given CSS selector or\n * Element, no drag/resize/gesture is started.\n *\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n = (string | Element | object) The current ignoreFrom value or this Interactable\n **\n | interact(element, { ignoreFrom: document.getElementById('no-action') });\n | // or\n | interact(element).ignoreFrom('input, textarea, a');\n\\*/\nInteractable.prototype.ignoreFrom = function (newValue) {\n  if (utils.trySelector(newValue)) {\n    // CSS selector to match event.target\n    this.options.ignoreFrom = newValue;\n    return this;\n  }\n\n  if (utils.isElement(newValue)) {\n    // specific element\n    this.options.ignoreFrom = newValue;\n    return this;\n  }\n\n  return this.options.ignoreFrom;\n};\n\n/*\\\n * Interactable.allowFrom\n [ method ]\n *\n * A drag/resize/gesture is started only If the target of the\n * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n * parents match the given CSS selector or Element.\n *\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n = (string | Element | object) The current allowFrom value or this Interactable\n **\n | interact(element, { allowFrom: document.getElementById('drag-handle') });\n | // or\n | interact(element).allowFrom('.handle');\n\\*/\nInteractable.prototype.allowFrom = function (newValue) {\n  if (utils.trySelector(newValue)) {\n    // CSS selector to match event.target\n    this.options.allowFrom = newValue;\n    return this;\n  }\n\n  if (utils.isElement(newValue)) {\n    // specific element\n    this.options.allowFrom = newValue;\n    return this;\n  }\n\n  return this.options.allowFrom;\n};\n\nInteraction.signals.on('stop-active', function (_ref5) {\n  var interaction = _ref5.interaction;\n\n  var target = interaction.target;\n\n  if (target.options.styleCursor) {\n    target._doc.documentElement.style.cursor = '';\n  }\n});\n\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n  var rect = this.getRect(element);\n  var action = null;\n\n  for (var _iterator = actions.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var actionName = _ref;\n\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n    if (action) {\n      return action;\n    }\n  }\n};\n\nInteractable.settingsMethods.push('styleCursor');\nInteractable.settingsMethods.push('actionChecker');\nInteractable.settingsMethods.push('ignoreFrom');\nInteractable.settingsMethods.push('allowFrom');\n\ndefaultOptions.base.actionChecker = null;\ndefaultOptions.base.ignoreFrom = null;\ndefaultOptions.base.allowFrom = null;\ndefaultOptions.base.styleCursor = true;\ndefaultOptions.perAction.manualStart = false;\n\nmodule.exports = { signals: signals };\n\n},{\"../Interactable\":3,\"../Interaction\":4,\"../actions\":8,\"../defaultOptions\":14,\"../scope\":23,\"../utils\":33,\"../utils/Signals\":24,\"../utils/browser\":26}],14:[function(require,module,exports){\nmodule.exports = {\n  base: {\n    accept: null,\n    preventDefault: 'auto',\n    origin: { x: 0, y: 0 },\n    deltaSource: 'page',\n    allowFrom: null\n  },\n\n  perAction: {\n    max: Infinity,\n    maxPerElement: 1,\n\n    inertia: {\n      enabled: false,\n      resistance: 10, // the lambda in exponential decay\n      minSpeed: 100, // target speed must be above this for inertia to start\n      endSpeed: 10, // the speed at which inertia is slow enough to stop\n      allowResume: true, // allow resuming an action in inertia phase\n      zeroResumeDelta: true, // if an action is resumed after launch, set dx/dy to 0\n      smoothEndDuration: 300 }\n  },\n\n  // animate to snap/restrict endOnly if there's no inertia\n  _holdDuration: 600\n};\n\n},{}],15:[function(require,module,exports){\n/* browser entry point */\n\n// Interaction\nrequire('./Interaction');\n\n// Legacy browser support\nrequire('./legacyBrowsers');\n\n// pointerEvents\nrequire('./pointerEvents');\n\n// inertia\nrequire('./inertia');\n\n// modifiers\nrequire('./modifiers/snap');\nrequire('./modifiers/restrict');\n\n// actions\nrequire('./actions/gesture');\nrequire('./actions/resize');\nrequire('./actions/drag');\nrequire('./actions/drop');\n\n// autoScroll\nrequire('./autoScroll');\n\n// autoStart\nrequire('./autoStart');\nrequire('./autoStart/drag');\nrequire('./autoStart/delay');\n\n// export interact\nmodule.exports = require('./interact');\n\n},{\"./Interaction\":4,\"./actions/drag\":5,\"./actions/drop\":6,\"./actions/gesture\":7,\"./actions/resize\":9,\"./autoScroll\":10,\"./autoStart\":13,\"./autoStart/delay\":11,\"./autoStart/drag\":12,\"./inertia\":16,\"./interact\":17,\"./legacyBrowsers\":18,\"./modifiers/restrict\":20,\"./modifiers/snap\":21,\"./pointerEvents\":22}],16:[function(require,module,exports){\nvar InteractEvent = require('./InteractEvent');\nvar Interaction = require('./Interaction');\nvar modifiers = require('./modifiers');\nvar utils = require('./utils');\nvar animationFrame = utils.raf;\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.inertiaStatus = {\n    active: false,\n    smoothEnd: false,\n    allowResume: false,\n    resumed: false,\n    ending: false,\n\n    startEvent: null,\n    upCoords: {},\n\n    xe: 0, ye: 0,\n    sx: 0, sy: 0,\n\n    t0: 0,\n    vx0: 0, vys: 0,\n    duration: 0,\n\n    resumeDx: 0,\n    resumeDy: 0,\n\n    lambda_v0: 0,\n    one_ve_v0: 0,\n    i: null\n  };\n\n  interaction.boundInertiaFrame = function () {\n    return inertiaFrame.apply(interaction);\n  };\n  interaction.boundSmoothEndFrame = function () {\n    return smoothEndFrame.apply(interaction);\n  };\n});\n\nInteraction.signals.on('down', function (_ref) {\n  var interaction = _ref.interaction;\n  var eventTarget = _ref.eventTarget;\n\n  var status = interaction.inertiaStatus;\n\n  // Check if the down event hits the current inertia target\n  if (status.active) {\n    var element = eventTarget;\n\n    // climb up the DOM tree from the event target\n    while (utils.isElement(element)) {\n\n      // if interaction element is the current inertia target element\n      if (element === interaction.element) {\n\n        // stop inertia so that the next move will be a normal one\n        animationFrame.cancel(status.i);\n        status.active = false;\n        status.resumed = true;\n        interaction.simulation = null;\n\n        break;\n      }\n      element = utils.parentElement(element);\n    }\n  }\n});\n\nInteraction.signals.on('up', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  var status = interaction.inertiaStatus;\n\n  if (!interaction.interacting() || status.active) {\n    return;\n  }\n\n  var target = interaction.target;\n  var options = target && target.options;\n  var inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\n\n  var now = new Date().getTime();\n  var statuses = {};\n  var page = utils.extend({}, interaction.curCoords.page);\n  var pointerSpeed = interaction.pointerDelta.client.speed;\n  var inertiaPossible = false;\n  var inertia = false;\n  var smoothEnd = false;\n  var modifierResult = undefined;\n\n  // check if inertia should be started\n  inertiaPossible = inertiaOptions && inertiaOptions.enabled && interaction.prepared.name !== 'gesture' && event !== status.startEvent;\n\n  inertia = inertiaPossible && now - interaction.curCoords.timeStamp < 50 && pointerSpeed > inertiaOptions.minSpeed && pointerSpeed > inertiaOptions.endSpeed;\n\n  // smoothEnd\n  if (inertiaPossible && !inertia) {\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(interaction, page, statuses, true);\n\n    if (modifierResult.shouldMove && modifierResult.locked) {\n      smoothEnd = true;\n    }\n  }\n\n  if (!(inertia || smoothEnd)) {\n    return;\n  }\n\n  utils.copyCoords(status.upCoords, interaction.curCoords);\n\n  interaction.pointers[0] = status.startEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\n\n  status.t0 = now;\n\n  status.active = true;\n  status.allowResume = inertiaOptions.allowResume;\n  interaction.simulation = status;\n\n  target.fire(status.startEvent);\n\n  if (inertia) {\n    status.vx0 = interaction.pointerDelta.client.vx;\n    status.vy0 = interaction.pointerDelta.client.vy;\n    status.v0 = pointerSpeed;\n\n    calcInertia(interaction, status);\n\n    utils.extend(page, interaction.curCoords.page);\n\n    page.x += status.xe;\n    page.y += status.ye;\n\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(interaction, page, statuses, true, true);\n\n    status.modifiedXe += modifierResult.dx;\n    status.modifiedYe += modifierResult.dy;\n\n    status.i = animationFrame.request(interaction.boundInertiaFrame);\n  } else {\n    status.smoothEnd = true;\n    status.xe = modifierResult.dx;\n    status.ye = modifierResult.dy;\n\n    status.sx = status.sy = 0;\n\n    status.i = animationFrame.request(interaction.boundSmoothEndFrame);\n  }\n});\n\nInteraction.signals.on('stop-active', function (_ref3) {\n  var interaction = _ref3.interaction;\n\n  var status = interaction.inertiaStatus;\n\n  if (status.active) {\n    status.resumeDx = status.resumeDy = 0;\n    animationFrame.cancel(status.i);\n    status.active = status.ending = false;\n    interaction.simulation = null;\n  }\n});\n\nInteractEvent.signals.on('set-delta', function (_ref4) {\n  var iEvent = _ref4.iEvent;\n  var phase = _ref4.phase;\n  var interaction = _ref4.interaction;\n  var actionName = _ref4.action;\n\n  var status = interaction.inertiaStatus;\n\n  if (!status.active) {\n    return;\n  }\n\n  // copy properties from previousmove if starting inertia\n  if (phase === 'inertiastart') {\n    iEvent.dx = interaction.prevEvent.dx;\n    iEvent.dy = interaction.prevEvent.dy;\n  }\n\n  iEvent.detail = 'inertia';\n\n  if (status.resumed) {\n    var inertiaOptions = interaction.target.options[actionName].inertia;\n\n    if (inertiaOptions.zeroResumeDelta) {\n      status.resumeDx += iEvent.dx;\n      status.resumeDy += iEvent.dy;\n\n      iEvent.dx = iEvent.dy = 0;\n    }\n  }\n});\n\nfunction calcInertia(interaction, status) {\n  var inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\n  var lambda = inertiaOptions.resistance;\n  var inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n  status.x0 = interaction.prevEvent.pageX;\n  status.y0 = interaction.prevEvent.pageY;\n  status.t0 = status.startEvent.timeStamp / 1000;\n  status.sx = status.sy = 0;\n\n  status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n  status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n  status.te = inertiaDur;\n\n  status.lambda_v0 = lambda / status.v0;\n  status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n}\n\nfunction inertiaFrame() {\n  updateInertiaCoords(this);\n  utils.setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n  var status = this.inertiaStatus;\n  var options = this.target.options[this.prepared.name].inertia;\n  var lambda = options.resistance;\n  var t = new Date().getTime() / 1000 - status.t0;\n\n  if (t < status.te) {\n\n    var progress = 1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\n\n    if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\n      status.sx = status.xe * progress;\n      status.sy = status.ye * progress;\n    } else {\n      var quadPoint = utils.getQuadraticCurvePoint(0, 0, status.xe, status.ye, status.modifiedXe, status.modifiedYe, progress);\n\n      status.sx = quadPoint.x;\n      status.sy = quadPoint.y;\n    }\n\n    this.doMove();\n\n    status.i = animationFrame.request(this.boundInertiaFrame);\n  } else {\n    status.ending = true;\n\n    status.sx = status.modifiedXe;\n    status.sy = status.modifiedYe;\n\n    this.doMove();\n    this.end(status.startEvent);\n    status.active = status.ending = false;\n    this.simulation = null;\n  }\n\n  utils.copyCoords(this.prevCoords, this.curCoords);\n}\n\nfunction smoothEndFrame() {\n  updateInertiaCoords(this);\n\n  var status = this.inertiaStatus;\n  var t = new Date().getTime() - status.t0;\n  var duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n  if (t < duration) {\n    status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\n    status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\n\n    this.pointerMove(status.startEvent, status.startEvent);\n\n    status.i = animationFrame.request(this.boundSmoothEndFrame);\n  } else {\n    status.ending = true;\n\n    status.sx = status.xe;\n    status.sy = status.ye;\n\n    this.pointerMove(status.startEvent, status.startEvent);\n    this.end(status.startEvent);\n\n    status.smoothEnd = status.active = status.ending = false;\n    this.simulation = null;\n  }\n}\n\nfunction updateInertiaCoords(interaction) {\n  var status = interaction.inertiaStatus;\n\n  // return if inertia isn't running\n  if (!status.active) {\n    return;\n  }\n\n  var pageUp = status.upCoords.page;\n  var clientUp = status.upCoords.client;\n\n  interaction.setEventXY(interaction.curCoords, [{\n    pageX: pageUp.x + status.sx,\n    pageY: pageUp.y + status.sy,\n    clientX: clientUp.x + status.sx,\n    clientY: clientUp.y + status.sy\n  }]);\n}\n\n},{\"./InteractEvent\":2,\"./Interaction\":4,\"./modifiers\":19,\"./utils\":33}],17:[function(require,module,exports){\n/**\n * interact.js v1.2.5\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n\nvar browser = require('./utils/browser');\nvar events = require('./utils/events');\nvar utils = require('./utils');\nvar scope = require('./scope');\nvar Interactable = require('./Interactable');\n\nscope.dynamicDrop = false;\n\n// Less Precision with touch input\nscope.margin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;\n\nscope.pointerMoveTolerance = 1;\n\n// Allow this many interactions to happen simultaneously\nscope.maxInteractions = Infinity;\n\n// because Webkit and Opera still use 'mousewheel' event type\nscope.wheelEvent = 'onmousewheel' in scope.document ? 'mousewheel' : 'wheel';\n\nscope.globalEvents = {};\n\nscope.inContext = function (interactable, element) {\n  return interactable._context === element.ownerDocument || utils.nodeContains(interactable._context, element);\n};\n\nscope.testIgnore = function (interactable, interactableElement, element) {\n  var ignoreFrom = interactable.options.ignoreFrom;\n\n  if (!ignoreFrom || !utils.isElement(element)) {\n    return false;\n  }\n\n  if (utils.isString(ignoreFrom)) {\n    return utils.matchesUpTo(element, ignoreFrom, interactableElement);\n  } else if (utils.isElement(ignoreFrom)) {\n    return utils.nodeContains(ignoreFrom, element);\n  }\n\n  return false;\n};\n\nscope.testAllow = function (interactable, interactableElement, element) {\n  var allowFrom = interactable.options.allowFrom;\n\n  if (!allowFrom) {\n    return true;\n  }\n\n  if (!utils.isElement(element)) {\n    return false;\n  }\n\n  if (utils.isString(allowFrom)) {\n    return utils.matchesUpTo(element, allowFrom, interactableElement);\n  } else if (utils.isElement(allowFrom)) {\n    return utils.nodeContains(allowFrom, element);\n  }\n\n  return false;\n};\n\nscope.interactables.indexOfElement = function indexOfElement(target, context) {\n  context = context || scope.document;\n\n  for (var i = 0; i < this.length; i++) {\n    var interactable = this[i];\n\n    if (interactable.target === target && (!utils.isString(target) || interactable._context === context)) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nscope.interactables.get = function interactableGet(element, options) {\n  return this[this.indexOfElement(element, options && options.context)];\n};\n\nscope.interactables.forEachSelector = function (callback) {\n  for (var i = 0; i < this.length; i++) {\n    var interactable = this[i];\n\n    // skip non CSS selector targets\n    if (!utils.isString(interactable.target)) {\n      continue;\n    }\n\n    var ret = callback(interactable, interactable.target, interactable._context, i, this);\n\n    if (ret !== undefined) {\n      return ret;\n    }\n  }\n};\n\n/*\\\n * interact\n [ method ]\n *\n * The methods of this variable can be used to set elements as\n * interactables and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to\n * configure it.\n *\n - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n = (object) An @Interactable\n *\n > Usage\n | interact(document.getElementById('draggable')).draggable(true);\n |\n | var rectables = interact('rect');\n | rectables\n |     .gesturable(true)\n |     .on('gesturemove', function (event) {\n |         // something cool...\n |     })\n |     .autoScroll(true);\n\\*/\nfunction interact(element, options) {\n  return scope.interactables.get(element, options) || new Interactable(element, options);\n}\n\n/*\\\n * interact.isSet\n [ method ]\n *\n * Check if an element has been set\n - element (Element) The Element being searched for\n = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\\*/\ninteract.isSet = function (element, options) {\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n};\n\n/*\\\n * interact.on\n [ method ]\n *\n * Adds a global listener for an InteractEvent or adds a DOM event to\n * `document`\n *\n - type       (string | array | object) The types of events to listen for\n - listener   (function) The function event (s)\n - useCapture (boolean) #optional useCapture flag for addEventListener\n = (object) interact\n\\*/\ninteract.on = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (var _iterator = type, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var eventType = _ref;\n\n      interact.on(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (var prop in type) {\n      interact.on(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.contains(scope.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!scope.globalEvents[type]) {\n      scope.globalEvents[type] = [listener];\n    } else {\n      scope.globalEvents[type].push(listener);\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n      events.add(scope.document, type, listener, useCapture);\n    }\n\n  return interact;\n};\n\n/*\\\n * interact.off\n [ method ]\n *\n * Removes a global InteractEvent listener or DOM event from `document`\n *\n - type       (string | array | object) The types of events that were listened for\n - listener   (function) The listener function to be removed\n - useCapture (boolean) #optional useCapture flag for removeEventListener\n = (object) interact\n \\*/\ninteract.off = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (var _iterator2 = type, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var eventType = _ref2;\n\n      interact.off(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (var prop in type) {\n      interact.off(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  if (!utils.contains(scope.eventTypes, type)) {\n    events.remove(scope.document, type, listener, useCapture);\n  } else {\n    var index = undefined;\n\n    if (type in scope.globalEvents && (index = utils.indexOf(scope.globalEvents[type], listener)) !== -1) {\n      scope.globalEvents[type].splice(index, 1);\n    }\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.debug\n [ method ]\n *\n * Returns an object which exposes internal data\n = (object) An object with properties that outline the current state and expose internal functions and variables\n\\*/\ninteract.debug = function () {\n  return scope;\n};\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage = utils.pointerAverage;\ninteract.getTouchBBox = utils.touchBBox;\ninteract.getTouchDistance = utils.touchDistance;\ninteract.getTouchAngle = utils.touchAngle;\n\ninteract.getElementRect = utils.getElementRect;\ninteract.getElementClientRect = utils.getElementClientRect;\ninteract.matchesSelector = utils.matchesSelector;\ninteract.closest = utils.closest;\n\n/*\\\n * interact.supportsTouch\n [ method ]\n *\n = (boolean) Whether or not the browser supports touch input\n\\*/\ninteract.supportsTouch = function () {\n  return browser.supportsTouch;\n};\n\n/*\\\n * interact.supportsPointerEvent\n [ method ]\n *\n = (boolean) Whether or not the browser supports PointerEvents\n\\*/\ninteract.supportsPointerEvent = function () {\n  return browser.supportsPointerEvent;\n};\n\n/*\\\n * interact.stop\n [ method ]\n *\n * Cancels all interactions (end events are not fired)\n *\n - event (Event) An event on which to call preventDefault()\n = (object) interact\n\\*/\ninteract.stop = function (event) {\n  for (var i = scope.interactions.length - 1; i >= 0; i--) {\n    scope.interactions[i].stop(event);\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.dynamicDrop\n [ method ]\n *\n * Returns or sets whether the dimensions of dropzone elements are\n * calculated on every dragmove or only on dragstart for the default\n * dropChecker\n *\n - newValue (boolean) #optional True to check on each move. False to check only before start\n = (boolean | interact) The current setting or interact\n\\*/\ninteract.dynamicDrop = function (newValue) {\n  if (utils.isBool(newValue)) {\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\n    //calcRects(dropzones);\n    //}\n\n    scope.dynamicDrop = newValue;\n\n    return interact;\n  }\n  return scope.dynamicDrop;\n};\n\n/*\\\n * interact.pointerMoveTolerance\n [ method ]\n * Returns or sets the distance the pointer must be moved before an action\n * sequence occurs. This also affects tolerance for tap events.\n *\n - newValue (number) #optional The movement from the start position must be greater than this value\n = (number | Interactable) The current setting or interact\n\\*/\ninteract.pointerMoveTolerance = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    scope.pointerMoveTolerance = newValue;\n\n    return this;\n  }\n\n  return scope.pointerMoveTolerance;\n};\n\n/*\\\n * interact.maxInteractions\n [ method ]\n **\n * Returns or sets the maximum number of concurrent interactions allowed.\n * By default only 1 interaction is allowed at a time (for backwards\n * compatibility). To allow multiple interactions on the same Interactables\n * and elements, you need to enable it in the draggable, resizable and\n * gesturable `'max'` and `'maxPerElement'` options.\n **\n - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\\*/\ninteract.maxInteractions = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    scope.maxInteractions = newValue;\n\n    return this;\n  }\n\n  return scope.maxInteractions;\n};\n\nscope.interact = interact;\n\nmodule.exports = interact;\n\n},{\"./Interactable\":3,\"./scope\":23,\"./utils\":33,\"./utils/browser\":26,\"./utils/events\":29}],18:[function(require,module,exports){\nvar scope = require('./scope');\nvar events = require('./utils/events');\nvar browser = require('./utils/browser');\nvar iFinder = require('./utils/interactionFinder');\n\nvar toString = Object.prototype.toString;\n\nif (!window.Array.isArray) {\n  window.Array.isArray = function (obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n\n// http://www.quirksmode.org/dom/events/click.html\n// >Events leading to dblclick\n//\n// IE8 doesn't fire down event before dblclick.\n// This workaround tries to fire a tap and doubletap after dblclick\nfunction onIE8Dblclick(event) {\n  var interaction = iFinder.search(event, event.type, event.target);\n\n  if (!interaction) {\n    return;\n  }\n\n  if (interaction.prevTap && event.clientX === interaction.prevTap.clientX && event.clientY === interaction.prevTap.clientY && event.target === interaction.prevTap.target) {\n\n    interaction.downTargets[0] = event.target;\n    interaction.downTimes[0] = new Date().getTime();\n\n    scope.pointerEvents.collectEventTargets(interaction, event, event, event.target, 'tap');\n  }\n}\n\nif (browser.isIE8) {\n  scope.signals.on('listen-to-document', function (_ref2) {\n    var doc = _ref2.doc;\n\n    // For IE's lack of Event#preventDefault\n    events.add(doc, 'selectstart', function (event) {\n      for (var _iterator = scope.interactions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var interaction = _ref;\n\n        if (interaction.interacting()) {\n          interaction.checkAndPreventDefault(event);\n        }\n      }\n    });\n\n    if (scope.pointerEvents) {\n      events.add(doc, 'dblclick', onIE8Dblclick);\n    }\n  });\n}\n\nmodule.exports = null;\n\n},{\"./scope\":23,\"./utils/browser\":26,\"./utils/events\":29,\"./utils/interactionFinder\":34}],19:[function(require,module,exports){\nvar InteractEvent = require('../InteractEvent');\nvar Interaction = require('../Interaction');\nvar extend = require('../utils/extend');\n\nvar modifiers = {\n  names: [],\n\n  setStartOffsets: function (interaction) {\n    var target = interaction.target;\n    var element = interaction.element;\n\n    var rect = target.getRect(element);\n\n    if (rect) {\n      interaction.startOffset.left = interaction.startCoords.page.x - rect.left;\n      interaction.startOffset.top = interaction.startCoords.page.y - rect.top;\n\n      interaction.startOffset.right = rect.right - interaction.startCoords.page.x;\n      interaction.startOffset.bottom = rect.bottom - interaction.startCoords.page.y;\n\n      if (!('width' in rect)) {\n        rect.width = rect.right - rect.left;\n      }\n      if (!('height' in rect)) {\n        rect.height = rect.bottom - rect.top;\n      }\n    } else {\n      interaction.startOffset.left = interaction.startOffset.top = interaction.startOffset.right = interaction.startOffset.bottom = 0;\n    }\n\n    modifiers.setOffsets(interaction, target, element, rect, interaction.modifierOffsets);\n  },\n\n  setOffsets: function (interaction, interactable, element, rect, offsets) {\n    for (var i = 0; i < modifiers.names.length; i++) {\n      var modifierName = modifiers.names[i];\n\n      offsets[modifierName] = modifiers[modifiers.names[i]].setOffset(interaction, interactable, element, rect, interaction.startOffset);\n    }\n  },\n\n  setAll: function (interaction, coordsArg, statuses, preEnd, requireEndOnly) {\n    var result = {\n      dx: 0,\n      dy: 0,\n      changed: false,\n      locked: false,\n      shouldMove: true\n    };\n    var target = interaction.target;\n    var coords = extend({}, coordsArg);\n\n    var currentStatus = undefined;\n\n    for (var _iterator = modifiers.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var modifierName = _ref;\n\n      var modifier = modifiers[modifierName];\n\n      if (!modifier.shouldDo(target, interaction.prepared.name, preEnd, requireEndOnly)) {\n        continue;\n      }\n\n      currentStatus = modifier.set(coords, interaction, statuses[modifierName]);\n\n      if (currentStatus.locked) {\n        coords.x += currentStatus.dx;\n        coords.y += currentStatus.dy;\n\n        result.dx += currentStatus.dx;\n        result.dy += currentStatus.dy;\n\n        result.locked = true;\n      }\n    }\n\n    // a move should be fired if the modified coords of\n    // the last modifier status that was calculated changes\n    result.shouldMove = !currentStatus || currentStatus.changed;\n\n    return result;\n  },\n\n  resetStatuses: function (statuses) {\n    for (var _iterator2 = modifiers.names, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var modifierName = _ref2;\n\n      statuses[modifierName] = modifiers[modifierName].reset(statuses[modifierName] || {});\n    }\n\n    return statuses;\n  }\n};\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.startOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n  interaction.modifierOffsets = {};\n  interaction.modifierStatuses = modifiers.resetStatuses({});\n});\n\nInteraction.signals.on('start', function (_ref3) {\n  var interaction = _ref3.interaction;\n\n  modifiers.setStartOffsets(interaction);\n\n  modifiers.resetStatuses(interaction.modifierStatuses);\n  modifiers.setAll(interaction, interaction.startCoords.page, interaction.modifierStatuses);\n});\n\nInteraction.signals.on('before-action-move', function (_ref4) {\n  var interaction = _ref4.interaction;\n  var preEnd = _ref4.preEnd;\n  var interactingBeforeMove = _ref4.interactingBeforeMove;\n\n  var modifierResult = modifiers.setAll(interaction, interaction.curCoords.page, interaction.modifierStatuses, preEnd);\n\n  // don't fire an action move if a modifier would keep the event in the same\n  // cordinates as before\n  if (!modifierResult.shouldMove && interactingBeforeMove) {\n    interaction._dontFireMove = true;\n  }\n});\n\nInteraction.signals.on('action-end', function (_ref5) {\n  var interaction = _ref5.interaction;\n\n  for (var i = 0; i < modifiers.names.length; i++) {\n    // if the endOnly option is true for any modifier\n    if (modifiers[modifiers.names[i]].shouldDo(interaction.target, interaction.prepared.name, true, true)) {\n      // fire a move event at the modified coordinates\n      interaction.doMove({ preEnd: true });\n      break;\n    }\n  }\n});\n\nInteractEvent.signals.on('set-xy', function (_ref6) {\n  var iEvent = _ref6.iEvent;\n  var interaction = _ref6.interaction;\n  var page = _ref6.page;\n  var client = _ref6.client;\n  var phase = _ref6.phase;\n  var actionName = _ref6.action;\n\n  var target = interaction.target;\n\n  for (var i = 0; i < modifiers.names.length; i++) {\n    var modifierName = modifiers.names[i];\n    var modifier = modifiers[modifierName];\n\n    iEvent[modifierName] = modifier.modifyCoords(page, client, target, interaction.modifierStatuses[modifierName], actionName, phase);\n  }\n});\n\nmodule.exports = modifiers;\n\n},{\"../InteractEvent\":2,\"../Interaction\":4,\"../utils/extend\":30}],20:[function(require,module,exports){\nvar modifiers = require('./index');\nvar utils = require('../utils');\nvar defaultOptions = require('../defaultOptions');\n\nvar restrict = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    restriction: null,\n    elementRect: null\n  },\n\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\n    var restrictOptions = interactable.options[actionName].restrict;\n\n    return restrictOptions && restrictOptions.enabled && (preEnd || !restrictOptions.endOnly) && (!requireEndOnly || restrictOptions.endOnly);\n  },\n\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\n    var elementRect = interactable.options[interaction.prepared.name].restrict.elementRect;\n    var offset = {};\n\n    if (rect && elementRect) {\n      offset.left = startOffset.left - rect.width * elementRect.left;\n      offset.top = startOffset.top - rect.height * elementRect.top;\n\n      offset.right = startOffset.right - rect.width * (1 - elementRect.right);\n      offset.bottom = startOffset.bottom - rect.height * (1 - elementRect.bottom);\n    } else {\n      offset.left = offset.top = offset.right = offset.bottom = 0;\n    }\n\n    return offset;\n  },\n\n  set: function (pageCoords, interaction, status) {\n    var target = interaction.target;\n    var restrictOptions = target && target.options[interaction.prepared.name].restrict;\n    var restriction = restrictOptions && restrictOptions.restriction;\n\n    if (!restriction) {\n      return status;\n    }\n\n    var page = status.useStatusXY ? { x: status.x, y: status.y } : utils.extend({}, pageCoords);\n\n    if (interaction.simulation) {\n      page.x -= interaction.simulation.resumeDx;\n      page.y -= interaction.simulation.resumeDy;\n    }\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    var rect = undefined;\n    var restrictedX = undefined;\n    var restrictedY = undefined;\n\n    if (utils.isString(restriction)) {\n      if (restriction === 'parent') {\n        restriction = utils.parentElement(interaction.element);\n      } else if (restriction === 'self') {\n        restriction = target.getRect(interaction.element);\n      } else {\n        restriction = utils.closest(interaction.element, restriction);\n      }\n\n      if (!restriction) {\n        return status;\n      }\n    }\n\n    if (utils.isFunction(restriction)) {\n      restriction = restriction(page.x, page.y, interaction.element);\n    }\n\n    if (utils.isElement(restriction)) {\n      restriction = utils.getElementRect(restriction);\n    }\n\n    rect = restriction;\n\n    var offset = interaction.modifierOffsets.restrict;\n\n    if (!restriction) {\n      restrictedX = page.x;\n      restrictedY = page.y;\n    }\n    // object is assumed to have\n    // x, y, width, height or\n    // left, top, right, bottom\n    else if ('x' in restriction && 'y' in restriction) {\n        restrictedX = Math.max(Math.min(rect.x + rect.width - offset.right, page.x), rect.x + offset.left);\n        restrictedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top);\n      } else {\n        restrictedX = Math.max(Math.min(rect.right - offset.right, page.x), rect.left + offset.left);\n        restrictedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top + offset.top);\n      }\n\n    status.dx = restrictedX - page.x;\n    status.dy = restrictedY - page.y;\n\n    status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.restrictedX = restrictedX;\n    status.restrictedY = restrictedY;\n\n    return status;\n  },\n\n  reset: function (status) {\n    status.dx = status.dy = 0;\n    status.modifiedX = status.modifiedY = NaN;\n    status.locked = false;\n    status.changed = true;\n\n    return status;\n  },\n\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\n    var options = interactable.options[actionName].restrict;\n    var elementRect = options && options.elementRect;\n\n    if (options && options.enabled && !(phase === 'start' && elementRect && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy\n        };\n      }\n    }\n  }\n};\n\nmodifiers.restrict = restrict;\nmodifiers.names.push('restrict');\n\ndefaultOptions.perAction.restrict = restrict.defaults;\n\nmodule.exports = restrict;\n\n},{\"../defaultOptions\":14,\"../utils\":33,\"./index\":19}],21:[function(require,module,exports){\nvar modifiers = require('./index');\nvar interact = require('../interact');\nvar utils = require('../utils');\nvar defaultOptions = require('../defaultOptions');\n\nvar snap = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range: Infinity,\n    targets: null,\n    offsets: null,\n\n    relativePoints: null\n  },\n\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\n    var snapOptions = interactable.options[actionName].snap;\n\n    return snapOptions && snapOptions.enabled && (preEnd || !snapOptions.endOnly) && (!requireEndOnly || snapOptions.endOnly);\n  },\n\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\n    var offsets = [];\n    var origin = utils.getOriginXY(interactable, element);\n    var snapOptions = interactable.options[interaction.prepared.name].snap || {};\n    var snapOffset = undefined;\n\n    if (snapOptions.offset === 'startCoords') {\n      snapOffset = {\n        x: interaction.startCoords.page.x - origin.x,\n        y: interaction.startCoords.page.y - origin.y\n      };\n    } else if (snapOptions.offset === 'self') {\n      snapOffset = {\n        x: rect.left - origin.x,\n        y: rect.top - origin.y\n      };\n    } else {\n      snapOffset = snapOptions.offset || { x: 0, y: 0 };\n    }\n\n    if (rect && snapOptions.relativePoints && snapOptions.relativePoints.length) {\n      for (var _iterator = snapOptions.relativePoints, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var relativeX = _ref.x;\n        var relativeY = _ref.y;\n\n        offsets.push({\n          x: startOffset.left - rect.width * relativeX + snapOffset.x,\n          y: startOffset.top - rect.height * relativeY + snapOffset.y\n        });\n      }\n    } else {\n      offsets.push(snapOffset);\n    }\n\n    return offsets;\n  },\n\n  set: function (pageCoords, interaction, status) {\n    var snapOptions = interaction.target.options[interaction.prepared.name].snap;\n    var targets = [];\n    var target = undefined;\n    var page = undefined;\n    var i = undefined;\n\n    if (status.useStatusXY) {\n      page = { x: status.x, y: status.y };\n    } else {\n      var origin = utils.getOriginXY(interaction.target, interaction.element);\n\n      page = utils.extend({}, pageCoords);\n\n      page.x -= origin.x;\n      page.y -= origin.y;\n    }\n\n    status.realX = page.x;\n    status.realY = page.y;\n\n    if (interaction.simulation) {\n      page.x -= interaction.simulation.resumeDx;\n      page.y -= interaction.simulation.resumeDy;\n    }\n\n    var offsets = interaction.modifierOffsets.snap;\n    var len = snapOptions.targets ? snapOptions.targets.length : 0;\n\n    for (var _iterator2 = offsets, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var offsetX = _ref2.x;\n      var offsetY = _ref2.y;\n\n      var relativeX = page.x - offsetX;\n      var relativeY = page.y - offsetY;\n\n      for (var _iterator3 = snapOptions.targets, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var snapTarget = _ref3;\n\n        if (utils.isFunction(snapTarget)) {\n          target = snapTarget(relativeX, relativeY, interaction);\n        } else {\n          target = snapTarget;\n        }\n\n        if (!target) {\n          continue;\n        }\n\n        targets.push({\n          x: utils.isNumber(target.x) ? target.x + offsetX : relativeX,\n          y: utils.isNumber(target.y) ? target.y + offsetY : relativeY,\n\n          range: utils.isNumber(target.range) ? target.range : snapOptions.range\n        });\n      }\n    }\n\n    var closest = {\n      target: null,\n      inRange: false,\n      distance: 0,\n      range: 0,\n      dx: 0,\n      dy: 0\n    };\n\n    for (i = 0, len = targets.length; i < len; i++) {\n      target = targets[i];\n\n      var range = target.range;\n      var dx = target.x - page.x;\n      var dy = target.y - page.y;\n      var distance = utils.hypot(dx, dy);\n      var inRange = distance <= range;\n\n      // Infinite targets count as being out of range\n      // compared to non infinite ones that are in range\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n        inRange = false;\n      }\n\n      if (!closest.target || (inRange\n      // is the closest target in range?\n      ? closest.inRange && range !== Infinity\n      // the pointer is relatively deeper in this target\n      ? distance / range < closest.distance / closest.range\n      // this target has Infinite range and the closest doesn't\n      : range === Infinity && closest.range !== Infinity ||\n      // OR this target is closer that the previous closest\n      distance < closest.distance :\n      // The other is not in range and the pointer is closer to this target\n      !closest.inRange && distance < closest.distance)) {\n\n        closest.target = target;\n        closest.distance = distance;\n        closest.range = range;\n        closest.inRange = inRange;\n        closest.dx = dx;\n        closest.dy = dy;\n\n        status.range = range;\n      }\n    }\n\n    var snapChanged = undefined;\n\n    if (closest.target) {\n      snapChanged = status.snappedX !== closest.target.x || status.snappedY !== closest.target.y;\n\n      status.snappedX = closest.target.x;\n      status.snappedY = closest.target.y;\n    } else {\n      snapChanged = true;\n\n      status.snappedX = NaN;\n      status.snappedY = NaN;\n    }\n\n    status.dx = closest.dx;\n    status.dy = closest.dy;\n\n    status.changed = snapChanged || closest.inRange && !status.locked;\n    status.locked = closest.inRange;\n\n    return status;\n  },\n\n  reset: function (status) {\n    status.dx = status.dy = 0;\n    status.snappedX = status.snappedY = NaN;\n    status.locked = false;\n    status.changed = true;\n\n    return status;\n  },\n\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\n    var snapOptions = interactable.options[actionName].snap;\n    var relativePoints = snapOptions && snapOptions.relativePoints;\n\n    if (snapOptions && snapOptions.enabled && !(phase === 'start' && relativePoints && relativePoints.length)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n      }\n\n      return {\n        range: status.range,\n        locked: status.locked,\n        x: status.snappedX,\n        y: status.snappedY,\n        realX: status.realX,\n        realY: status.realY,\n        dx: status.dx,\n        dy: status.dy\n      };\n    }\n  }\n};\n\ninteract.createSnapGrid = function (grid) {\n  return function (x, y) {\n    var offsetX = 0;\n    var offsetY = 0;\n\n    if (utils.isObject(grid.offset)) {\n      offsetX = grid.offset.x;\n      offsetY = grid.offset.y;\n    }\n\n    var gridx = Math.round((x - offsetX) / grid.x);\n    var gridy = Math.round((y - offsetY) / grid.y);\n\n    var newX = gridx * grid.x + offsetX;\n    var newY = gridy * grid.y + offsetY;\n\n    return {\n      x: newX,\n      y: newY,\n      range: grid.range\n    };\n  };\n};\n\nmodifiers.snap = snap;\nmodifiers.names.push('snap');\n\ndefaultOptions.perAction.snap = snap.defaults;\n\nmodule.exports = snap;\n\n},{\"../defaultOptions\":14,\"../interact\":17,\"../utils\":33,\"./index\":19}],22:[function(require,module,exports){\nvar scope = require('./scope');\nvar InteractEvent = require('./InteractEvent');\nvar Interaction = require('./Interaction');\nvar utils = require('./utils');\nvar browser = require('./utils/browser');\n\nvar simpleSignals = ['down', 'up', 'up', 'cancel'];\nvar simpleEvents = ['down', 'up', 'tap', 'cancel'];\n\nfunction preventOriginalDefault() {\n  this.originalEvent.preventDefault();\n}\n\nfunction firePointers(interaction, pointer, event, eventTarget, targets, elements, eventType) {\n  var pointerIndex = interaction.mouse ? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n  var pointerEvent = {};\n  var i = undefined;\n  // for tap events\n  var interval = undefined;\n  var createNewDoubleTap = undefined;\n\n  // if it's a doubletap then the event properties would have been\n  // copied from the tap event and provided as the pointer argument\n  if (eventType === 'doubletap') {\n    pointerEvent = pointer;\n  } else {\n    utils.pointerExtend(pointerEvent, event);\n    if (event !== pointer) {\n      utils.pointerExtend(pointerEvent, pointer);\n    }\n\n    pointerEvent.preventDefault = preventOriginalDefault;\n    pointerEvent.stopPropagation = InteractEvent.prototype.stopPropagation;\n    pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n    pointerEvent.interaction = interaction;\n\n    pointerEvent.timeStamp = new Date().getTime();\n    pointerEvent.originalEvent = event;\n    pointerEvent.type = eventType;\n    pointerEvent.pointerId = utils.getPointerId(pointer);\n    pointerEvent.pointerType = interaction.mouse ? 'mouse' : !browser.supportsPointerEvent ? 'touch' : utils.isString(pointer.pointerType) ? pointer.pointerType : [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType];\n  }\n\n  if (eventType === 'tap') {\n    pointerEvent.dt = pointerEvent.timeStamp - interaction.downTimes[pointerIndex];\n\n    interval = pointerEvent.timeStamp - interaction.tapTime;\n    createNewDoubleTap = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap' && interaction.prevTap.target === pointerEvent.target && interval < 500);\n\n    pointerEvent.double = createNewDoubleTap;\n\n    interaction.tapTime = pointerEvent.timeStamp;\n  }\n\n  for (i = 0; i < targets.length; i++) {\n    pointerEvent.currentTarget = elements[i];\n    pointerEvent.interactable = targets[i];\n    targets[i].fire(pointerEvent);\n\n    if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget) {\n      break;\n    }\n  }\n\n  if (createNewDoubleTap) {\n    var doubleTap = {};\n\n    utils.extend(doubleTap, pointerEvent);\n\n    doubleTap.dt = interval;\n    doubleTap.type = 'doubletap';\n\n    collectEventTargets(interaction, doubleTap, event, eventTarget, 'doubletap');\n\n    interaction.prevTap = doubleTap;\n  } else if (eventType === 'tap') {\n    interaction.prevTap = pointerEvent;\n  }\n}\n\nfunction collectEventTargets(interaction, pointer, event, eventTarget, eventType) {\n  var pointerIndex = interaction.mouse ? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (eventType === 'tap' && (interaction.pointerWasMoved\n  // or if the pointerup target is different to the pointerdown target\n   || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n    return;\n  }\n\n  var targets = [];\n  var elements = [];\n  var element = eventTarget;\n\n  function collectSelectors(interactable, selector, context) {\n    var els = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n    if (interactable._iEvents[eventType] && utils.isElement(element) && scope.inContext(interactable, element) && !scope.testIgnore(interactable, element, eventTarget) && scope.testAllow(interactable, element, eventTarget) && utils.matchesSelector(element, selector, els)) {\n\n      targets.push(interactable);\n      elements.push(element);\n    }\n  }\n\n  var interact = scope.interact;\n\n  while (element) {\n    if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n      targets.push(interact(element));\n      elements.push(element);\n    }\n\n    scope.interactables.forEachSelector(collectSelectors);\n\n    element = utils.parentElement(element);\n  }\n\n  // create the tap event even if there are no listeners so that\n  // doubletap can still be created and fired\n  if (targets.length || eventType === 'tap') {\n    firePointers(interaction, pointer, event, eventTarget, targets, elements, eventType);\n  }\n}\n\nInteraction.signals.on('move', function (_ref) {\n  var interaction = _ref.interaction;\n  var pointer = _ref.pointer;\n  var event = _ref.event;\n  var eventTarget = _ref.eventTarget;\n  var duplicateMove = _ref.duplicateMove;\n\n  var pointerIndex = interaction.mouse ? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearTimeout(interaction.holdTimers[pointerIndex]);\n    }\n\n    collectEventTargets(interaction, pointer, event, eventTarget, 'move');\n  }\n});\n\nInteraction.signals.on('down', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var pointer = _ref2.pointer;\n  var event = _ref2.event;\n  var eventTarget = _ref2.eventTarget;\n  var pointerIndex = _ref2.pointerIndex;\n\n  // copy event to be used in timeout for IE8\n  var eventCopy = browser.isIE8 ? utils.extend({}, event) : event;\n\n  interaction.holdTimers[pointerIndex] = setTimeout(function () {\n\n    collectEventTargets(interaction, browser.isIE8 ? eventCopy : pointer, eventCopy, eventTarget, 'hold');\n  }, scope.defaultOptions._holdDuration);\n});\n\nfunction createSignalListener(event) {\n  return function (arg) {\n    collectEventTargets(arg.interaction, arg.pointer, arg.event, arg.eventTarget, event);\n  };\n}\n\nfor (var i = 0; i < simpleSignals.length; i++) {\n  Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.prevTap = null; // the most recent tap event on this interaction\n  interaction.tapTime = 0; // time of the most recent tap event\n});\n\nutils.merge(scope.eventTypes, ['down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold']);\n\nmodule.exports = scope.pointerEvents = {\n  firePointers: firePointers,\n  collectEventTargets: collectEventTargets,\n  preventOriginalDefault: preventOriginalDefault\n};\n\n},{\"./InteractEvent\":2,\"./Interaction\":4,\"./scope\":23,\"./utils\":33,\"./utils/browser\":26}],23:[function(require,module,exports){\nvar scope = {};\nvar utils = require('./utils');\nvar signals = require('./utils/Signals')['new']();\n\nscope.defaultOptions = require('./defaultOptions');\nscope.events = require('./utils/events');\n\nscope.signals = signals;\n\nutils.extend(scope, require('./utils/window'));\nutils.extend(scope, require('./utils/domObjects'));\n\nscope.documents = []; // all documents being listened to\nscope.eventTypes = []; // all event types specific to interact.js\n\nscope.withinInteractionLimit = function (interactable, element, action) {\n  var options = interactable.options;\n  var maxActions = options[action.name].max;\n  var maxPerElement = options[action.name].maxPerElement;\n  var activeInteractions = 0;\n  var targetCount = 0;\n  var targetElementCount = 0;\n\n  for (var i = 0, len = scope.interactions.length; i < len; i++) {\n    var interaction = scope.interactions[i];\n    var otherAction = interaction.prepared.name;\n\n    if (!interaction.interacting()) {\n      continue;\n    }\n\n    activeInteractions++;\n\n    if (activeInteractions >= scope.maxInteractions) {\n      return false;\n    }\n\n    if (interaction.target !== interactable) {\n      continue;\n    }\n\n    targetCount += otherAction === action.name | 0;\n\n    if (targetCount >= maxActions) {\n      return false;\n    }\n\n    if (interaction.element === element) {\n      targetElementCount++;\n\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n        return false;\n      }\n    }\n  }\n\n  return scope.maxInteractions > 0;\n};\n\nscope.endAllInteractions = function (event) {\n  for (var i = 0; i < scope.interactions.length; i++) {\n    scope.interactions[i].end(event);\n  }\n};\n\nscope.prefixedPropREs = utils.prefixedPropREs;\n\nscope.signals.on('listen-to-document', function (_ref) {\n  var doc = _ref.doc;\n\n  // if document is already known\n  if (utils.contains(scope.documents, doc)) {\n    // don't call any further signal listeners\n    return false;\n  }\n});\n\nmodule.exports = scope;\n\n},{\"./defaultOptions\":14,\"./utils\":33,\"./utils/Signals\":24,\"./utils/domObjects\":27,\"./utils/events\":29,\"./utils/window\":39}],24:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _require = require('./arr');\n\nvar indexOf = _require.indexOf;\n\nvar Signals = (function () {\n  function Signals() {\n    _classCallCheck(this, Signals);\n\n    this.listeners = {\n      // signalName: [listeners],\n    };\n  }\n\n  Signals.prototype.on = function on(name, listener) {\n    if (!this.listeners[name]) {\n      this.listeners[name] = [listener];\n      return;\n    }\n\n    this.listeners[name].push(listener);\n  };\n\n  Signals.prototype.off = function off(name, listener) {\n    if (!this.listeners[name]) {\n      return;\n    }\n\n    var index = indexOf(this.listeners[name], listener);\n\n    if (index !== -1) {\n      this.listeners[name].splice(index, 1);\n    }\n  };\n\n  Signals.prototype.fire = function fire(name, arg) {\n    var targetListeners = this.listeners[name];\n\n    if (!targetListeners) {\n      return;\n    }\n\n    for (var i = 0; i < targetListeners.length; i++) {\n      if (targetListeners[i](arg, name) === false) {\n        return;\n      }\n    }\n  };\n\n  return Signals;\n})();\n\nSignals['new'] = function () {\n  return new Signals();\n};\n\nmodule.exports = Signals;\n\n},{\"./arr\":25}],25:[function(require,module,exports){\nfunction indexOf(array, target) {\n  for (var i = 0, len = array.length; i < len; i++) {\n    if (array[i] === target) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction contains(array, target) {\n  return indexOf(array, target) !== -1;\n}\n\nfunction merge(target, source) {\n  for (var i = 0; i < source.length; i++) {\n    target.push(source[i]);\n  }\n\n  return target;\n}\n\nmodule.exports = {\n  indexOf: indexOf,\n  contains: contains,\n  merge: merge\n};\n\n},{}],26:[function(require,module,exports){\nvar win = require('./window');\nvar isType = require('./isType');\nvar domObjects = require('./domObjects');\n\nvar browser = {\n    // Does the browser support touch input?\n    supportsTouch: !!('ontouchstart' in win.window || isType.isFunction(win.window.DocumentTouch) && domObjects.document instanceof win.DocumentTouch),\n\n    // Does the browser support PointerEvents\n    supportsPointerEvent: !!domObjects.PointerEvent,\n\n    isIE8: 'attachEvent' in win.window && !('addEventListener' in win.window),\n\n    // Opera Mobile must be handled differently\n    isOperaMobile: navigator.appName === 'Opera' && browser.supportsTouch && navigator.userAgent.match('Presto'),\n\n    // scrolling doesn't change the result of getClientRects on iOS 7\n    isIOS7: /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion),\n\n    isIe9OrOlder: domObjects.document.all && !win.window.atob,\n\n    // prefix matchesSelector\n    prefixedMatchesSelector: 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector',\n\n    useMatchesSelectorPolyfill: false,\n\n    pEventTypes: domObjects.PointerEvent ? domObjects.PointerEvent === win.window.MSPointerEvent ? { up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n        out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' } : { up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n        out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' } : null\n};\n\nbrowser.useMatchesSelectorPolyfill = !isType.isFunction(Element.prototype[browser.prefixedMatchesSelector]);\n\nmodule.exports = browser;\n\n},{\"./domObjects\":27,\"./isType\":35,\"./window\":39}],27:[function(require,module,exports){\nvar domObjects = {};\nvar win = require('./window').window;\n\nfunction blank() {}\n\ndomObjects.document = win.document;\ndomObjects.DocumentFragment = win.DocumentFragment || blank;\ndomObjects.SVGElement = win.SVGElement || blank;\ndomObjects.SVGSVGElement = win.SVGSVGElement || blank;\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\ndomObjects.HTMLElement = win.HTMLElement || win.Element;\n\ndomObjects.Event = win.Event;\ndomObjects.Touch = win.Touch || blank;\ndomObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;\n\nmodule.exports = domObjects;\n\n},{\"./window\":39}],28:[function(require,module,exports){\nvar win = require('./window');\nvar browser = require('./browser');\nvar isType = require('./isType');\nvar domObjects = require('./domObjects');\n\nvar domUtils = {\n  nodeContains: function (parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  },\n\n  closest: function (child, selector) {\n    var parent = domUtils.parentElement(child);\n\n    while (isType.isElement(parent)) {\n      if (domUtils.matchesSelector(parent, selector)) {\n        return parent;\n      }\n\n      parent = domUtils.parentElement(parent);\n    }\n\n    return null;\n  },\n\n  parentElement: function (node) {\n    var parent = node.parentNode;\n\n    if (isType.isDocFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && isType.isDocFrag(parent)) {\n        continue;\n      }\n\n      return parent;\n    }\n\n    return parent;\n  },\n\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n  matchesSelectorPolyfill: browser.useMatchesSelectorPolyfill ? function (element, selector, elems) {\n    elems = elems || element.parentNode.querySelectorAll(selector);\n\n    for (var i = 0, len = elems.length; i < len; i++) {\n      if (elems[i] === element) {\n        return true;\n      }\n    }\n\n    return false;\n  } : null,\n\n  matchesSelector: function (element, selector, nodeList) {\n    if (browser.useMatchesSelectorPolyfill) {\n      return domUtils.matchesSelectorPolyfill(element, selector, nodeList);\n    }\n\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (win.window !== win.realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[browser.prefixedMatchesSelector](selector);\n  },\n\n  // Test for the element that's \"above\" all other qualifiers\n  indexOfDeepestElement: function (elements) {\n    var deepestZoneParents = [];\n    var dropzoneParents = [];\n    var dropzone = undefined;\n    var deepestZone = elements[0];\n    var index = deepestZone ? 0 : -1;\n    var parent = undefined;\n    var child = undefined;\n    var i = undefined;\n    var n = undefined;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n          deepestZone = dropzone;\n          index = i;\n          continue;\n        }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (deepestZone instanceof domObjects.HTMLElement && dropzone instanceof domObjects.SVGElement && !(dropzone instanceof domObjects.SVGSVGElement)) {\n\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      } else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        } else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  },\n\n  matchesUpTo: function (element, selector, limit) {\n    while (domUtils.isElement(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = domUtils.parentElement(element);\n\n      if (element === limit) {\n        return domUtils.matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  },\n\n  getActualElement: function (element) {\n    return element instanceof domObjects.SVGElementInstance ? element.correspondingUseElement : element;\n  },\n\n  getScrollXY: function (relevantWindow) {\n    relevantWindow = relevantWindow || win.window;\n    return {\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop\n    };\n  },\n\n  getElementClientRect: function (element) {\n    var clientRect = element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];\n\n    return clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top\n    };\n  },\n\n  getElementRect: function (element) {\n    var clientRect = domUtils.getElementClientRect(element);\n\n    if (!browser.isIOS7 && clientRect) {\n      var _scroll = domUtils.getScrollXY(win.getWindow(element));\n\n      clientRect.left += _scroll.x;\n      clientRect.right += _scroll.x;\n      clientRect.top += _scroll.y;\n      clientRect.bottom += _scroll.y;\n    }\n\n    return clientRect;\n  }\n};\n\nmodule.exports = domUtils;\n\n},{\"./browser\":26,\"./domObjects\":27,\"./isType\":35,\"./window\":39}],29:[function(require,module,exports){\nvar arr = require('./arr');\nvar isType = require('./isType');\nvar domUtils = require('./domUtils');\nvar indexOf = arr.indexOf;\nvar contains = arr.contains;\nvar getWindow = require('./window').getWindow;\n\nvar useAttachEvent = 'attachEvent' in window && !('addEventListener' in window);\nvar addEvent = useAttachEvent ? 'attachEvent' : 'addEventListener';\nvar removeEvent = useAttachEvent ? 'detachEvent' : 'removeEventListener';\nvar on = useAttachEvent ? 'on' : '';\n\nvar elements = [];\nvar targets = [];\nvar attachedListeners = [];\n\n// {\n//   type: {\n//     selectors: ['selector', ...],\n//     contexts : [document, ...],\n//     listeners: [[listener, useCapture], ...]\n//   }\n//  }\nvar delegatedEvents = {};\n\nvar documents = [];\n\nfunction add(element, type, listener, useCapture) {\n  var elementIndex = indexOf(elements, element);\n  var target = targets[elementIndex];\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0\n    };\n\n    elementIndex = elements.push(element) - 1;\n    targets.push(target);\n\n    attachedListeners.push(useAttachEvent ? {\n      supplied: [],\n      wrapped: [],\n      useCount: []\n    } : null);\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = [];\n    target.typeCount++;\n  }\n\n  if (!contains(target.events[type], listener)) {\n    var ret = undefined;\n\n    if (useAttachEvent) {\n      var _attachedListeners$elementIndex = attachedListeners[elementIndex];\n      var supplied = _attachedListeners$elementIndex.supplied;\n      var wrapped = _attachedListeners$elementIndex.wrapped;\n      var useCount = _attachedListeners$elementIndex.useCount;\n\n      var listenerIndex = indexOf(supplied, listener);\n\n      var wrappedListener = wrapped[listenerIndex] || function (event) {\n        if (!event.immediatePropagationStopped) {\n          event.target = event.srcElement;\n          event.currentTarget = element;\n\n          event.preventDefault = event.preventDefault || preventDef;\n          event.stopPropagation = event.stopPropagation || stopProp;\n          event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n          if (/mouse|click/.test(event.type)) {\n            event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n            event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n          }\n\n          listener(event);\n        }\n      };\n\n      ret = element[addEvent](on + type, wrappedListener, !!useCapture);\n\n      if (listenerIndex === -1) {\n        supplied.push(listener);\n        wrapped.push(wrappedListener);\n        useCount.push(1);\n      } else {\n        useCount[listenerIndex]++;\n      }\n    } else {\n      ret = element[addEvent](type, listener, !!useCapture);\n    }\n    target.events[type].push(listener);\n\n    return ret;\n  }\n}\n\nfunction remove(element, type, listener, useCapture) {\n  var elementIndex = indexOf(elements, element);\n  var target = targets[elementIndex];\n\n  if (!target || !target.events) {\n    return;\n  }\n\n  var wrappedListener = listener;\n  var listeners = undefined;\n  var listenerIndex = undefined;\n\n  if (useAttachEvent) {\n    listeners = attachedListeners[elementIndex];\n    listenerIndex = indexOf(listeners.supplied, listener);\n    wrappedListener = listeners.wrapped[listenerIndex];\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all');\n      }\n    }\n    return;\n  }\n\n  if (target.events[type]) {\n    var len = target.events[type].length;\n\n    if (listener === 'all') {\n      for (var i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], !!useCapture);\n      }\n      return;\n    } else {\n      for (var i = 0; i < len; i++) {\n        if (target.events[type][i] === listener) {\n          element[removeEvent](on + type, wrappedListener, !!useCapture);\n          target.events[type].splice(i, 1);\n\n          if (useAttachEvent && listeners) {\n            listeners.useCount[listenerIndex]--;\n            if (listeners.useCount[listenerIndex] === 0) {\n              listeners.supplied.splice(listenerIndex, 1);\n              listeners.wrapped.splice(listenerIndex, 1);\n              listeners.useCount.splice(listenerIndex, 1);\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      target.events[type] = null;\n      target.typeCount--;\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1);\n    elements.splice(elementIndex, 1);\n    attachedListeners.splice(elementIndex, 1);\n  }\n}\n\nfunction addDelegate(selector, context, type, listener, useCapture) {\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      selectors: [],\n      contexts: [],\n      listeners: []\n    };\n\n    // add delegate listener functions\n    for (var i = 0; i < documents.length; i++) {\n      add(documents[i], type, delegateListener);\n      add(documents[i], type, delegateUseCapture, true);\n    }\n  }\n\n  var delegated = delegatedEvents[type];\n  var index = undefined;\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n      break;\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length;\n\n    delegated.selectors.push(selector);\n    delegated.contexts.push(context);\n    delegated.listeners.push([]);\n  }\n\n  // keep listener and useCapture flag\n  delegated.listeners[index].push([listener, useCapture]);\n}\n\nfunction removeDelegate(selector, context, type, listener, useCapture) {\n  var delegated = delegatedEvents[type];\n  var matchFound = false;\n  var index = undefined;\n\n  if (!delegated) {\n    return;\n  }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n\n      var listeners = delegated.listeners[index];\n\n      // each item of the listeners array is an array: [function, useCaptureFlag]\n      for (var i = listeners.length - 1; i >= 0; i--) {\n        var fn = listeners[i][0];\n        var useCap = listeners[i][1];\n\n        // check if the listener functions and useCapture flags match\n        if (fn === listener && useCap === useCapture) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1);\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1);\n            delegated.contexts.splice(index, 1);\n            delegated.listeners.splice(index, 1);\n\n            // remove delegate function from context\n            remove(context, type, delegateListener);\n            remove(context, type, delegateUseCapture, true);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null;\n            }\n          }\n\n          // only remove one listener\n          matchFound = true;\n          break;\n        }\n      }\n\n      if (matchFound) {\n        break;\n      }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener(event, useCapture) {\n  var fakeEvent = {};\n  var delegated = delegatedEvents[event.type];\n  var eventTarget = domUtils.getActualElement(event.path ? event.path[0] : event.target);\n  var element = eventTarget;\n\n  useCapture = useCapture ? true : false;\n\n  // duplicate the event so that currentTarget can be changed\n  for (var prop in event) {\n    fakeEvent[prop] = event[prop];\n  }\n\n  fakeEvent.originalEvent = event;\n  fakeEvent.preventDefault = preventOriginalDefault;\n\n  // climb up document tree looking for selector matches\n  while (isType.isElement(element)) {\n    for (var i = 0; i < delegated.selectors.length; i++) {\n      var selector = delegated.selectors[i];\n      var context = delegated.contexts[i];\n\n      if (domUtils.matchesSelector(element, selector) && domUtils.nodeContains(context, eventTarget) && domUtils.nodeContains(context, element)) {\n\n        var listeners = delegated.listeners[i];\n\n        fakeEvent.currentTarget = element;\n\n        for (var j = 0; j < listeners.length; j++) {\n          if (listeners[j][1] === useCapture) {\n            listeners[j][0](fakeEvent);\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentElement(element);\n  }\n}\n\nfunction delegateUseCapture(event) {\n  return delegateListener.call(this, event, true);\n}\n\nfunction preventDef() {\n  this.returnValue = false;\n}\n\nfunction preventOriginalDefault() {\n  this.originalEvent.preventDefault();\n}\n\nfunction stopProp() {\n  this.cancelBubble = true;\n}\n\nfunction stopImmProp() {\n  this.cancelBubble = true;\n  this.immediatePropagationStopped = true;\n}\n\nmodule.exports = {\n  add: add,\n  remove: remove,\n\n  addDelegate: addDelegate,\n  removeDelegate: removeDelegate,\n\n  delegateListener: delegateListener,\n  delegateUseCapture: delegateUseCapture,\n  delegatedEvents: delegatedEvents,\n  documents: documents,\n\n  useAttachEvent: useAttachEvent,\n\n  _elements: elements,\n  _targets: targets,\n  _attachedListeners: attachedListeners\n};\n\n},{\"./arr\":25,\"./domUtils\":28,\"./isType\":35,\"./window\":39}],30:[function(require,module,exports){\nmodule.exports = function extend(dest, source) {\n  for (var prop in source) {\n    dest[prop] = source[prop];\n  }\n  return dest;\n};\n\n},{}],31:[function(require,module,exports){\nvar _require = require('./domUtils');\n\nvar closest = _require.closest;\nvar parentElement = _require.parentElement;\nvar getElementRect = _require.getElementRect;\n\nvar _require2 = require('./isType');\n\nvar isElement = _require2.isElement;\nvar isFunction = _require2.isFunction;\nvar trySelector = _require2.trySelector;\n\nmodule.exports = function (interactable, element) {\n  var origin = interactable.options.origin;\n\n  if (origin === 'parent') {\n    origin = parentElement(element);\n  } else if (origin === 'self') {\n    origin = interactable.getRect(element);\n  } else if (trySelector(origin)) {\n    origin = closest(element, origin) || { x: 0, y: 0 };\n  }\n\n  if (isFunction(origin)) {\n    origin = origin(interactable && element);\n  }\n\n  if (isElement(origin)) {\n    origin = getElementRect(origin);\n  }\n\n  origin.x = 'x' in origin ? origin.x : origin.left;\n  origin.y = 'y' in origin ? origin.y : origin.top;\n\n  return origin;\n};\n\n},{\"./domUtils\":28,\"./isType\":35}],32:[function(require,module,exports){\nmodule.exports = function (x, y) {\n  return Math.sqrt(x * x + y * y);\n};\n\n},{}],33:[function(require,module,exports){\nvar utils = module.exports;\nvar extend = require('./extend');\nvar win = require('./window');\n\nutils.blank = function () {};\n\nutils.warnOnce = function (method, message) {\n  var warned = false;\n\n  return function () {\n    if (!warned) {\n      win.window.console.warn(message);\n      warned = true;\n    }\n\n    return method.apply(this, arguments);\n  };\n};\n\n// http://stackoverflow.com/a/5634528/2280888\nutils._getQBezierValue = function (t, p1, p2, p3) {\n  var iT = 1 - t;\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n};\n\nutils.getQuadraticCurvePoint = function (startX, startY, cpX, cpY, endX, endY, position) {\n  return {\n    x: utils._getQBezierValue(position, startX, cpX, endX),\n    y: utils._getQBezierValue(position, startY, cpY, endY)\n  };\n};\n\n// http://gizma.com/easing/\nutils.easeOutQuad = function (t, b, c, d) {\n  t /= d;\n  return -c * t * (t - 2) + b;\n};\n\nutils.copyAction = function (dest, src) {\n  dest.name = src.name;\n  dest.axis = src.axis;\n  dest.edges = src.edges;\n\n  return dest;\n};\n\nutils.extend = extend;\nutils.hypot = require('./hypot');\nutils.raf = require('./raf');\nutils.browser = require('./browser');\nutils.getOriginXY = require('./getOriginXY');\n\nextend(utils, require('./arr'));\nextend(utils, require('./isType'));\nextend(utils, require('./domUtils'));\nextend(utils, require('./pointerUtils'));\n\n},{\"./arr\":25,\"./browser\":26,\"./domUtils\":28,\"./extend\":30,\"./getOriginXY\":31,\"./hypot\":32,\"./isType\":35,\"./pointerUtils\":37,\"./raf\":38,\"./window\":39}],34:[function(require,module,exports){\nvar scope = require('../scope');\nvar utils = require('./index');\nvar browser = require('./browser');\n\nvar finder = {\n  methodOrder: ['simulationResume', 'mouse', 'hasPointer', 'idle'],\n\n  search: function (pointer, eventType, eventTarget) {\n    var mouseEvent = /mouse/i.test(pointer.pointerType || eventType)\n    // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n     || pointer.pointerType === 4;\n    var pointerId = utils.getPointerId(pointer);\n    var details = { pointer: pointer, pointerId: pointerId, mouseEvent: mouseEvent, eventType: eventType, eventTarget: eventTarget };\n\n    for (var _iterator = finder.methodOrder, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var method = _ref;\n\n      var interaction = finder[method](details);\n\n      if (interaction) {\n        return interaction;\n      }\n    }\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume: function (_ref7) {\n    var mouseEvent = _ref7.mouseEvent;\n    var eventType = _ref7.eventType;\n    var eventTarget = _ref7.eventTarget;\n\n    if (!/down|start/i.test(eventType)) {\n      return null;\n    }\n\n    for (var _iterator2 = scope.interactions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var interaction = _ref2;\n\n      var element = eventTarget;\n\n      if (interaction.simulation && interaction.simulation.allowResume && interaction.mouse === mouseEvent) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction;\n          }\n          element = utils.parentElement(element);\n        }\n      }\n    }\n\n    return null;\n  },\n\n  // if it's a mouse interaction\n  mouse: function (_ref8) {\n    var mouseEvent = _ref8.mouseEvent;\n    var eventType = _ref8.eventType;\n\n    if (!mouseEvent && (browser.supportsTouch || browser.supportsPointerEvent)) {\n      return null;\n    }\n\n    var firstNonActive = undefined;\n\n    for (var _iterator3 = scope.interactions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var interaction = _ref3;\n\n      if (interaction.mouse) {\n        // if it's a down event, skip interactions with running simulations\n        if (/down/i.test(eventType) && interaction.simulation) {\n          continue;\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction;\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n            firstNonActive = interaction;\n          }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive;\n    }\n\n    // Find any interaction specifically for mouse.\n    // ignore the interaction if the eventType is a mousedown, and a simulation\n    // is active\n    for (var _iterator4 = scope.interactions, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var interaction = _ref4;\n\n      if (interaction.mouse && !(/down/.test(eventType) && interaction.simulation)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n\n  // get interaction that has this pointer\n  hasPointer: function (_ref9) {\n    var pointerId = _ref9.pointerId;\n\n    for (var _iterator5 = scope.interactions, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n      var _ref5;\n\n      if (_isArray5) {\n        if (_i5 >= _iterator5.length) break;\n        _ref5 = _iterator5[_i5++];\n      } else {\n        _i5 = _iterator5.next();\n        if (_i5.done) break;\n        _ref5 = _i5.value;\n      }\n\n      var interaction = _ref5;\n\n      if (utils.contains(interaction.pointerIds, pointerId)) {\n        return interaction;\n      }\n    }\n  },\n\n  // get first idle interaction\n  idle: function (_ref10) {\n    var mouseEvent = _ref10.mouseEvent;\n\n    for (var _iterator6 = scope.interactions, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n      var _ref6;\n\n      if (_isArray6) {\n        if (_i6 >= _iterator6.length) break;\n        _ref6 = _iterator6[_i6++];\n      } else {\n        _i6 = _iterator6.next();\n        if (_i6.done) break;\n        _ref6 = _i6.value;\n      }\n\n      var interaction = _ref6;\n\n      // if there's already a pointer held down\n      if (interaction.pointerIds.length === 1) {\n        var target = interaction.target;\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !target.options.gesture.enabled) {\n          continue;\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointerIds.length >= 2) {\n          continue;\n        }\n\n      if (!interaction.interacting() && !(!mouseEvent && interaction.mouse)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  }\n};\n\nmodule.exports = finder;\n\n},{\"../scope\":23,\"./browser\":26,\"./index\":33}],35:[function(require,module,exports){\nvar win = require('./window');\nvar isWindow = require('./isWindow');\nvar domObjects = require('./domObjects');\n\nvar isType = {\n  isElement: function (o) {\n    if (!o || typeof o !== 'object') {\n      return false;\n    }\n\n    var _window = win.getWindow(o) || win.window;\n\n    return (/object|function/.test(typeof _window.Element) ? o instanceof _window.Element //DOM2\n      : o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  },\n\n  isArray: null,\n\n  isWindow: function (thing) {\n    return thing === win.window || isWindow(thing);\n  },\n\n  isDocFrag: function (thing) {\n    return isType.isObject(thing) && thing.nodeType === 11;\n  },\n\n  isObject: function (thing) {\n    return !!thing && typeof thing === 'object';\n  },\n\n  isFunction: function (thing) {\n    return typeof thing === 'function';\n  },\n\n  isNumber: function (thing) {\n    return typeof thing === 'number';\n  },\n\n  isBool: function (thing) {\n    return typeof thing === 'boolean';\n  },\n\n  isString: function (thing) {\n    return typeof thing === 'string';\n  },\n\n  trySelector: function (value) {\n    if (!isType.isString(value)) {\n      return false;\n    }\n\n    // an exception will be raised if it is invalid\n    domObjects.document.querySelector(value);\n    return true;\n  }\n};\n\nisType.isArray = function (thing) {\n  return isType.isObject(thing) && typeof thing.length !== 'undefined' && isType.isFunction(thing.splice);\n};\n\nmodule.exports = isType;\n\n},{\"./domObjects\":27,\"./isWindow\":36,\"./window\":39}],36:[function(require,module,exports){\nmodule.exports = function (thing) {\n  return !!(thing && thing.Window) && thing instanceof thing.Window;\n};\n\n},{}],37:[function(require,module,exports){\nvar hypot = require('./hypot');\nvar browser = require('./browser');\nvar dom = require('./domObjects');\nvar isType = require('./isType');\n\nvar pointerUtils = {\n  copyCoords: function (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  },\n\n  setEventDeltas: function (targetObj, prev, cur) {\n    var now = new Date().getTime();\n\n    targetObj.page.x = cur.page.x - prev.page.x;\n    targetObj.page.y = cur.page.y - prev.page.y;\n    targetObj.client.x = cur.client.x - prev.client.x;\n    targetObj.client.y = cur.client.y - prev.client.y;\n    targetObj.timeStamp = now - prev.timeStamp;\n\n    // set pointer velocity\n    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\n    targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx = targetObj.page.x / dt;\n    targetObj.page.vy = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx = targetObj.client.x / dt;\n    targetObj.client.vy = targetObj.client.y / dt;\n  },\n\n  isNativePointer: function (pointer) {\n    return pointer instanceof dom.Event || pointer instanceof dom.Touch;\n  },\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  getXY: function (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  },\n\n  getPageXY: function (pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      pointerUtils.getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    } else {\n      pointerUtils.getXY('page', pointer, page);\n    }\n\n    return page;\n  },\n\n  getClientXY: function (pointer, client) {\n    client = client || {};\n\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      pointerUtils.getXY('screen', pointer, client);\n    } else {\n      pointerUtils.getXY('client', pointer, client);\n    }\n\n    return client;\n  },\n\n  getPointerId: function (pointer) {\n    return isType.isNumber(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\n  },\n\n  prefixedPropREs: {\n    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n  },\n\n  pointerExtend: function (dest, source) {\n    for (var prop in source) {\n      var prefixedPropREs = pointerUtils.prefixedPropREs;\n      var deprecated = false;\n\n      // skip deprecated prefixed properties\n      for (var vendor in prefixedPropREs) {\n        if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n          deprecated = true;\n          break;\n        }\n      }\n\n      if (!deprecated) {\n        dest[prop] = source[prop];\n      }\n    }\n    return dest;\n  },\n\n  getTouchPair: function (event) {\n    var touches = [];\n\n    // array of touches is supplied\n    if (isType.isArray(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n        if (event.type === 'touchend') {\n          if (event.touches.length === 1) {\n            touches[0] = event.touches[0];\n            touches[1] = event.changedTouches[0];\n          } else if (event.touches.length === 0) {\n            touches[0] = event.changedTouches[0];\n            touches[1] = event.changedTouches[1];\n          }\n        } else {\n          touches[0] = event.touches[0];\n          touches[1] = event.touches[1];\n        }\n      }\n\n    return touches;\n  },\n\n  pointerAverage: function (pointers) {\n    var average = {\n      pageX: 0,\n      pageY: 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0\n    };\n\n    for (var _iterator = pointers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var pointer = _ref;\n\n      for (var prop in average) {\n        average[prop] += pointer[prop];\n      }\n    }\n    for (var prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  },\n\n  touchBBox: function (event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    var touches = pointerUtils.getTouchPair(event);\n    var minX = Math.min(touches[0].pageX, touches[1].pageX);\n    var minY = Math.min(touches[0].pageY, touches[1].pageY);\n    var maxX = Math.max(touches[0].pageX, touches[1].pageX);\n    var maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  },\n\n  touchDistance: function (event, deltaSource) {\n    deltaSource = deltaSource;\n\n    var sourceX = deltaSource + 'X';\n    var sourceY = deltaSource + 'Y';\n    var touches = pointerUtils.getTouchPair(event);\n\n    var dx = touches[0][sourceX] - touches[1][sourceX];\n    var dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  },\n\n  touchAngle: function (event, prevAngle, deltaSource) {\n    deltaSource = deltaSource;\n\n    var sourceX = deltaSource + 'X';\n    var sourceY = deltaSource + 'Y';\n    var touches = pointerUtils.getTouchPair(event);\n    var dx = touches[1][sourceX] - touches[0][sourceX];\n    var dy = touches[1][sourceY] - touches[0][sourceY];\n    var angle = 180 * Math.atan2(dy, dx) / Math.PI;\n\n    return angle;\n  }\n};\n\nmodule.exports = pointerUtils;\n\n},{\"./browser\":26,\"./domObjects\":27,\"./hypot\":32,\"./isType\":35}],38:[function(require,module,exports){\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\nvar lastTime = 0;\nvar request = undefined;\nvar cancel = undefined;\n\nfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n  request = window[vendors[x] + 'RequestAnimationFrame'];\n  cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  request = function (callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  cancel = function (id) {\n    clearTimeout(id);\n  };\n}\n\nmodule.exports = {\n  request: request,\n  cancel: cancel\n};\n\n},{}],39:[function(require,module,exports){\nvar win = module.exports;\nvar isWindow = require('./isWindow');\n\nfunction init(window) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  win.realWindow = window;\n\n  // create a TextNode\n  var el = window.document.createTextNode('');\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n    // return wrapped window\n    win.window = window.wrap(window);\n  }\n\n  // no Shadow DOM polyfil or native implementation\n  win.window = window;\n}\n\nif (typeof window === 'undefined') {\n  win.window = undefined;\n  win.realWindow = undefined;\n} else {\n  init(window);\n}\n\nwin.getWindow = function getWindow(node) {\n  if (isWindow(node)) {\n    return node;\n  }\n\n  var rootNode = node.ownerDocument || node;\n\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\n};\n\nwin.init = init;\n\n},{\"./isWindow\":36}]},{},[1])(1)\n});\n//# sourceMappingURL=interact.js.map\n","const hypot       = require('./utils/hypot');\nconst extend      = require('./utils/extend');\nconst getOriginXY = require('./utils/getOriginXY');\nconst scope       = require('./scope');\nconst signals     = require('./utils/Signals').new();\n\nclass InteractEvent {\n  constructor (interaction, event, action, phase, element, related) {\n    const target      = interaction.target;\n    const deltaSource = (target && target.options || scope.defaultOptions).deltaSource;\n    const sourceX     = deltaSource + 'X';\n    const sourceY     = deltaSource + 'Y';\n    const origin      = getOriginXY(target, element);\n    const starting    = phase === 'start';\n    const ending      = phase === 'end';\n    const coords      = starting? interaction.startCoords : interaction.curCoords;\n\n    element = element || interaction.element;\n\n    const page   = extend({}, coords.page);\n    const client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    this.ctrlKey       = event.ctrlKey;\n    this.altKey        = event.altKey;\n    this.shiftKey      = event.shiftKey;\n    this.metaKey       = event.metaKey;\n    this.button        = event.button;\n    this.buttons       = event.buttons;\n    this.target        = element;\n    this.relatedTarget = related || null;\n    this.t0            = interaction.downTimes[interaction.downTimes.length - 1];\n    this.type          = action + (phase || '');\n    this.interaction   = interaction;\n    this.interactable  = target;\n\n    const signalArg = {\n      interaction,\n      event,\n      action,\n      phase,\n      element,\n      related,\n      page,\n      client,\n      coords,\n      starting,\n      ending,\n      deltaSource,\n      iEvent: this,\n    };\n\n    signals.fire('set-xy', signalArg);\n\n    if (ending) {\n      const prevEvent = interaction.prevEvent;\n\n      // use previous coords when ending\n      this.pageX = prevEvent.pageX;\n      this.pageY = prevEvent.pageY;\n      this.clientX = prevEvent.clientX;\n      this.clientY = prevEvent.clientY;\n    }\n    else {\n      this.pageX     = page.x;\n      this.pageY     = page.y;\n      this.clientX   = client.x;\n      this.clientY   = client.y;\n    }\n\n    this.x0        = interaction.startCoords.page.x - origin.x;\n    this.y0        = interaction.startCoords.page.y - origin.y;\n    this.clientX0  = interaction.startCoords.client.x - origin.x;\n    this.clientY0  = interaction.startCoords.client.y - origin.y;\n\n    signals.fire('set-delta', signalArg);\n    signals.fire(action, signalArg);\n\n    if (starting) {\n      this.timeStamp = interaction.downTimes[0];\n      this.dt        = 0;\n      this.duration  = 0;\n      this.speed     = 0;\n      this.velocityX = 0;\n      this.velocityY = 0;\n    }\n    else if (phase === 'inertiastart') {\n      this.timeStamp = interaction.prevEvent.timeStamp;\n      this.dt        = interaction.prevEvent.dt;\n      this.duration  = interaction.prevEvent.duration;\n      this.speed     = interaction.prevEvent.speed;\n      this.velocityX = interaction.prevEvent.velocityX;\n      this.velocityY = interaction.prevEvent.velocityY;\n    }\n    else {\n      this.timeStamp = new Date().getTime();\n      this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n      this.duration  = this.timeStamp - interaction.downTimes[0];\n\n      if (event instanceof InteractEvent) {\n        const dx = this[sourceX] - interaction.prevEvent[sourceX];\n        const dy = this[sourceY] - interaction.prevEvent[sourceY];\n        const dt = this.dt / 1000;\n\n        this.speed = hypot(dx, dy) / dt;\n        this.velocityX = dx / dt;\n        this.velocityY = dy / dt;\n      }\n      // if normal move or end event, use previous user event coords\n      else {\n        // speed and velocity in pixels per second\n        this.speed = interaction.pointerDelta[deltaSource].speed;\n        this.velocityX = interaction.pointerDelta[deltaSource].vx;\n        this.velocityY = interaction.pointerDelta[deltaSource].vy;\n      }\n    }\n\n    if ((ending || phase === 'inertiastart')\n        && interaction.prevEvent.speed > 600\n        && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n      let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n      const overlap = 22.5;\n\n      if (angle < 0) {\n        angle += 360;\n      }\n\n      const left = 135 - overlap <= angle && angle < 225 + overlap;\n      const up   = 225 - overlap <= angle && angle < 315 + overlap;\n\n      const right = !left && (315 - overlap <= angle || angle <  45 + overlap);\n      const down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n      this.swipe = {\n        up,\n        down,\n        left,\n        right,\n        angle,\n        speed: interaction.prevEvent.speed,\n        velocity: {\n          x: interaction.prevEvent.velocityX,\n          y: interaction.prevEvent.velocityY,\n        },\n      };\n    }\n\n    signals.fire('new', signalArg);\n    signals.fire('new-' + action, signalArg);\n  }\n\n  preventDefault () {}\n\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  }\n\n  stopPropagation () {\n    this.propagationStopped = true;\n  }\n}\n\nsignals.on('set-delta', function ({ iEvent, interaction, ending, starting,\n                                            page, client, deltaSource }) {\n  // end event dx, dy is difference between start and end points\n  if (ending) {\n    if (deltaSource === 'client') {\n      iEvent.dx = client.x - interaction.startCoords.client.x;\n      iEvent.dy = client.y - interaction.startCoords.client.y;\n    }\n    else {\n      iEvent.dx = page.x - interaction.startCoords.page.x;\n      iEvent.dy = page.y - interaction.startCoords.page.y;\n    }\n  }\n  else if (starting) {\n    iEvent.dx = 0;\n    iEvent.dy = 0;\n  }\n  else {\n    if (deltaSource === 'client') {\n      iEvent.dx = client.x - interaction.prevEvent.clientX;\n      iEvent.dy = client.y - interaction.prevEvent.clientY;\n    }\n    else {\n      iEvent.dx = page.x - interaction.prevEvent.pageX;\n      iEvent.dy = page.y - interaction.prevEvent.pageY;\n    }\n  }\n});\n\nInteractEvent.signals = signals;\n\nmodule.exports = InteractEvent;\n","const isType  = require('./utils/isType');\nconst events  = require('./utils/events');\nconst extend  = require('./utils/extend');\nconst actions = require('./actions');\nconst scope   = require('./scope');\nconst signals = require('./utils/Signals').new();\n\nconst { getElementRect }    = require('./utils/domUtils');\nconst { indexOf, contains } = require('./utils/arr');\n\n// all set interactables\nscope.interactables = [];\n\n/*\\\n * Interactable\n [ property ]\n **\n * Object type returned by @interact\n\\*/\nclass Interactable {\n  constructor (target, options) {\n    this.target   = target;\n    this._context = scope.document;\n    this._iEvents = this._iEvents || {};\n\n    let _window;\n\n    if (isType.trySelector(target)) {\n      this.target = target;\n\n      const context = options && options.context;\n\n      _window = context? scope.getWindow(context) : scope.window;\n\n      if (context && (_window.Node\n        ? context instanceof _window.Node\n        : (isType.isElement(context) || context === _window.document))) {\n\n        this._context = context;\n      }\n    }\n    else {\n      _window = scope.getWindow(target);\n    }\n\n    this._doc = _window.document;\n\n    signals.fire('new', {\n      target,\n      options,\n      interactable: this,\n      win: _window,\n    });\n\n    if (this._doc !== scope.document) {\n      scope.signals.fire('listen-to-document', {\n        doc: this._doc,\n        win: _window,\n      });\n    }\n\n    scope.interactables.push(this);\n\n    this.set(options);\n  }\n\n  setOnEvents (action, phases) {\n    const onAction = 'on' + action;\n\n    if (isType.isFunction(phases.onstart)       ) { this[onAction + 'start'        ] = phases.onstart         ; }\n    if (isType.isFunction(phases.onmove)        ) { this[onAction + 'move'         ] = phases.onmove          ; }\n    if (isType.isFunction(phases.onend)         ) { this[onAction + 'end'          ] = phases.onend           ; }\n    if (isType.isFunction(phases.oninertiastart)) { this[onAction + 'inertiastart' ] = phases.oninertiastart  ; }\n\n    return this;\n  }\n\n  setPerAction (action, options) {\n    // for all the default per-action options\n    for (const option in options) {\n      // if this option exists for this action\n      if (option in scope.defaultOptions[action]) {\n        // if the option in the options arg is an object value\n        if (isType.isObject(options[option])) {\n          // duplicate the object\n          this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n          if (isType.isObject(scope.defaultOptions.perAction[option]) && 'enabled' in scope.defaultOptions.perAction[option]) {\n            this.options[action][option].enabled = options[option].enabled === false? false : true;\n          }\n        }\n        else if (isType.isBool(options[option]) && isType.isObject(scope.defaultOptions.perAction[option])) {\n          this.options[action][option].enabled = options[option];\n        }\n        else if (options[option] !== undefined) {\n          // or if it's not undefined, do a plain assignment\n          this.options[action][option] = options[option];\n        }\n      }\n    }\n  }\n\n  /*\\\n   * Interactable.getRect\n   [ method ]\n   *\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using @Interactable.rectChecker.\n   *\n   - element (Element) #optional The element to measure.\n   = (object) The object's bounding rectangle.\n   o {\n   o     top   : 0,\n   o     left  : 0,\n   o     bottom: 0,\n   o     right : 0,\n   o     width : 0,\n   o     height: 0\n   o }\n  \\*/\n  getRect (element) {\n    element = element || this.target;\n\n    if (isType.isString(this.target) && !(isType.isElement(element))) {\n      element = this._context.querySelector(this.target);\n    }\n\n    return getElementRect(element);\n  }\n\n  /*\\\n   * Interactable.rectChecker\n   [ method ]\n   *\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n   = (function | object) The checker function or this Interactable\n  \\*/\n  rectChecker (checker) {\n    if (isType.isFunction(checker)) {\n      this.getRect = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.getRect;\n\n      return this;\n    }\n\n    return this.getRect;\n  }\n\n  /*\\\n   * Interactable.preventDefault\n   [ method ]\n   *\n   * Returns or sets whether to prevent the browser's default behaviour\n   * in response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   - newValue (string) #optional `true`, `false` or `'auto'`\n   = (string | Interactable) The current setting or this Interactable\n  \\*/\n  preventDefault (newValue) {\n    if (/^(always|never|auto)$/.test(newValue)) {\n      this.options.preventDefault = newValue;\n      return this;\n    }\n\n    if (isType.isBool(newValue)) {\n      this.options.preventDefault = newValue? 'always' : 'never';\n      return this;\n    }\n\n    return this.options.preventDefault;\n  }\n\n  /*\\\n   * Interactable.origin\n   [ method ]\n   *\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n   * OR\n   - origin (Element) #optional An HTML or SVG Element whose rect will be used\n   **\n   = (object) The current origin or this Interactable\n  \\*/\n  origin (newValue) {\n    if (isType.trySelector(newValue)) {\n      this.options.origin = newValue;\n      return this;\n    }\n    else if (isType.isObject(newValue)) {\n      this.options.origin = newValue;\n      return this;\n    }\n\n    return this.options.origin;\n  }\n\n  /*\\\n   * Interactable.deltaSource\n   [ method ]\n   *\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n   = (string | object) The current deltaSource or this Interactable\n  \\*/\n  deltaSource (newValue) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue;\n\n      return this;\n    }\n\n    return this.options.deltaSource;\n  }\n\n  /*\\\n   * Interactable.context\n   [ method ]\n   *\n   * Gets the selector context Node of the Interactable. The default is `window.document`.\n   *\n   = (Node) The context Node of this Interactable\n   **\n  \\*/\n  context () {\n    return this._context;\n  }\n\n  /*\\\n   * Interactable.fire\n   [ method ]\n   *\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n   = (Interactable) this Interactable\n  \\*/\n  fire (iEvent) {\n    if (!(iEvent && iEvent.type) || !contains(scope.eventTypes, iEvent.type)) {\n      return this;\n    }\n\n    let listeners;\n    const onEvent = 'on' + iEvent.type;\n\n    // Interactable#on() listeners\n    if (iEvent.type in this._iEvents) {\n      listeners = this._iEvents[iEvent.type];\n\n      for (let i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n        listeners[i](iEvent);\n      }\n    }\n\n    // interactable.onevent listener\n    if (isType.isFunction(this[onEvent])) {\n      this[onEvent](iEvent);\n    }\n\n    // interact.on() listeners\n    if (iEvent.type in scope.globalEvents && (listeners = scope.globalEvents[iEvent.type]))  {\n\n      for (let i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n        listeners[i](iEvent);\n      }\n    }\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.on\n   [ method ]\n   *\n   * Binds a listener for an InteractEvent or DOM event.\n   *\n   - eventType  (string | array | object) The types of events to listen for\n   - listener   (function) The function event (s)\n   - useCapture (boolean) #optional useCapture flag for addEventListener\n   = (object) This Interactable\n  \\*/\n  on (eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (let i = 0; i < eventType.length; i++) {\n        this.on(eventType[i], listener, useCapture);\n      }\n\n      return this;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (const prop in eventType) {\n        this.on(prop, eventType[prop], listener);\n      }\n\n      return this;\n    }\n\n    if (eventType === 'wheel') {\n      eventType = scope.wheelEvent;\n    }\n\n    // convert to boolean\n    useCapture = useCapture? true: false;\n\n    if (contains(scope.eventTypes, eventType)) {\n      // if this type of event was never bound to this Interactable\n      if (!(eventType in this._iEvents)) {\n        this._iEvents[eventType] = [listener];\n      }\n      else {\n        this._iEvents[eventType].push(listener);\n      }\n    }\n    // delegated event for selector\n    else if (isType.isString(this.target)) {\n      events.addDelegate(this.target, this._context, eventType, listener, useCapture);\n    }\n    else {\n      events.add(this.target, eventType, listener, useCapture);\n    }\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.off\n   [ method ]\n   *\n   * Removes an InteractEvent or DOM event listener\n   *\n   - eventType  (string | array | object) The types of events that were listened for\n   - listener   (function) The listener function to be removed\n   - useCapture (boolean) #optional useCapture flag for removeEventListener\n   = (object) This Interactable\n  \\*/\n  off (eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (let i = 0; i < eventType.length; i++) {\n        this.off(eventType[i], listener, useCapture);\n      }\n\n      return this;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (const prop in eventType) {\n        this.off(prop, eventType[prop], listener);\n      }\n\n      return this;\n    }\n\n\n    // convert to boolean\n    useCapture = useCapture? true: false;\n\n    if (eventType === 'wheel') {\n      eventType = scope.wheelEvent;\n    }\n\n    // if it is an action event type\n    if (contains(scope.eventTypes, eventType)) {\n      const eventList = this._iEvents[eventType];\n      const index     = eventList? indexOf(eventList, listener) : -1;\n\n      if (index !== -1) {\n        this._iEvents[eventType].splice(index, 1);\n      }\n    }\n    // delegated event\n    else if (isType.isString(this.target)) {\n      events.removeDelegate(this.target, this._context, eventType, listener, useCapture);\n    }\n    // remove listener from this Interatable's element\n    else {\n      events.remove(this.target, eventType, listener, useCapture);\n    }\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.set\n   [ method ]\n   *\n   * Reset the options of this Interactable\n   - options (object) The new settings to apply\n   = (object) This Interactable\n  \\*/\n  set (options) {\n    if (!isType.isObject(options)) {\n      options = {};\n    }\n\n    this.options = extend({}, scope.defaultOptions.base);\n\n    const perActions = extend({}, scope.defaultOptions.perAction);\n\n    for (const actionName in actions.methodDict) {\n      const methodName = actions.methodDict[actionName];\n\n      this.options[actionName] = extend({}, scope.defaultOptions[actionName]);\n\n      this.setPerAction(actionName, perActions);\n\n      this[methodName](options[actionName]);\n    }\n\n    for (const setting of Interactable.settingsMethods) {\n      this.options[setting] = scope.defaultOptions.base[setting];\n\n      if (setting in options) {\n        this[setting](options[setting]);\n      }\n    }\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.unset\n   [ method ]\n   *\n   * Remove this interactable from the list of interactables and remove\n   * it's action capabilities and event listeners\n   *\n   = (object) @interact\n  \\*/\n  unset () {\n    events.remove(this.target, 'all');\n\n    if (isType.isString(this.target)) {\n      // remove delegated events\n      for (const type in events.delegatedEvents) {\n        const delegated = events.delegatedEvents[type];\n\n        for (let i = 0; i < delegated.selectors.length; i++) {\n          if (delegated.selectors[i] === this.target\n              && delegated.contexts[i] === this._context) {\n\n            delegated.selectors.splice(i, 1);\n            delegated.contexts .splice(i, 1);\n            delegated.listeners.splice(i, 1);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegated[type] = null;\n            }\n          }\n\n          events.remove(this._context, type, events.delegateListener);\n          events.remove(this._context, type, events.delegateUseCapture, true);\n\n          break;\n        }\n      }\n    }\n    else {\n      events.remove(this, 'all');\n    }\n\n    signals.fire('unset', { interactable: this });\n\n    scope.interactables.splice(indexOf(scope.interactables, this), 1);\n\n    return scope.interact;\n  }\n}\n\nInteractable.signals = signals;\n\nInteractable.settingsMethods = [ 'deltaSource', 'origin', 'preventDefault', 'rectChecker' ];\n\nmodule.exports = Interactable;\n","const scope          = require('./scope');\nconst utils          = require('./utils');\nconst Interactable   = require('./Interactable');\nconst events         = require('./utils/events');\nconst browser        = require('./utils/browser');\nconst finder         = require('./utils/interactionFinder');\nconst signals        = require('./utils/Signals').new();\n\nconst listeners   = {};\nconst methodNames = [\n  'pointerDown', 'pointerMove', 'pointerUp',\n  'addPointer', 'removePointer', 'recordPointer',\n];\n\n// for ignoring browser's simulated mouse events\nlet prevTouchTime = 0;\n\n// all active and idle interactions\nscope.interactions = [];\n\nclass Interaction {\n  constructor () {\n    this.target        = null; // current interactable being interacted with\n    this.element       = null; // the target element of the interactable\n\n    this.prepared      = {     // action that's ready to be fired on next move event\n      name : null,\n      axis : null,\n      edges: null,\n    };\n\n    // keep track of added pointers\n    this.pointers    = [];\n    this.pointerIds  = [];\n    this.downTargets = [];\n    this.downTimes   = [];\n    this.holdTimers  = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      timeStamp: 0,\n    };\n\n    this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget    = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null;      // previous action event\n\n    this.pointerIsDown   = false;\n    this.pointerWasMoved = false;\n    this._interacting    = false;\n\n    this.mouse = false;\n\n    signals.fire('new', this);\n\n    scope.interactions.push(this);\n  }\n\n  setEventXY (targetObj, pointers) {\n    const pointer = (pointers.length > 1\n                     ? utils.pointerAverage(pointers)\n                     : pointers[0]);\n\n    const tmpXY = {};\n\n    utils.getPageXY(pointer, tmpXY, this);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    utils.getClientXY(pointer, tmpXY, this);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = new Date().getTime();\n  }\n\n  pointerDown (pointer, event, eventTarget) {\n    const pointerIndex = this.addPointer(pointer);\n\n    this.pointerIsDown = true;\n\n    if (!this.interacting()) {\n      this.setEventXY(this.curCoords, this.pointers);\n    }\n\n    signals.fire('down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      interaction: this,\n    });\n\n    if (!this.interacting()) {\n      this.pointerIsDown = true;\n      this.downEvent = event;\n\n      this.downTimes[pointerIndex] = new Date().getTime();\n      this.downTargets[pointerIndex] = eventTarget;\n\n      this.pointerWasMoved = false;\n\n      utils.pointerExtend(this.downPointer, pointer);\n      utils.copyCoords(this.prevCoords, this.curCoords);\n    }\n\n    this.checkAndPreventDefault(event);\n  }\n\n  /*\\\n   * Interaction.start\n   [ method ]\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate number\n   * of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   - action       (object)  The action to be performed - drag, resize, etc.\n   - interactable (Interactable) The Interactable to target\n   - element      (Element) The DOM Element to target\n   = (object) interact\n   **\n   | interact(target)\n   |   .draggable({\n   |     // disable the default drag start by down->move\n   |     manualStart: true\n   |   })\n   |   // start dragging after the user holds the pointer down\n   |   .on('hold', function (event) {\n   |     var interaction = event.interaction;\n   |\n   |     if (!interaction.interacting()) {\n   |       interaction.start({ name: 'drag' },\n   |                         event.interactable,\n   |                         event.currentTarget);\n   |     }\n   | });\n   \\*/\n  start (action, interactable, element) {\n    if (this.interacting()\n        || !this.pointerIsDown\n        || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n      return;\n    }\n\n    // if this interaction had been removed after stopping\n    // add it back\n    if (utils.indexOf(scope.interactions, this) === -1) {\n      scope.interactions.push(this);\n    }\n\n    // set the startCoords if there was no prepared action\n    if (!this.prepared.name) {\n      this.setEventXY(this.startCoords, this.pointers);\n    }\n\n    utils.copyAction(this.prepared, action);\n    this.target         = interactable;\n    this.element        = element;\n\n    signals.fire('start', { interaction: this });\n\n    signals.fire('start-' + this.prepared.name, {\n      interaction: this,\n      event: this.downEvent,\n    });\n  }\n\n  pointerMove (pointer, event, eventTarget) {\n    if (!this.simulation) {\n      this.recordPointer(pointer);\n      this.setEventXY(this.curCoords, this.pointers);\n    }\n\n    const duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n                           && this.curCoords.page.y === this.prevCoords.page.y\n                           && this.curCoords.client.x === this.prevCoords.client.x\n                           && this.curCoords.client.y === this.prevCoords.client.y);\n\n    let dx;\n    let dy;\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.curCoords.client.x - this.startCoords.client.x;\n      dy = this.curCoords.client.y - this.startCoords.client.y;\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > scope.pointerMoveTolerance;\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and speeds\n      utils.setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n      const signalArg = {\n        pointer,\n        event,\n        eventTarget,\n        dx,\n        dy,\n        duplicate: duplicateMove,\n        interaction: this,\n        interactingBeforeMove: this.interacting(),\n      };\n\n      signals.fire('move', signalArg);\n\n      // if interacting, fire a 'move-{action}' signal\n      if (this.interacting()) {\n        this.doMove(signalArg);\n        this.checkAndPreventDefault(event);\n      }\n\n      if (this.pointerWasMoved) {\n        utils.copyCoords(this.prevCoords, this.curCoords);\n      }\n\n      signals.fire('move-done', signalArg);\n    }\n  }\n\n  /*\\\n   * Interaction.doMove\n   [ method ]\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   *\n   **\n   | interact(target)\n   |   .draggable(true)\n   |   .on('dragmove', function (event) {\n   |     if (someCondition) {\n   |       // change the snap settings\n   |       event.interactable.draggable({ snap: { targets: [] }});\n   |       // fire another move event with re-calculated snap\n   |       event.interaction.doMove();\n   |     }\n   |   });\n   \\*/\n  doMove (signalArg) {\n    signalArg = utils.extend({\n      pointer: this.pointers[0],\n      event: this.prevEvent,\n      eventTarget: this._eventTarget,\n      interaction: this,\n    }, signalArg || {});\n\n    signals.fire('before-action-move', signalArg);\n\n    if (!this._dontFireMove) {\n      signals.fire('move-' + this.prepared.name, signalArg);\n    }\n\n    this._dontFireMove = false;\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer, event, eventTarget, curEventTarget) {\n    const pointerIndex = this.mouse? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    clearTimeout(this.holdTimers[pointerIndex]);\n\n    signals.fire(/cancel$/i.test(event.type)? 'cancel' : 'up', {\n      pointer,\n      event,\n      eventTarget,\n      curEventTarget,\n      interaction: this,\n    });\n\n    if (!this.simulation) {\n      this.end(event);\n      this.removePointer(pointer);\n    }\n  }\n\n  /*\\\n   * Interaction.end\n   [ method ]\n   *\n   * Stop the current action and fire an end event. Inertial movement does\n   * not happen.\n   *\n   - event (PointerEvent) #optional\n   **\n   | interact(target)\n   |   .draggable(true)\n   |   .on('move', function (event) {\n   |     if (event.pageX > 1000) {\n   |       // end the current action\n   |       event.interaction.end();\n   |       // stop all further listeners from being called\n   |       event.stopImmediatePropagation();\n   |     }\n   |   });\n   \\*/\n  end (event) {\n    event = event || this.prevEvent;\n\n    if (this.interacting()) {\n      signals.fire('action-end', {\n        event,\n        interaction: this,\n      });\n    }\n\n    this.stop(event);\n  }\n\n  currentAction () {\n    return this._interacting? this.prepared.name: null;\n  }\n\n  interacting () {\n    return this._interacting;\n  }\n\n  stop (event) {\n    signals.fire('stop', { interaction: this });\n\n    if (this._interacting) {\n      signals.fire('stop-active', { interaction: this });\n\n      // prevent Default only if were previously interacting\n      if (event && utils.isFunction(event.preventDefault)) {\n        this.checkAndPreventDefault(event);\n      }\n\n      signals.fire('stop-' + this.prepared.name, {\n        event,\n        interaction: this,\n      });\n    }\n\n    this.target = this.element = null;\n\n    this.pointerIsDown = this._interacting = false;\n    this.prepared.name = this.prevEvent = null;\n  }\n\n  addPointer (pointer) {\n    const id = utils.getPointerId(pointer);\n    let index = this.mouse? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) {\n      index = this.pointerIds.length;\n    }\n\n    this.pointerIds[index] = id;\n    this.pointers[index] = pointer;\n\n    return index;\n  }\n\n  removePointer (pointer) {\n    const id = utils.getPointerId(pointer);\n    const index = this.mouse? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) { return; }\n\n    this.pointers   .splice(index, 1);\n    this.pointerIds .splice(index, 1);\n    this.downTargets.splice(index, 1);\n    this.downTimes  .splice(index, 1);\n    this.holdTimers .splice(index, 1);\n  }\n\n  recordPointer (pointer) {\n    const index = this.mouse? 0: utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    if (index === -1) { return; }\n\n    this.pointers[index] = pointer;\n  }\n\n  checkAndPreventDefault (event) {\n    const setting = this.target && this.target.options.preventDefault;\n\n    if (!this.target || setting === 'never') { return; }\n\n    if (setting === 'always') {\n      event.preventDefault();\n      return;\n    }\n\n    // setting === 'auto'\n\n    // don't preventDefault on input elements\n    if (/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n      return;\n    }\n\n    const actionOptions = this.target.options[this.prepared.name];\n\n    // Do not preventDefault on pointerdown if the prepared action is delayed\n    // or it is a drag and dragging can only start from a certain direction.\n    // This allows a touch to pan the viewport if the action doesn't actually\n    // start>\n    if (/down|start/i.test(event.type)\n        && ((this.prepared.name === 'drag' && actionOptions.startAxis !== 'xy')\n            || (actionOptions && actionOptions.delay > 0))) {\n\n      return;\n    }\n\n    // with manualStart, only preventDefault while interacting\n    if (actionOptions && actionOptions.manualStart\n        && !this.interacting()) {\n      return;\n    }\n\n    event.preventDefault();\n  }\n\n  _updateEventTargets (target, currentTarget) {\n    this._eventTarget    = target;\n    this._curEventTarget = currentTarget;\n  }\n}\n\n// Check if the current target supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction (action, interactable) {\n  if (utils.isObject(action) && interactable.options[action.name].enabled) {\n    return action;\n  }\n\n  return null;\n}\n\nfor (let i = 0, len = methodNames.length; i < len; i++) {\n  const method = methodNames[i];\n\n  listeners[method] = doOnInteractions(method);\n}\n\nfunction doOnInteractions (method) {\n  return (function (event) {\n    const eventTarget = utils.getActualElement(event.path ? event.path[0] : event.target);\n    const curEventTarget = utils.getActualElement(event.currentTarget);\n    const matches = []; // [ [pointer, interaction], ...]\n\n    if (browser.supportsTouch && /touch/.test(event.type)) {\n      prevTouchTime = new Date().getTime();\n\n      for (let i = 0; i < event.changedTouches.length; i++) {\n        const pointer = event.changedTouches[i];\n        const interaction = finder.search(pointer, event.type, eventTarget);\n\n        matches.push([pointer, interaction || new Interaction()]);\n      }\n    }\n    else {\n      let invalidPointer = false;\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n          invalidPointer = !scope.interactions[i].mouse && scope.interactions[i].pointerIsDown;\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer || (new Date().getTime() - prevTouchTime < 500);\n      }\n\n      if (!invalidPointer) {\n        let interaction = finder.search(event, event.type, eventTarget);\n\n        if (!interaction) {\n\n          interaction = new Interaction();\n          interaction.mouse = (/mouse/i.test(event.pointerType || event.type)\n                               // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                               || event.pointerType === 4);\n        }\n\n        matches.push([event, interaction]);\n      }\n    }\n\n    for (const [pointer, interaction] of matches) {\n      interaction._updateEventTargets(eventTarget, curEventTarget);\n      interaction[method](pointer, event, eventTarget, curEventTarget);\n    }\n  });\n}\n\nscope.signals.on('listen-to-document', function ({ doc, win }) {\n  const pEventTypes = browser.pEventTypes;\n\n  // add delegate event listener\n  for (const eventType in scope.delegatedEvents) {\n    events.add(doc, eventType, events.delegateListener);\n    events.add(doc, eventType, events.delegateUseCapture, true);\n  }\n\n  if (scope.PointerEvent) {\n    events.add(doc, pEventTypes.down  , listeners.pointerDown  );\n    events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n    events.add(doc, pEventTypes.move  , listeners.pointerHover );\n    events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n    events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n    events.add(doc, pEventTypes.cancel, listeners.pointerUp    );\n  }\n  else {\n    events.add(doc, 'mousedown', listeners.pointerDown );\n    events.add(doc, 'mousemove', listeners.pointerMove );\n    events.add(doc, 'mousemove', listeners.pointerHover);\n    events.add(doc, 'mouseup'  , listeners.pointerUp   );\n    events.add(doc, 'mouseout' , listeners.pointerOut  );\n\n    events.add(doc, 'touchstart' , listeners.pointerDown  );\n    events.add(doc, 'touchmove'  , listeners.pointerMove  );\n    events.add(doc, 'touchend'   , listeners.pointerUp    );\n    events.add(doc, 'touchcancel', listeners.pointerUp    );\n  }\n\n  events.add(win, 'blur', scope.endAllInteractions);\n\n  try {\n    if (win.frameElement) {\n      const parentDoc = win.frameElement.ownerDocument;\n      const parentWindow = parentDoc.defaultView;\n\n      events.add(parentDoc   , 'mouseup'      , listeners.pointerUp);\n      events.add(parentDoc   , 'touchend'     , listeners.pointerUp);\n      events.add(parentDoc   , 'touchcancel'  , listeners.pointerUp);\n      events.add(parentDoc   , 'pointerup'    , listeners.pointerUp);\n      events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerUp);\n      events.add(parentWindow, 'blur'         , scope.endAllInteractions );\n    }\n  }\n  catch (error) {\n    scope.windowParentError = error;\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  events.add(doc, 'dragstart', function (event) {\n    for (const interaction of scope.interactions) {\n\n      if (interaction.element\n          && (interaction.element === event.target\n              || utils.nodeContains(interaction.element, event.target))) {\n\n        interaction.checkAndPreventDefault(event);\n        return;\n      }\n    }\n  });\n\n  scope.documents.push(doc);\n  events.documents.push(doc);\n});\n\nscope.signals.fire('listen-to-document', {\n  win: scope.window,\n  doc: scope.document,\n});\n\n// Stop related interactions when an Interactable is unset\nInteractable.signals.on('unset', function ( {interactable} ) {\n  for (const interaction of scope.interactions) {\n    if (interaction.target === interactable && interaction.interacting()) {\n      interaction.end();\n    }\n  }\n});\n\nInteraction.doOnInteractions = doOnInteractions;\nInteraction.withinLimit = scope.withinInteractionLimit;\nInteraction.validateAction = validateAction;\nInteraction.signals = signals;\n\nmodule.exports = Interaction;\n","const actions = require('./index');\nconst scope = require('../scope');\nconst utils = require('../utils');\nconst InteractEvent = require('../InteractEvent');\nconst Interactable = require('../Interactable');\nconst Interaction = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst drag = {\n  defaults: {\n    enabled      : false,\n    manualStart  : true,\n    max          : Infinity,\n    maxPerElement: 1,\n\n    snap      : null,\n    restrict  : null,\n    inertia   : null,\n    autoScroll: null,\n\n    startAxis: 'xy',\n    lockAxis : 'xy',\n  },\n\n  checker: function (pointer, event, interactable) {\n    const dragOptions = interactable.options.drag;\n\n    return dragOptions.enabled\n      ? { name: 'drag', axis: (dragOptions.lockAxis === 'start'\n                               ? dragOptions.startAxis\n                               : dragOptions.lockAxis)}\n      : null;\n  },\n\n  getCursor: function () {\n    return 'move';\n  },\n};\n\nInteraction.signals.on('start-drag', function ({ interaction, event }) {\n  const dragEvent = new InteractEvent(interaction, event, 'drag', 'start', interaction.element);\n\n  interaction._interacting = true;\n  interaction.target.fire(dragEvent);\n  interaction.prevEvent = dragEvent;\n});\n\nInteraction.signals.on('before-action-move', function ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  const axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    interaction.curCoords.page.y   = interaction.startCoords.page.y;\n    interaction.curCoords.client.y = interaction.startCoords.client.y;\n\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vx);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\n    interaction.pointerDelta.client.vy = 0;\n    interaction.pointerDelta.page.vy   = 0;\n  }\n  else if (axis === 'y') {\n    interaction.curCoords.page.x   = interaction.startCoords.page.x;\n    interaction.curCoords.client.x = interaction.startCoords.client.x;\n\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vy);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\n    interaction.pointerDelta.client.vx = 0;\n    interaction.pointerDelta.page.vx   = 0;\n  }\n});\n\nInteraction.signals.on('move-drag', function ({ interaction, event }) {\n  const dragEvent = new InteractEvent(interaction, event, 'drag', 'move', interaction.element);\n\n  const axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    dragEvent.pageY   = interaction.startCoords.page.y;\n    dragEvent.clientY = interaction.startCoords.client.y;\n    dragEvent.dy = 0;\n  }\n  else if (axis === 'y') {\n    dragEvent.pageX   = interaction.startCoords.page.x;\n    dragEvent.clientX = interaction.startCoords.client.x;\n    dragEvent.dx = 0;\n  }\n\n  interaction.target.fire(dragEvent);\n  interaction.prevEvent = dragEvent;\n\n  // if the action was ended in a dragmove listener\n  if (!interaction.interacting()) { return false; }\n});\n\nInteraction.signals.on('action-end', function ({ interaction, event }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  const dragEvent = new InteractEvent(interaction, event, 'drag', 'end', interaction.element);\n\n  interaction.target.fire(dragEvent);\n  interaction.prevEvent = dragEvent;\n});\n\n/*\\\n * Interactable.draggable\n [ method ]\n *\n * Gets or sets whether drag actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of drag events\n | var isDraggable = interact('ul li').draggable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n = (object) This Interactable\n | interact(element).draggable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // the axis in which the first movement must be\n |     // for the drag sequence to start\n |     // 'xy' by default - any direction\n |     startAxis: 'x' || 'y' || 'xy',\n |\n |     // 'xy' by default - don't restrict to one axis (move in any direction)\n |     // 'x' or 'y' to restrict movement to either axis\n |     // 'start' to restrict movement to the axis the drag started in\n |     lockAxis: 'x' || 'y' || 'xy' || 'start',\n |\n |     // max number of drags that can happen concurrently\n |     // with elements of this Interactable. Infinity by default\n |     max: Infinity,\n |\n |     // max number of drags that can target the same element+Interactable\n |     // 1 by default\n |     maxPerElement: 2\n | });\n\\*/\nInteractable.prototype.draggable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drag.enabled = options.enabled === false? false: true;\n    this.setPerAction('drag', options);\n    this.setOnEvents('drag', options);\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis;\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drag.enabled = options;\n\n    return this;\n  }\n\n  return this.options.drag;\n};\n\nactions.drag = drag;\nactions.names.push('drag');\nutils.merge(scope.eventTypes, [\n  'dragstart',\n  'dragmove',\n  'draginertiastart',\n  'dragend',\n]);\nactions.methodDict.drag = 'draggable';\n\ndefaultOptions.drag = drag.defaults;\n\nmodule.exports = drag;\n","const actions = require('./index');\nconst utils = require('../utils');\nconst scope = require('../scope');\nconst InteractEvent = require('../InteractEvent');\nconst Interactable = require('../Interactable');\nconst Interaction = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst drop = {\n  defaults: {\n    enabled: false,\n    accept : null,\n    overlap: 'pointer',\n  },\n};\n\nInteraction.signals.on('start-drag', function ({ interaction, event }) {\n  // reset active dropzones\n  interaction.activeDrops.dropzones = [];\n  interaction.activeDrops.elements  = [];\n  interaction.activeDrops.rects     = [];\n\n  interaction.dropEvents = null;\n\n  if (!interaction.dynamicDrop) {\n    setActiveDrops(interaction, interaction.element);\n  }\n\n  const dragEvent = interaction.prevEvent;\n  const dropEvents = getDropEvents(interaction, event, dragEvent);\n\n  if (dropEvents.activate) {\n    fireActiveDrops(interaction, dropEvents.activate);\n  }\n});\n\nInteractEvent.signals.on('new-drag', function ({ interaction, iEvent, event }) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') { return; }\n\n  const draggableElement = interaction.element;\n  const dragEvent = iEvent;\n  const dropResult = getDrop(dragEvent, event, draggableElement);\n\n  interaction.dropTarget  = dropResult.dropzone;\n  interaction.dropElement = dropResult.element;\n\n  interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\n});\n\nInteraction.signals.on('move-drag', function ({ interaction }) {\n  fireDropEvents(interaction, interaction.dropEvents);\n});\n\nInteraction.signals.on('action-end', function ({ interaction }) {\n  if (interaction.prepared.name === 'drag') {\n    fireDropEvents(interaction, interaction.dropEvents);\n  }\n});\n\nInteraction.signals.on('stop-drag', function ({ interaction }) {\n  interaction.activeDrops.dropzones =\n    interaction.activeDrops.elements =\n    interaction.activeDrops.rects =\n    interaction.dropEvents = null;\n});\n\nfunction collectDrops (interaction, element) {\n  const drops = [];\n  const elements = [];\n\n  element = element || interaction.element;\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const current of scope.interactables) {\n    if (!current.options.drop.enabled) { continue; }\n\n    const accept = current.options.drop.accept;\n\n    // test the draggable element against the dropzone's accept setting\n    if ((utils.isElement(accept) && accept !== element)\n        || (utils.isString(accept)\n        && !utils.matchesSelector(element, accept))) {\n\n      continue;\n    }\n\n    // query for new elements if necessary\n    const dropElements = utils.isString(current.target)\n      ? current._context.querySelectorAll(current.target)\n      : [current.target];\n\n    for (let i = 0; i < dropElements.length; i++) {\n      const currentElement = dropElements[i];\n\n      if (currentElement !== element) {\n        drops.push(current);\n        elements.push(currentElement);\n      }\n    }\n  }\n\n  return {\n    elements,\n    dropzones: drops,\n  };\n}\n\nfunction fireActiveDrops (interaction, event) {\n  let prevElement;\n\n  // loop through all active dropzones and trigger event\n  for (let i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    const current = interaction.activeDrops.dropzones[i];\n    const currentElement = interaction.activeDrops.elements [i];\n\n    // prevent trigger of duplicate events on same element\n    if (currentElement !== prevElement) {\n      // set current element as event target\n      event.target = currentElement;\n      current.fire(event);\n    }\n    prevElement = currentElement;\n  }\n}\n\n// Collect a new set of possible drops and save them in activeDrops.\n// setActiveDrops should always be called when a drag has just started or a\n// drag event happens while dynamicDrop is true\nfunction setActiveDrops (interaction, dragElement) {\n  // get dropzones and their elements that could receive the draggable\n  const possibleDrops = collectDrops(interaction, dragElement, true);\n\n  interaction.activeDrops.dropzones = possibleDrops.dropzones;\n  interaction.activeDrops.elements  = possibleDrops.elements;\n  interaction.activeDrops.rects     = [];\n\n  for (let i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    interaction.activeDrops.rects[i] =\n      interaction.activeDrops.dropzones[i].getRect(interaction.activeDrops.elements[i]);\n  }\n}\n\nfunction getDrop (dragEvent, event, dragElement) {\n  const interaction = dragEvent.interaction;\n  const validDrops = [];\n\n  if (scope.dynamicDrop) {\n    setActiveDrops(interaction, dragElement);\n  }\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (let j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n    const current        = interaction.activeDrops.dropzones[j];\n    const currentElement = interaction.activeDrops.elements [j];\n    const rect           = interaction.activeDrops.rects    [j];\n\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect)\n      ? currentElement\n      : null);\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = utils.indexOfDeepestElement(validDrops);\n\n  return {\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n    element : interaction.activeDrops.elements [dropIndex] || null,\n  };\n}\n\nfunction getDropEvents (interaction, pointerEvent, dragEvent) {\n  const dropEvents = {\n    enter     : null,\n    leave     : null,\n    activate  : null,\n    deactivate: null,\n    move      : null,\n    drop      : null,\n  };\n\n  const tmpl = {\n    dragEvent,\n    interaction,\n    target       : interaction.dropElement,\n    dropzone     : interaction.dropTarget,\n    relatedTarget: dragEvent.target,\n    draggable    : dragEvent.interactable,\n    timeStamp    : dragEvent.timeStamp,\n  };\n\n  if (interaction.dropElement !== interaction.prevDropElement) {\n    // if there was a prevDropTarget, create a dragleave event\n    if (interaction.prevDropTarget) {\n      dropEvents.leave = utils.extend({ type: 'dragleave' }, tmpl);\n\n      dragEvent.dragLeave    = dropEvents.leave.target   = interaction.prevDropElement;\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\n    }\n    // if the dropTarget is not null, create a dragenter event\n    if (interaction.dropTarget) {\n      dropEvents.enter = {\n        dragEvent,\n        interaction,\n        target       : interaction.dropElement,\n        dropzone     : interaction.dropTarget,\n        relatedTarget: dragEvent.target,\n        draggable    : dragEvent.interactable,\n        timeStamp    : dragEvent.timeStamp,\n        type         : 'dragenter',\n      };\n\n      dragEvent.dragEnter = interaction.dropElement;\n      dragEvent.dropzone = interaction.dropTarget;\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n    dropEvents.drop = utils.extend({ type: 'drop' }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = utils.extend({ type: 'dropactivate' }, tmpl);\n\n    dropEvents.activate.target   = null;\n    dropEvents.activate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = utils.extend({ type: 'dropdeactivate' }, tmpl);\n\n    dropEvents.deactivate.target   = null;\n    dropEvents.deactivate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n    dropEvents.move = utils.extend({\n      dragmove     : dragEvent,\n      type         : 'dropmove',\n    }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n\n  return dropEvents;\n}\n\nfunction fireDropEvents (interaction, dropEvents) {\n  if (dropEvents.leave) { interaction.prevDropTarget.fire(dropEvents.leave); }\n  if (dropEvents.enter) {     interaction.dropTarget.fire(dropEvents.enter); }\n  if (dropEvents.drop ) {     interaction.dropTarget.fire(dropEvents.drop ); }\n  if (dropEvents.deactivate) {\n    fireActiveDrops(interaction, dropEvents.deactivate);\n  }\n\n  interaction.prevDropTarget  = interaction.dropTarget;\n  interaction.prevDropElement = interaction.dropElement;\n}\n\n/*\\\n * Interactable.dropzone\n [ method ]\n *\n * Returns or sets whether elements can be dropped onto this\n * Interactable to trigger drop events\n *\n * Dropzones can receive the following events:\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n *  - `dragmove` when a draggable that has entered the dropzone is moved\n *  - `drop` when a draggable is dropped into this dropzone\n *\n * Use the `accept` option to allow only elements that match the given CSS\n * selector or element. The value can be:\n *\n *  - **an Element** - only that element can be dropped into this dropzone.\n *  - **a string**, - the element being dragged must match it as a CSS selector.\n *  - **`null`** - accept options is cleared - it accepts any element.\n *\n * Use the `overlap` option to set how drops are checked for. The allowed\n * values are:\n *\n *   - `'pointer'`, the pointer must be over the dropzone (default)\n *   - `'center'`, the draggable element's center must be over the dropzone\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n *   over the dropzone\n *\n * Use the `checker` option to specify a function to check if a dragged\n * element is over this Interactable.\n *\n | interact(target)\n | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n |                       event,             // TouchEvent/PointerEvent/MouseEvent\n |                       dropped,           // bool result of the default checker\n |                       dropzone,          // dropzone Interactable\n |                       dropElement,       // dropzone elemnt\n |                       draggable,         // draggable Interactable\n |                       draggableElement) {// draggable element\n |\n |   return dropped && event.target.hasAttribute('allow-drop');\n | }\n *\n *\n - options (boolean | object | null) #optional The new value to be set.\n | interact('.drop').dropzone({\n |   accept: '.can-drop' || document.getElementById('single-drop'),\n |   overlap: 'pointer' || 'center' || zeroToOne\n | }\n = (boolean | object) The current setting or this Interactable\n\\*/\nInteractable.prototype.dropzone = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drop.enabled = options.enabled === false? false: true;\n\n    if (utils.isFunction(options.ondrop)          ) { this.ondrop           = options.ondrop          ; }\n    if (utils.isFunction(options.ondropactivate)  ) { this.ondropactivate   = options.ondropactivate  ; }\n    if (utils.isFunction(options.ondropdeactivate)) { this.ondropdeactivate = options.ondropdeactivate; }\n    if (utils.isFunction(options.ondragenter)     ) { this.ondragenter      = options.ondragenter     ; }\n    if (utils.isFunction(options.ondragleave)     ) { this.ondragleave      = options.ondragleave     ; }\n    if (utils.isFunction(options.ondropmove)      ) { this.ondropmove       = options.ondropmove      ; }\n\n    if (/^(pointer|center)$/.test(options.overlap)) {\n      this.options.drop.overlap = options.overlap;\n    }\n    else if (utils.isNumber(options.overlap)) {\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n    }\n    if ('accept' in options) {\n      this.options.drop.accept = options.accept;\n    }\n    if ('checker' in options) {\n      this.options.drop.checker = options.checker;\n    }\n\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drop.enabled = options;\n\n    return this;\n  }\n\n  return this.options.drop;\n};\n\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n  let dropped = false;\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || this.getRect(dropElement))) {\n    return (this.options.drop.checker\n      ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n      : false);\n  }\n\n  const dropOverlap = this.options.drop.overlap;\n\n  if (dropOverlap === 'pointer') {\n    const origin = utils.getOriginXY(draggable, draggableElement);\n    const page = utils.getPageXY(dragEvent);\n    let horizontal;\n    let vertical;\n\n    page.x += origin.x;\n    page.y += origin.y;\n\n    horizontal = (page.x > rect.left) && (page.x < rect.right);\n    vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n    dropped = horizontal && vertical;\n  }\n\n  const dragRect = draggable.getRect(draggableElement);\n\n  if (dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width  / 2;\n    const cy = dragRect.top  + dragRect.height / 2;\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n  }\n\n  if (utils.isNumber(dropOverlap)) {\n    const overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                          * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top )));\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n    dropped = overlapRatio >= dropOverlap;\n  }\n\n  if (this.options.drop.checker) {\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n  }\n\n  return dropped;\n};\n\nInteractable.signals.on('unset', function ({ interactable }) {\n  interactable.dropzone(false);\n});\n\nInteractable.settingsMethods.push('dropChecker');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.dropTarget      = null; // the dropzone a drag target might be dropped into\n  interaction.dropElement     = null; // the element at the time of checking\n  interaction.prevDropTarget  = null; // the dropzone that was recently dragged away from\n  interaction.prevDropElement = null; // the element at the time of checking\n  interaction.dropEvents      = null; // the dropEvents related to the current drag event\n\n  interaction.activeDrops = {\n    dropzones: [],      // the dropzones that are mentioned below\n    elements : [],      // elements of dropzones that accept the target draggable\n    rects    : [],      // the rects of the elements mentioned above\n  };\n\n});\n\nInteraction.signals.on('stop', function ({ interaction }) {\n  interaction.dropTarget = interaction.dropElement =\n    interaction.prevDropTarget = interaction.prevDropElement = null;\n});\n\nutils.merge(scope.eventTypes, [\n  'dragenter',\n  'dragleave',\n  'dropactivate',\n  'dropdeactivate',\n  'dropmove',\n  'drop',\n]);\nactions.methodDict.drop = 'dropzone';\n\ndefaultOptions.drop = drop.defaults;\n\nmodule.exports = drop;\n","const actions = require('./index');\nconst utils = require('../utils');\nconst InteractEvent = require('../InteractEvent');\nconst Interactable = require('../Interactable');\nconst Interaction = require('../Interaction');\nconst scope = require('../scope');\nconst defaultOptions = require('../defaultOptions');\n\nconst gesture = {\n  defaults: {\n    manualStart  : false,\n    enabled      : false,\n    max          : Infinity,\n    maxPerElement: 1,\n\n    restrict: null,\n  },\n\n  checker: function (pointer, event, interactable, element, interaction) {\n    if (interaction.pointerIds.length >= 2) {\n      return { name: 'gesture' };\n    }\n\n    return null;\n  },\n\n  getCursor: function () {\n    return '';\n  },\n};\n\nInteraction.signals.on('start-gesture', function ({ interaction, event }) {\n  const gestureEvent = new InteractEvent(interaction, event, 'gesture', 'start', interaction.element);\n\n  gestureEvent.ds = 0;\n\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = gestureEvent.distance;\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = gestureEvent.angle;\n  interaction.gesture.scale = 1;\n\n  interaction._interacting = true;\n\n  interaction.target.fire(gestureEvent);\n  interaction.prevEvent = gestureEvent;\n});\n\nInteraction.signals.on('move-gesture', function ({ interaction, event }) {\n  if (!interaction.pointerIds.length) {\n    return interaction.prevEvent;\n  }\n\n  let gestureEvent;\n\n  gestureEvent = new InteractEvent(interaction, event, 'gesture', 'move', interaction.element);\n  gestureEvent.ds = gestureEvent.scale - interaction.gesture.scale;\n\n  interaction.target.fire(gestureEvent);\n\n  interaction.gesture.prevAngle = gestureEvent.angle;\n  interaction.gesture.prevDistance = gestureEvent.distance;\n\n  if (gestureEvent.scale !== Infinity\n      && gestureEvent.scale !== null\n      && gestureEvent.scale !== undefined\n      && !isNaN(gestureEvent.scale)) {\n\n    interaction.gesture.scale = gestureEvent.scale;\n  }\n\n  interaction.prevEvent = gestureEvent;\n\n  // if the action was ended in a gesturemove listener\n  if (!interaction.interacting()) { return false; }\n});\n\nInteraction.signals.on('action-end', function ({ interaction, event }) {\n  if (interaction.prepared.name !== 'gesture') { return; }\n\n  const gestureEvent = new InteractEvent(interaction, event, 'gesture', 'end', interaction.element);\n\n  interaction.target.fire(gestureEvent);\n  interaction.prevEvent = gestureEvent;\n});\n\n/*\\\n * Interactable.gesturable\n [ method ]\n *\n * Gets or sets whether multitouch gestures can be performed on the\n * Interactable's element\n *\n = (boolean) Indicates if this can be the target of gesture events\n   | var isGestureable = interact(element).gesturable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n = (object) this Interactable\n | interact(element).gesturable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // limit multiple gestures.\n |     // See the explanation in @Interactable.draggable example\n |     max: Infinity,\n |     maxPerElement: 1,\n | });\n\\*/\nInteractable.prototype.gesturable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.gesture.enabled = options.enabled === false? false: true;\n    this.setPerAction('gesture', options);\n    this.setOnEvents('gesture', options);\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.gesture.enabled = options;\n\n    return this;\n  }\n\n  return this.options.gesture;\n};\n\nInteractEvent.signals.on('gesture', function (arg) {\n  if (arg.action !== 'gesture') { return; }\n\n  const { interaction, iEvent, event, starting, ending, deltaSource } = arg;\n  const pointers = interaction.pointers;\n\n  iEvent.touches = [pointers[0], pointers[1]];\n\n  if (starting) {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box      = utils.touchBBox(pointers);\n    iEvent.scale    = 1;\n    iEvent.ds       = 0;\n    iEvent.angle    = utils.touchAngle(pointers, undefined, deltaSource);\n    iEvent.da       = 0;\n  }\n  else if (ending || event instanceof InteractEvent) {\n    iEvent.distance = interaction.prevEvent.distance;\n    iEvent.box      = interaction.prevEvent.box;\n    iEvent.scale    = interaction.prevEvent.scale;\n    iEvent.ds       = iEvent.scale - 1;\n    iEvent.angle    = interaction.prevEvent.angle;\n    iEvent.da       = iEvent.angle - interaction.gesture.startAngle;\n  }\n  else {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box      = utils.touchBBox(pointers);\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance;\n    iEvent.angle    = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n  }\n});\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.gesture = {\n    start: { x: 0, y: 0 },\n\n    startDistance: 0,   // distance between two touches of touchStart\n    prevDistance : 0,\n    distance     : 0,\n\n    scale: 1,           // gesture.distance / gesture.startDistance\n\n    startAngle: 0,      // angle of line joining two touches\n    prevAngle : 0,      // angle of the previous gesture event\n  };\n});\n\nactions.gesture = gesture;\nactions.names.push('gesture');\nutils.merge(scope.eventTypes, [\n  'gesturestart',\n  'gesturemove',\n  'gestureinertiastart',\n  'gestureend',\n]);\nactions.methodDict.gesture = 'gesturable';\n\ndefaultOptions.gesture = gesture.defaults;\n\nmodule.exports = gesture;\n","const actions = {\n  names: [],\n  methodDict: {},\n};\n\nmodule.exports = actions;\n","const actions = require('./index');\nconst utils = require('../utils');\nconst browser = require('../utils/browser');\nconst scope = require('../scope');\nconst InteractEvent = require('../InteractEvent');\nconst Interactable = require('../Interactable');\nconst Interaction = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst resize = {\n  defaults: {\n    enabled      : false,\n    manualStart  : false,\n    max          : Infinity,\n    maxPerElement: 1,\n\n    snap      : null,\n    restrict  : null,\n    inertia   : null,\n    autoScroll: null,\n\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  },\n\n  checker: function (pointer, event, interactable, element, interaction, rect) {\n    if (!rect) { return null; }\n\n    const page = utils.extend({}, interaction.curCoords.page);\n    const options = interactable.options;\n\n    if (options.resize.enabled) {\n      const resizeOptions = options.resize;\n      const resizeEdges = { left: false, right: false, top: false, bottom: false };\n\n      // if using resize.edges\n      if (utils.isObject(resizeOptions.edges)) {\n        for (const edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge,\n                                              resizeOptions.edges[edge],\n                                              page,\n                                              interaction._eventTarget,\n                                              element,\n                                              rect,\n                                              resizeOptions.margin || scope.margin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: 'resize',\n            edges: resizeEdges,\n          };\n        }\n      }\n      else {\n        const right  = options.resize.axis !== 'y' && page.x > (rect.right  - scope.margin);\n        const bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - scope.margin);\n\n        if (right || bottom) {\n          return {\n            name: 'resize',\n            axes: (right? 'x' : '') + (bottom? 'y' : ''),\n          };\n        }\n      }\n    }\n\n    return null;\n  },\n\n  cursors: (browser.isIe9OrOlder ? {\n    x : 'e-resize',\n    y : 's-resize',\n    xy: 'se-resize',\n\n    top        : 'n-resize',\n    left       : 'w-resize',\n    bottom     : 's-resize',\n    right      : 'e-resize',\n    topleft    : 'se-resize',\n    bottomright: 'se-resize',\n    topright   : 'ne-resize',\n    bottomleft : 'ne-resize',\n  } : {\n    x : 'ew-resize',\n    y : 'ns-resize',\n    xy: 'nwse-resize',\n\n    top        : 'ns-resize',\n    left       : 'ew-resize',\n    bottom     : 'ns-resize',\n    right      : 'ew-resize',\n    topleft    : 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright   : 'nesw-resize',\n    bottomleft : 'nesw-resize',\n  }),\n\n  getCursor: function (action) {\n    if (action.axis) {\n      return resize.cursors[action.name + action.axis];\n    }\n    else if (action.edges) {\n      let cursorKey = '';\n      const edgeNames = ['top', 'bottom', 'left', 'right'];\n\n      for (let i = 0; i < 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i];\n        }\n      }\n\n      return resize.cursors[cursorKey];\n    }\n  },\n};\n\nInteraction.signals.on('start-resize', function ({ interaction, event }) {\n  const resizeEvent = new InteractEvent(interaction, event, 'resize', 'start', interaction.element);\n\n  if (interaction.prepared.edges) {\n    const startRect = interaction.target.getRect(interaction.element);\n    const resizeOptions = interaction.target.options.resize;\n\n    /*\n     * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n     * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n     * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n     * on the active edges and the edge being interacted with.\n     */\n    if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n      const linkedEdges = utils.extend({}, interaction.prepared.edges);\n\n      linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n      linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n      linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n      linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n      interaction.prepared._linkedEdges = linkedEdges;\n    }\n    else {\n      interaction.prepared._linkedEdges = null;\n    }\n\n    // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n    if (resizeOptions.preserveAspectRatio) {\n      interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n    }\n\n    interaction.resizeRects = {\n      start     : startRect,\n      current   : utils.extend({}, startRect),\n      restricted: utils.extend({}, startRect),\n      previous  : utils.extend({}, startRect),\n      delta     : {\n        left: 0, right : 0, width : 0,\n        top : 0, bottom: 0, height: 0,\n      },\n    };\n\n    resizeEvent.rect = interaction.resizeRects.restricted;\n    resizeEvent.deltaRect = interaction.resizeRects.delta;\n  }\n\n  interaction.target.fire(resizeEvent);\n\n  interaction._interacting = true;\n\n  interaction.prevEvent = resizeEvent;\n});\n\nInteraction.signals.on('move-resize', function ({ interaction, event }) {\n  const resizeEvent = new InteractEvent(interaction, event, 'resize', 'move', interaction.element);\n  const resizeOptions = interaction.target.options.resize;\n  const invert = resizeOptions.invert;\n  const invertible = invert === 'reposition' || invert === 'negate';\n\n  let edges = interaction.prepared.edges;\n\n  if (edges) {\n    const start      = interaction.resizeRects.start;\n    const current    = interaction.resizeRects.current;\n    const restricted = interaction.resizeRects.restricted;\n    const delta      = interaction.resizeRects.delta;\n    const previous   = utils.extend(interaction.resizeRects.previous, restricted);\n    const originalEdges = edges;\n\n    let dx = resizeEvent.dx;\n    let dy = resizeEvent.dy;\n\n    if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n      // `resize.preserveAspectRatio` takes precedence over `resize.square`\n      const startAspectRatio = resizeOptions.preserveAspectRatio\n        ? interaction.resizeStartAspectRatio\n        : 1;\n\n      edges = interaction.prepared._linkedEdges;\n\n      if ((originalEdges.left && originalEdges.bottom)\n          || (originalEdges.right && originalEdges.top)) {\n        dy = -dx / startAspectRatio;\n      }\n      else if (originalEdges.left || originalEdges.right ) { dy = dx / startAspectRatio; }\n      else if (originalEdges.top  || originalEdges.bottom) { dx = dy * startAspectRatio; }\n    }\n\n    // update the 'current' rect without modifications\n    if (edges.top   ) { current.top    += dy; }\n    if (edges.bottom) { current.bottom += dy; }\n    if (edges.left  ) { current.left   += dx; }\n    if (edges.right ) { current.right  += dx; }\n\n    if (invertible) {\n      // if invertible, copy the current rect\n      utils.extend(restricted, current);\n\n      if (invert === 'reposition') {\n        // swap edge values if necessary to keep width/height positive\n        let swap;\n\n        if (restricted.top > restricted.bottom) {\n          swap = restricted.top;\n\n          restricted.top = restricted.bottom;\n          restricted.bottom = swap;\n        }\n        if (restricted.left > restricted.right) {\n          swap = restricted.left;\n\n          restricted.left = restricted.right;\n          restricted.right = swap;\n        }\n      }\n    }\n    else {\n      // if not invertible, restrict to minimum of 0x0 rect\n      restricted.top    = Math.min(current.top, start.bottom);\n      restricted.bottom = Math.max(current.bottom, start.top);\n      restricted.left   = Math.min(current.left, start.right);\n      restricted.right  = Math.max(current.right, start.left);\n    }\n\n    restricted.width  = restricted.right  - restricted.left;\n    restricted.height = restricted.bottom - restricted.top ;\n\n    for (const edge in restricted) {\n      delta[edge] = restricted[edge] - previous[edge];\n    }\n\n    resizeEvent.edges = interaction.prepared.edges;\n    resizeEvent.rect = restricted;\n    resizeEvent.deltaRect = delta;\n  }\n\n  interaction.target.fire(resizeEvent);\n\n  interaction.prevEvent = resizeEvent;\n\n  // if the action was ended in a resizemove listener\n  if (!interaction.interacting()) { return false; }\n});\n\nInteraction.signals.on('action-end', function ({ interaction, event }) {\n  if (interaction.prepared.name !== 'resize') { return; }\n\n  const resizeEvent = new InteractEvent(interaction, event, 'resize', 'end', interaction.element);\n\n  interaction.target.fire(resizeEvent);\n  interaction.prevEvent = resizeEvent;\n});\n\n/*\\\n * Interactable.resizable\n [ method ]\n *\n * Gets or sets whether resize actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of resize elements\n   | var isResizeable = interact('input[type=text]').resizable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n = (object) This Interactable\n   | interact(element).resizable({\n   |   onstart: function (event) {},\n   |   onmove : function (event) {},\n   |   onend  : function (event) {},\n   |\n   |   edges: {\n   |     top   : true,       // Use pointer coords to check for resize.\n   |     left  : false,      // Disable resizing from left edge.\n   |     bottom: '.resize-s',// Resize if pointer target matches selector\n   |     right : handleEl    // Resize if pointer target is the given Element\n   |   },\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height are adjusted at a 1:1 ratio.\n   |     square: false,\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height maintain the aspect ratio they had when resizing started.\n   |     preserveAspectRatio: false,\n   |\n   |   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   |   // 'negate' will allow the rect to have negative width/height\n   |   // 'reposition' will keep the width/height positive by swapping\n   |   // the top and bottom edges and/or swapping the left and right edges\n   |   invert: 'none' || 'negate' || 'reposition'\n   |\n   |   // limit multiple resizes.\n   |   // See the explanation in the @Interactable.draggable example\n   |   max: Infinity,\n   |   maxPerElement: 1,\n   | });\n  \\*/\nInteractable.prototype.resizable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.resize.enabled = options.enabled === false? false: true;\n    this.setPerAction('resize', options);\n    this.setOnEvents('resize', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.resize.axis = options.axis;\n    }\n    else if (options.axis === null) {\n      this.options.resize.axis = scope.defaultOptions.resize.axis;\n    }\n\n    if (utils.isBool(options.preserveAspectRatio)) {\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n    }\n    else if (utils.isBool(options.square)) {\n      this.options.resize.square = options.square;\n    }\n\n    return this;\n  }\n  if (utils.isBool(options)) {\n    this.options.resize.enabled = options;\n\n    return this;\n  }\n  return this.options.resize;\n};\n\nfunction checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n  // false, '', undefined, null\n  if (!value) { return false; }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width  = utils.isNumber(rect.width )? rect.width  : rect.right  - rect.left;\n    const height = utils.isNumber(rect.height)? rect.height : rect.bottom - rect.top ;\n\n    if (width < 0) {\n      if      (name === 'left' ) { name = 'right'; }\n      else if (name === 'right') { name = 'left' ; }\n    }\n    if (height < 0) {\n      if      (name === 'top'   ) { name = 'bottom'; }\n      else if (name === 'bottom') { name = 'top'   ; }\n    }\n\n    if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n    if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n    if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n    if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n  }\n\n  // the remaining checks require an element\n  if (!utils.isElement(element)) { return false; }\n\n  return utils.isElement(value)\n  // the value is an element to use as a resize handle\n    ? value === element\n    // otherwise check if element matches value as selector\n    : utils.matchesUpTo(element, value, interactableElement);\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.resizeAxes = 'xy';\n});\n\nInteractEvent.signals.on('resize', function ({ interaction, iEvent }) {\n  if (!interaction.resizeAxes) { return; }\n\n  const options = interaction.target.options;\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      iEvent.dx = iEvent.dy;\n    }\n    else {\n      iEvent.dy = iEvent.dx;\n    }\n    iEvent.axes = 'xy';\n  }\n  else {\n    iEvent.axes = interaction.resizeAxes;\n\n    if (interaction.resizeAxes === 'x') {\n      iEvent.dy = 0;\n    }\n    else if (interaction.resizeAxes === 'y') {\n      iEvent.dx = 0;\n    }\n  }\n});\n\nactions.resize = resize;\nactions.names.push('resize');\nutils.merge(scope.eventTypes, [\n  'resizestart',\n  'resizemove',\n  'resizeinertiastart',\n  'resizeend',\n]);\nactions.methodDict.resize = 'resizable';\n\ndefaultOptions.resize = resize.defaults;\n\nmodule.exports = resize;\n","const raf            = require('./utils/raf');\nconst getWindow      = require('./utils/window').getWindow;\nconst isWindow       = require('./utils/isType').isWindow;\nconst domUtils       = require('./utils/domUtils');\nconst Interaction    = require('./Interaction');\nconst defaultOptions = require('./defaultOptions');\n\nconst autoScroll = {\n  defaults: {\n    enabled  : false,\n    container: null,     // the item that is scrolled (Window or HTMLElement)\n    margin   : 60,\n    speed    : 300,      // the scroll speed in pixels per second\n  },\n\n  interaction: null,\n  i: null,    // the handle returned by window.setInterval\n  x: 0, y: 0, // Direction each pulse is to scroll in\n\n  isScrolling: false,\n  prevTime: 0,\n\n  start: function (interaction) {\n    autoScroll.isScrolling = true;\n    raf.cancel(autoScroll.i);\n\n    autoScroll.interaction = interaction;\n    autoScroll.prevTime = new Date().getTime();\n    autoScroll.i = raf.request(autoScroll.scroll);\n  },\n\n  stop: function () {\n    autoScroll.isScrolling = false;\n    raf.cancel(autoScroll.i);\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll: function () {\n    const options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n    const container = options.container || getWindow(autoScroll.interaction.element);\n    const now = new Date().getTime();\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000;\n    // displacement\n    const s = options.speed * dt;\n\n    if (s >= 1) {\n      if (isWindow(container)) {\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n      }\n      else if (container) {\n        container.scrollLeft += autoScroll.x * s;\n        container.scrollTop  += autoScroll.y * s;\n      }\n\n      autoScroll.prevTime = now;\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i);\n      autoScroll.i = raf.request(autoScroll.scroll);\n    }\n  },\n  check: function (interactable, actionName) {\n    const options = interactable.options;\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n  },\n  onInteractionMove: function ({ interaction, pointer }) {\n    if (!(interaction.interacting()\n          && autoScroll.check(interaction.target, interaction.prepared.name))) {\n      return;\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0;\n      return;\n    }\n\n    let top;\n    let right;\n    let bottom;\n    let left;\n\n    const options = interaction.target.options[interaction.prepared.name].autoScroll;\n    const container = options.container || getWindow(interaction.element);\n\n    if (isWindow(container)) {\n      left   = pointer.clientX < autoScroll.margin;\n      top    = pointer.clientY < autoScroll.margin;\n      right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n    }\n    else {\n      const rect = domUtils.getElementClientRect(container);\n\n      left   = pointer.clientX < rect.left   + autoScroll.margin;\n      top    = pointer.clientY < rect.top    + autoScroll.margin;\n      right  = pointer.clientX > rect.right  - autoScroll.margin;\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n    }\n\n    autoScroll.x = (right ? 1: left? -1: 0);\n    autoScroll.y = (bottom? 1:  top? -1: 0);\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin;\n      autoScroll.speed  = options.speed;\n\n      autoScroll.start(interaction);\n    }\n  },\n};\n\nInteraction.signals.on('stop-active', function () {\n  autoScroll.stop();\n});\n\nInteraction.signals.on('move-done', autoScroll.onInteractionMove);\n\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\n\nmodule.exports = autoScroll;\n","const autoStart   = require('./index');\nconst Interaction = require('../Interaction');\nconst actions     = require('../actions');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.delayTimer = null;\n});\n\nautoStart.signals.on('prepared', function ({ interaction }) {\n  const actionName = interaction.prepared.name;\n\n  if (!actionName) { return; }\n\n  const delay = interaction.target.options[actionName].delay;\n\n  if (delay > 0) {\n    interaction.delayTimer = setTimeout(() => {\n      interaction.start(interaction.prepared, interaction.target, interaction.element);\n    }, delay);\n  }\n});\n\nfor (const action of actions.names) {\n  autoStart.signals.on('before-start-' + action, preventImmediateMove);\n}\n\nInteraction.signals.on('move-done', function ({ interaction }) {\n  if (interaction.pointerWasMoved) {\n    clearTimeout(interaction.delayTimer);\n  }\n});\n\nfunction preventImmediateMove ({ interaction }) {\n  const actionName = interaction.prepared.name;\n\n  if (!actionName) { return; }\n\n  const delay = interaction.target.options[actionName].delay;\n\n  if (delay > 0) {\n    interaction.prepared.name = null;\n  }\n}\n","const autoStart = require('./index');\nconst scope     = require('../scope');\nconst browser   = require('../utils/browser');\n\nconst { isElement } = require('../utils/isType');\nconst { matchesSelector, parentElement } = require('../utils/domUtils');\n\nautoStart.signals.on('before-start-drag',  function ({ interaction, eventTarget, dx, dy }) {\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx);\n  const absY = Math.abs(dy);\n  const dragOptions = interaction.target.options.drag;\n  const startAxis = dragOptions.startAxis;\n  const currentAxis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n  interaction.prepared.axis = dragOptions.lockAxis === 'start'\n    ? currentAxis\n    : dragOptions.lockAxis;\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    interaction.prepared.name = null;\n\n    // then try to get a drag from another ineractable\n\n    if (!interaction.prepared.name) {\n\n      let element = eventTarget;\n\n      const getDraggable = function (interactable, selector, context) {\n        const elements = browser.useMatchesSelectorPolyfill\n            ? context.querySelectorAll(selector)\n            : undefined;\n\n        if (interactable === interaction.target) { return; }\n\n        let action = null;\n\n        if (scope.inContext(interactable, eventTarget)\n            && !interactable.options.drag.manualStart\n            && !scope.testIgnore(interactable, element, eventTarget)\n            && scope.testAllow(interactable, element, eventTarget)\n            && matchesSelector(element, selector, elements)) {\n\n          action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n        }\n        if (action\n            && action.name === 'drag'\n            && checkStartAxis(currentAxis, interactable)\n            && scope.withinInteractionLimit(interactable, element, { name: 'drag' })) {\n\n          return interactable;\n        }\n      };\n\n      let action = null;\n\n      // check all interactables\n      while (isElement(element)) {\n        const elementInteractable = scope.interactables.get(element);\n\n        if (elementInteractable\n            && elementInteractable !== interaction.target\n            && !elementInteractable.options.drag.manualStart) {\n\n          action = elementInteractable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n        }\n        if (action\n            && action.name === 'drag'\n            && checkStartAxis(currentAxis, elementInteractable)) {\n\n          interaction.prepared.name = 'drag';\n          interaction.target = elementInteractable;\n          interaction.element = element;\n          break;\n        }\n\n        const selectorInteractable = scope.interactables.forEachSelector(getDraggable);\n\n        if (selectorInteractable) {\n          interaction.prepared.name = 'drag';\n          interaction.target = selectorInteractable;\n          interaction.element = element;\n          break;\n        }\n\n        element = parentElement(element);\n      }\n    }\n  }\n});\n\nfunction checkStartAxis (startAxis, interactable) {\n  if (!interactable) { return false; }\n\n  const thisAxis = interactable.options.drag.startAxis;\n\n  return (startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis);\n}\n\n","const Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst actions        = require('../actions');\nconst defaultOptions = require('../defaultOptions');\nconst browser        = require('../utils/browser');\nconst scope          = require('../scope');\nconst utils          = require('../utils');\nconst signals        = require('../utils/Signals').new();\n\n// mouse move cursor style\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget }) {\n  if (!interaction.mouse || interaction.pointerIsDown) { return; }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget }) {\n  if (interaction.interacting()) { return; }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\nInteraction.signals.on('move', function (arg) {\n  const { interaction, event } = arg;\n\n  if (!(interaction.pointerIsDown && interaction.pointerWasMoved && interaction.prepared.name)) {\n    return;\n  }\n\n  // ignore movement while simulation is active\n  if (!interaction.simulation) {\n\n    // if just starting an action, calculate the pointer speed now\n    if (!interaction.interacting()) {\n      utils.setEventDeltas(interaction.pointerDelta, interaction.prevCoords, interaction.curCoords);\n\n      signals.fire('before-start-' + interaction.prepared.name, arg);\n    }\n\n    const starting = !!interaction.prepared.name && !interaction.interacting();\n\n    if (starting\n        && (interaction.target.options[interaction.prepared.name].manualStart\n        || !scope.withinInteractionLimit(interaction.target, interaction.element, interaction.prepared))) {\n      interaction.stop(event);\n      return;\n    }\n\n    if (interaction.prepared.name && interaction.target) {\n      if (starting) {\n        interaction.start(interaction.prepared, interaction.target, interaction.element);\n      }\n    }\n  }\n});\n\nfunction validateSelector (interaction, pointer, event, matches, matchElements) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i];\n    const matchElement = matchElements[i];\n    const action = Interaction.validateAction(match.getAction(pointer, event, interaction, matchElement), match);\n\n    if (action && scope.withinInteractionLimit(match, matchElement, action)) {\n      return {\n        action,\n        target: match,\n        element: matchElement,\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getActionInfo (interaction, pointer, event, eventTarget) {\n  let matches = [];\n  let matchElements = [];\n\n  let element = eventTarget;\n  let action = null;\n\n  function pushMatches (interactable, selector, context) {\n    const elements = (browser.useMatchesSelectorPolyfill\n      ? context.querySelectorAll(selector)\n      : undefined);\n\n    if (scope.inContext(interactable, element)\n        && !scope.testIgnore(interactable, element, eventTarget)\n      && scope.testAllow(interactable, element, eventTarget)\n      && utils.matchesSelector(element, selector, elements)) {\n\n      matches.push(interactable);\n      matchElements.push(element);\n    }\n  }\n\n  while (utils.isElement(element)) {\n    matches = [];\n    matchElements = [];\n\n    const elementInteractable = scope.interactables.get(element);\n\n    if (elementInteractable\n        && (action = Interaction.validateAction(elementInteractable.getAction(pointer, event, interaction, element), elementInteractable))) {\n      return {\n        element,\n        action,\n        target: elementInteractable,\n      };\n    }\n    else {\n      scope.interactables.forEachSelector(pushMatches);\n\n      const actionInfo = validateSelector(interaction, pointer, event, matches, matchElements);\n\n      if (actionInfo.action) {\n        return actionInfo;\n      }\n    }\n\n    element = utils.parentElement(element);\n  }\n\n  return {};\n}\n\nfunction prepare (interaction, { action, target, element }) {\n  action = action || {};\n\n  if (interaction.target && interaction.target.options.styleCursor) {\n    interaction.target._doc.documentElement.style.cursor = '';\n  }\n\n  interaction.target = target;\n  interaction.element = element;\n  utils.copyAction(interaction.prepared, action);\n\n  if (target && target.options.styleCursor) {\n    const cursor = action? actions[action.name].getCursor(action) : '';\n    interaction.target._doc.documentElement.style.cursor = cursor;\n  }\n\n  interaction.setEventXY(interaction.startCoords, interaction.pointers);\n\n  signals.fire('prepared', { interaction: interaction });\n}\n\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\n  const action = this.defaultActionChecker(pointer, event, interaction, element);\n\n  if (this.options.actionChecker) {\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\n  }\n\n  return action;\n};\n\n/*\\\n * Interactable.actionChecker\n [ method ]\n *\n * Gets or sets the function used to check action to be performed on\n * pointerDown\n *\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n = (Function | Interactable) The checker function or this Interactable\n *\n | interact('.resize-drag')\n |   .resizable(true)\n |   .draggable(true)\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n |\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\n |     // force drag with handle target\n |     action.name = drag;\n |   }\n |   else {\n |     // resize from the top and right edges\n |     action.name  = 'resize';\n |     action.edges = { top: true, right: true };\n |   }\n |\n |   return action;\n | });\n\\*/\nInteractable.prototype.actionChecker = function (checker) {\n  if (utils.isFunction(checker)) {\n    this.options.actionChecker = checker;\n\n    return this;\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker;\n\n    return this;\n  }\n\n  return this.options.actionChecker;\n};\n\n/*\\\n * Interactable.styleCursor\n [ method ]\n *\n * Returns or sets whether the the cursor should be changed depending on the\n * action that would be performed if the mouse were pressed and dragged.\n *\n - newValue (boolean) #optional\n = (boolean | Interactable) The current setting or this Interactable\n\\*/\nInteractable.prototype.styleCursor = function (newValue) {\n  if (utils.isBool(newValue)) {\n    this.options.styleCursor = newValue;\n\n    return this;\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor;\n\n    return this;\n  }\n\n  return this.options.styleCursor;\n};\n\n/*\\\n * Interactable.ignoreFrom\n [ method ]\n *\n * If the target of the `mousedown`, `pointerdown` or `touchstart`\n * event or any of it's parents match the given CSS selector or\n * Element, no drag/resize/gesture is started.\n *\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n = (string | Element | object) The current ignoreFrom value or this Interactable\n **\n | interact(element, { ignoreFrom: document.getElementById('no-action') });\n | // or\n | interact(element).ignoreFrom('input, textarea, a');\n\\*/\nInteractable.prototype.ignoreFrom = function (newValue) {\n  if (utils.trySelector(newValue)) {            // CSS selector to match event.target\n    this.options.ignoreFrom = newValue;\n    return this;\n  }\n\n  if (utils.isElement(newValue)) {              // specific element\n    this.options.ignoreFrom = newValue;\n    return this;\n  }\n\n  return this.options.ignoreFrom;\n};\n\n/*\\\n * Interactable.allowFrom\n [ method ]\n *\n * A drag/resize/gesture is started only If the target of the\n * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n * parents match the given CSS selector or Element.\n *\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n = (string | Element | object) The current allowFrom value or this Interactable\n **\n | interact(element, { allowFrom: document.getElementById('drag-handle') });\n | // or\n | interact(element).allowFrom('.handle');\n\\*/\nInteractable.prototype.allowFrom = function (newValue) {\n  if (utils.trySelector(newValue)) {            // CSS selector to match event.target\n    this.options.allowFrom = newValue;\n    return this;\n  }\n\n  if (utils.isElement(newValue)) {              // specific element\n    this.options.allowFrom = newValue;\n    return this;\n  }\n\n  return this.options.allowFrom;\n};\n\nInteraction.signals.on('stop-active', function ({ interaction }) {\n  const target = interaction.target;\n\n  if (target.options.styleCursor) {\n    target._doc.documentElement.style.cursor = '';\n  }\n});\n\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n  const rect = this.getRect(element);\n  let action = null;\n\n  for (const actionName of actions.names) {\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n    if (action) {\n      return action;\n    }\n  }\n};\n\nInteractable.settingsMethods.push('styleCursor');\nInteractable.settingsMethods.push('actionChecker');\nInteractable.settingsMethods.push('ignoreFrom');\nInteractable.settingsMethods.push('allowFrom');\n\ndefaultOptions.base.actionChecker = null;\ndefaultOptions.base.ignoreFrom = null;\ndefaultOptions.base.allowFrom = null;\ndefaultOptions.base.styleCursor = true;\ndefaultOptions.perAction.manualStart = false;\n\nmodule.exports = { signals };\n","module.exports = {\n  base: {\n    accept        : null,\n    preventDefault: 'auto',\n    origin        : { x: 0, y: 0 },\n    deltaSource   : 'page',\n    allowFrom     : null,\n  },\n\n  perAction: {\n    max: Infinity,\n    maxPerElement: 1,\n\n    inertia: {\n      enabled          : false,\n      resistance       : 10,    // the lambda in exponential decay\n      minSpeed         : 100,   // target speed must be above this for inertia to start\n      endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n      allowResume      : true,  // allow resuming an action in inertia phase\n      zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n      smoothEndDuration: 300,   // animate to snap/restrict endOnly if there's no inertia\n    },\n  },\n\n  _holdDuration: 600,\n};\n","/* browser entry point */\n\n// Interaction\nrequire('./Interaction');\n\n// Legacy browser support\nrequire('./legacyBrowsers');\n\n// pointerEvents\nrequire('./pointerEvents');\n\n// inertia\nrequire('./inertia');\n\n// modifiers\nrequire('./modifiers/snap');\nrequire('./modifiers/restrict');\n\n// actions\nrequire('./actions/gesture');\nrequire('./actions/resize');\nrequire('./actions/drag');\nrequire('./actions/drop');\n\n// autoScroll\nrequire('./autoScroll');\n\n// autoStart\nrequire('./autoStart');\nrequire('./autoStart/drag');\nrequire('./autoStart/delay');\n\n// export interact\nmodule.exports = require('./interact');\n","const InteractEvent  = require('./InteractEvent');\nconst Interaction    = require('./Interaction');\nconst modifiers      = require('./modifiers');\nconst utils          = require('./utils');\nconst animationFrame = utils.raf;\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.inertiaStatus = {\n    active     : false,\n    smoothEnd  : false,\n    allowResume: false,\n    resumed    : false,\n    ending     : false,\n\n    startEvent: null,\n    upCoords  : {},\n\n    xe: 0, ye: 0,\n    sx: 0, sy: 0,\n\n    t0: 0,\n    vx0: 0, vys: 0,\n    duration: 0,\n\n    resumeDx: 0,\n    resumeDy: 0,\n\n    lambda_v0: 0,\n    one_ve_v0: 0,\n    i  : null,\n  };\n\n  interaction.boundInertiaFrame   = () => inertiaFrame  .apply(interaction);\n  interaction.boundSmoothEndFrame = () => smoothEndFrame.apply(interaction);\n});\n\nInteraction.signals.on('down', function ({ interaction, eventTarget }) {\n  const status = interaction.inertiaStatus;\n\n  // Check if the down event hits the current inertia target\n  if (status.active) {\n    let element = eventTarget;\n\n    // climb up the DOM tree from the event target\n    while (utils.isElement(element)) {\n\n      // if interaction element is the current inertia target element\n      if (element === interaction.element) {\n\n        // stop inertia so that the next move will be a normal one\n        animationFrame.cancel(status.i);\n        status.active = false;\n        status.resumed = true;\n        interaction.simulation = null;\n\n        break;\n      }\n      element = utils.parentElement(element);\n    }\n  }\n});\n\nInteraction.signals.on('up', function ({ interaction, event }) {\n  const status = interaction.inertiaStatus;\n\n  if (!interaction.interacting() || status.active) { return; }\n\n  const target = interaction.target;\n  const options = target && target.options;\n  const inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\n\n  const now = new Date().getTime();\n  const statuses = {};\n  const page = utils.extend({}, interaction.curCoords.page);\n  const pointerSpeed = interaction.pointerDelta.client.speed;\n  let inertiaPossible = false;\n  let inertia = false;\n  let smoothEnd = false;\n  let modifierResult;\n\n  // check if inertia should be started\n  inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n                     && interaction.prepared.name !== 'gesture'\n                     && event !== status.startEvent);\n\n  inertia = (inertiaPossible\n            && (now - interaction.curCoords.timeStamp) < 50\n            && pointerSpeed > inertiaOptions.minSpeed\n            && pointerSpeed > inertiaOptions.endSpeed);\n\n  // smoothEnd\n  if (inertiaPossible && !inertia) {\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(interaction, page, statuses, true);\n\n    if (modifierResult.shouldMove && modifierResult.locked) {\n      smoothEnd = true;\n    }\n  }\n\n  if (!(inertia || smoothEnd)) { return; }\n\n  utils.copyCoords(status.upCoords, interaction.curCoords);\n\n  interaction.pointers[0] = status.startEvent =\n    new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\n\n  status.t0 = now;\n\n  status.active = true;\n  status.allowResume = inertiaOptions.allowResume;\n  interaction.simulation = status;\n\n  target.fire(status.startEvent);\n\n  if (inertia) {\n    status.vx0 = interaction.pointerDelta.client.vx;\n    status.vy0 = interaction.pointerDelta.client.vy;\n    status.v0 = pointerSpeed;\n\n    calcInertia(interaction, status);\n\n    utils.extend(page, interaction.curCoords.page);\n\n    page.x += status.xe;\n    page.y += status.ye;\n\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(interaction, page, statuses, true, true);\n\n    status.modifiedXe += modifierResult.dx;\n    status.modifiedYe += modifierResult.dy;\n\n    status.i = animationFrame.request(interaction.boundInertiaFrame);\n  }\n  else {\n    status.smoothEnd = true;\n    status.xe = modifierResult.dx;\n    status.ye = modifierResult.dy;\n\n    status.sx = status.sy = 0;\n\n    status.i = animationFrame.request(interaction.boundSmoothEndFrame);\n  }\n});\n\nInteraction.signals.on('stop-active', function ({ interaction }) {\n  const status = interaction.inertiaStatus;\n\n  if (status.active) {\n    status.resumeDx = status.resumeDy = 0;\n    animationFrame.cancel(status.i);\n    status.active = status.ending = false;\n    interaction.simulation = null;\n  }\n});\n\nInteractEvent.signals.on('set-delta', function ({ iEvent, phase, interaction, action: actionName }) {\n  const status = interaction.inertiaStatus;\n\n  if (!status.active) { return; }\n\n  // copy properties from previousmove if starting inertia\n  if (phase === 'inertiastart') {\n    iEvent.dx = interaction.prevEvent.dx;\n    iEvent.dy = interaction.prevEvent.dy;\n  }\n\n  iEvent.detail = 'inertia';\n\n  if (status.resumed) {\n    const inertiaOptions = interaction.target.options[actionName].inertia;\n\n    if (inertiaOptions.zeroResumeDelta) {\n      status.resumeDx += iEvent.dx;\n      status.resumeDy += iEvent.dy;\n\n      iEvent.dx = iEvent.dy = 0;\n    }\n  }\n});\n\nfunction calcInertia (interaction, status) {\n  const inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\n  const lambda = inertiaOptions.resistance;\n  const inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n  status.x0 = interaction.prevEvent.pageX;\n  status.y0 = interaction.prevEvent.pageY;\n  status.t0 = status.startEvent.timeStamp / 1000;\n  status.sx = status.sy = 0;\n\n  status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n  status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n  status.te = inertiaDur;\n\n  status.lambda_v0 = lambda / status.v0;\n  status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n}\n\nfunction inertiaFrame () {\n  updateInertiaCoords(this);\n  utils.setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n  const status = this.inertiaStatus;\n  const options = this.target.options[this.prepared.name].inertia;\n  const lambda = options.resistance;\n  const t = new Date().getTime() / 1000 - status.t0;\n\n  if (t < status.te) {\n\n    const progress =  1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\n\n    if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\n      status.sx = status.xe * progress;\n      status.sy = status.ye * progress;\n    }\n    else {\n      const quadPoint = utils.getQuadraticCurvePoint(0, 0,\n                                                     status.xe,\n                                                     status.ye,\n                                                     status.modifiedXe,\n                                                     status.modifiedYe,\n                                                     progress);\n\n      status.sx = quadPoint.x;\n      status.sy = quadPoint.y;\n    }\n\n    this.doMove();\n\n    status.i = animationFrame.request(this.boundInertiaFrame);\n  }\n  else {\n    status.ending = true;\n\n    status.sx = status.modifiedXe;\n    status.sy = status.modifiedYe;\n\n    this.doMove();\n    this.end(status.startEvent);\n    status.active = status.ending = false;\n    this.simulation = null;\n  }\n\n  utils.copyCoords(this.prevCoords, this.curCoords);\n}\n\nfunction smoothEndFrame () {\n  updateInertiaCoords(this);\n\n  const status = this.inertiaStatus;\n  const t = new Date().getTime() - status.t0;\n  const duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n  if (t < duration) {\n    status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\n    status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\n\n    this.pointerMove(status.startEvent, status.startEvent);\n\n    status.i = animationFrame.request(this.boundSmoothEndFrame);\n  }\n  else {\n    status.ending = true;\n\n    status.sx = status.xe;\n    status.sy = status.ye;\n\n    this.pointerMove(status.startEvent, status.startEvent);\n    this.end(status.startEvent);\n\n    status.smoothEnd =\n      status.active = status.ending = false;\n    this.simulation = null;\n  }\n}\n\nfunction updateInertiaCoords (interaction) {\n  const status = interaction.inertiaStatus;\n\n  // return if inertia isn't running\n  if (!status.active) { return; }\n\n  const pageUp   = status.upCoords.page;\n  const clientUp = status.upCoords.client;\n\n  interaction.setEventXY(interaction.curCoords, [ {\n    pageX  : pageUp.x   + status.sx,\n    pageY  : pageUp.y   + status.sy,\n    clientX: clientUp.x + status.sx,\n    clientY: clientUp.y + status.sy,\n  } ]);\n}\n","/**\n * interact.js v1.2.5\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n\nconst browser      = require('./utils/browser');\nconst events       = require('./utils/events');\nconst utils        = require('./utils');\nconst scope        = require('./scope');\nconst Interactable = require('./Interactable');\n\nscope.dynamicDrop = false;\n\n// Less Precision with touch input\nscope.margin = browser.supportsTouch || browser.supportsPointerEvent? 20: 10;\n\nscope.pointerMoveTolerance = 1;\n\n// Allow this many interactions to happen simultaneously\nscope.maxInteractions = Infinity;\n\n// because Webkit and Opera still use 'mousewheel' event type\nscope.wheelEvent = 'onmousewheel' in scope.document? 'mousewheel': 'wheel';\n\nscope.globalEvents = {};\n\nscope.inContext = function (interactable, element) {\n  return (interactable._context === element.ownerDocument\n          || utils.nodeContains(interactable._context, element));\n};\n\nscope.testIgnore = function (interactable, interactableElement, element) {\n  const ignoreFrom = interactable.options.ignoreFrom;\n\n  if (!ignoreFrom || !utils.isElement(element)) { return false; }\n\n  if (utils.isString(ignoreFrom)) {\n    return utils.matchesUpTo(element, ignoreFrom, interactableElement);\n  }\n  else if (utils.isElement(ignoreFrom)) {\n    return utils.nodeContains(ignoreFrom, element);\n  }\n\n  return false;\n};\n\nscope.testAllow = function (interactable, interactableElement, element) {\n  const allowFrom = interactable.options.allowFrom;\n\n  if (!allowFrom) { return true; }\n\n  if (!utils.isElement(element)) { return false; }\n\n  if (utils.isString(allowFrom)) {\n    return utils.matchesUpTo(element, allowFrom, interactableElement);\n  }\n  else if (utils.isElement(allowFrom)) {\n    return utils.nodeContains(allowFrom, element);\n  }\n\n  return false;\n};\n\nscope.interactables.indexOfElement = function indexOfElement (target, context) {\n  context = context || scope.document;\n\n  for (let i = 0; i < this.length; i++) {\n    const interactable = this[i];\n\n    if (interactable.target === target\n        && (!utils.isString(target) || (interactable._context === context))) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nscope.interactables.get = function interactableGet (element, options) {\n  return this[this.indexOfElement(element, options && options.context)];\n};\n\nscope.interactables.forEachSelector = function (callback) {\n  for (let i = 0; i < this.length; i++) {\n    const interactable = this[i];\n\n    // skip non CSS selector targets\n    if (!utils.isString(interactable.target)) {\n      continue;\n    }\n\n    const ret = callback(interactable, interactable.target, interactable._context, i, this);\n\n    if (ret !== undefined) {\n      return ret;\n    }\n  }\n};\n\n/*\\\n * interact\n [ method ]\n *\n * The methods of this variable can be used to set elements as\n * interactables and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to\n * configure it.\n *\n - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n = (object) An @Interactable\n *\n > Usage\n | interact(document.getElementById('draggable')).draggable(true);\n |\n | var rectables = interact('rect');\n | rectables\n |     .gesturable(true)\n |     .on('gesturemove', function (event) {\n |         // something cool...\n |     })\n |     .autoScroll(true);\n\\*/\nfunction interact (element, options) {\n  return scope.interactables.get(element, options) || new Interactable(element, options);\n}\n\n/*\\\n * interact.isSet\n [ method ]\n *\n * Check if an element has been set\n - element (Element) The Element being searched for\n = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\\*/\ninteract.isSet = function (element, options) {\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n};\n\n/*\\\n * interact.on\n [ method ]\n *\n * Adds a global listener for an InteractEvent or adds a DOM event to\n * `document`\n *\n - type       (string | array | object) The types of events to listen for\n - listener   (function) The function event (s)\n - useCapture (boolean) #optional useCapture flag for addEventListener\n = (object) interact\n\\*/\ninteract.on = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (const eventType of type) {\n      interact.on(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (const prop in type) {\n      interact.on(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.contains(scope.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!scope.globalEvents[type]) {\n      scope.globalEvents[type] = [listener];\n    }\n    else {\n      scope.globalEvents[type].push(listener);\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n    events.add(scope.document, type, listener, useCapture);\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.off\n [ method ]\n *\n * Removes a global InteractEvent listener or DOM event from `document`\n *\n - type       (string | array | object) The types of events that were listened for\n - listener   (function) The listener function to be removed\n - useCapture (boolean) #optional useCapture flag for removeEventListener\n = (object) interact\n \\*/\ninteract.off = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (const eventType of type) {\n      interact.off(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (const prop in type) {\n      interact.off(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  if (!utils.contains(scope.eventTypes, type)) {\n    events.remove(scope.document, type, listener, useCapture);\n  }\n  else {\n    let index;\n\n    if (type in scope.globalEvents\n        && (index = utils.indexOf(scope.globalEvents[type], listener)) !== -1) {\n      scope.globalEvents[type].splice(index, 1);\n    }\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.debug\n [ method ]\n *\n * Returns an object which exposes internal data\n = (object) An object with properties that outline the current state and expose internal functions and variables\n\\*/\ninteract.debug = function () {\n  return scope;\n};\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage  = utils.pointerAverage;\ninteract.getTouchBBox       = utils.touchBBox;\ninteract.getTouchDistance   = utils.touchDistance;\ninteract.getTouchAngle      = utils.touchAngle;\n\ninteract.getElementRect       = utils.getElementRect;\ninteract.getElementClientRect = utils.getElementClientRect;\ninteract.matchesSelector      = utils.matchesSelector;\ninteract.closest              = utils.closest;\n\n/*\\\n * interact.supportsTouch\n [ method ]\n *\n = (boolean) Whether or not the browser supports touch input\n\\*/\ninteract.supportsTouch = function () {\n  return browser.supportsTouch;\n};\n\n/*\\\n * interact.supportsPointerEvent\n [ method ]\n *\n = (boolean) Whether or not the browser supports PointerEvents\n\\*/\ninteract.supportsPointerEvent = function () {\n  return browser.supportsPointerEvent;\n};\n\n/*\\\n * interact.stop\n [ method ]\n *\n * Cancels all interactions (end events are not fired)\n *\n - event (Event) An event on which to call preventDefault()\n = (object) interact\n\\*/\ninteract.stop = function (event) {\n  for (let i = scope.interactions.length - 1; i >= 0; i--) {\n    scope.interactions[i].stop(event);\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.dynamicDrop\n [ method ]\n *\n * Returns or sets whether the dimensions of dropzone elements are\n * calculated on every dragmove or only on dragstart for the default\n * dropChecker\n *\n - newValue (boolean) #optional True to check on each move. False to check only before start\n = (boolean | interact) The current setting or interact\n\\*/\ninteract.dynamicDrop = function (newValue) {\n  if (utils.isBool(newValue)) {\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\n      //calcRects(dropzones);\n    //}\n\n    scope.dynamicDrop = newValue;\n\n    return interact;\n  }\n  return scope.dynamicDrop;\n};\n\n/*\\\n * interact.pointerMoveTolerance\n [ method ]\n * Returns or sets the distance the pointer must be moved before an action\n * sequence occurs. This also affects tolerance for tap events.\n *\n - newValue (number) #optional The movement from the start position must be greater than this value\n = (number | Interactable) The current setting or interact\n\\*/\ninteract.pointerMoveTolerance = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    scope.pointerMoveTolerance = newValue;\n\n    return this;\n  }\n\n  return scope.pointerMoveTolerance;\n};\n\n/*\\\n * interact.maxInteractions\n [ method ]\n **\n * Returns or sets the maximum number of concurrent interactions allowed.\n * By default only 1 interaction is allowed at a time (for backwards\n * compatibility). To allow multiple interactions on the same Interactables\n * and elements, you need to enable it in the draggable, resizable and\n * gesturable `'max'` and `'maxPerElement'` options.\n **\n - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\\*/\ninteract.maxInteractions = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    scope.maxInteractions = newValue;\n\n    return this;\n  }\n\n  return scope.maxInteractions;\n};\n\nscope.interact = interact;\n\nmodule.exports = interact;\n","const scope   = require('./scope');\nconst events  = require('./utils/events');\nconst browser = require('./utils/browser');\nconst iFinder = require('./utils/interactionFinder');\n\nconst toString = Object.prototype.toString;\n\nif (!window.Array.isArray) {\n  window.Array.isArray = function (obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n\n// http://www.quirksmode.org/dom/events/click.html\n// >Events leading to dblclick\n//\n// IE8 doesn't fire down event before dblclick.\n// This workaround tries to fire a tap and doubletap after dblclick\nfunction onIE8Dblclick (event) {\n  const interaction = iFinder.search(event, event.type, event.target);\n\n  if (!interaction) { return; }\n\n  if (interaction.prevTap\n      && event.clientX === interaction.prevTap.clientX\n      && event.clientY === interaction.prevTap.clientY\n      && event.target  === interaction.prevTap.target) {\n\n    interaction.downTargets[0] = event.target;\n    interaction.downTimes  [0] = new Date().getTime();\n\n    scope.pointerEvents.collectEventTargets(interaction, event, event, event.target, 'tap');\n  }\n}\n\nif (browser.isIE8) {\n  scope.signals.on('listen-to-document', function ({ doc }) {\n    // For IE's lack of Event#preventDefault\n    events.add(doc, 'selectstart', function (event) {\n      for (const interaction of scope.interactions) {\n        if (interaction.interacting()) {\n          interaction.checkAndPreventDefault(event);\n        }\n      }\n    });\n\n    if (scope.pointerEvents) {\n      events.add(doc, 'dblclick', onIE8Dblclick);\n    }\n  });\n}\n\nmodule.exports = null;\n","const InteractEvent = require('../InteractEvent');\nconst Interaction   = require('../Interaction');\nconst extend        = require('../utils/extend');\n\nconst modifiers = {\n  names: [],\n\n  setStartOffsets: function (interaction) {\n    const { target, element } = interaction;\n    const rect = target.getRect(element);\n\n    if (rect) {\n      interaction.startOffset.left = interaction.startCoords.page.x - rect.left;\n      interaction.startOffset.top  = interaction.startCoords.page.y - rect.top;\n\n      interaction.startOffset.right  = rect.right  - interaction.startCoords.page.x;\n      interaction.startOffset.bottom = rect.bottom - interaction.startCoords.page.y;\n\n      if (!('width'  in rect)) { rect.width  = rect.right  - rect.left; }\n      if (!('height' in rect)) { rect.height = rect.bottom - rect.top ; }\n    }\n    else {\n      interaction.startOffset.left = interaction.startOffset.top = interaction.startOffset.right = interaction.startOffset.bottom = 0;\n    }\n\n    modifiers.setOffsets(interaction, target, element, rect, interaction.modifierOffsets);\n  },\n\n  setOffsets: function (interaction, interactable, element, rect, offsets) {\n    for (let i = 0; i < modifiers.names.length; i++) {\n      const modifierName = modifiers.names[i];\n\n      offsets[modifierName] =\n        modifiers[modifiers.names[i]].setOffset(interaction,\n                                                interactable, element, rect,\n                                                interaction.startOffset);\n    }\n  },\n\n  setAll: function (interaction, coordsArg, statuses, preEnd, requireEndOnly) {\n    const result = {\n      dx: 0,\n      dy: 0,\n      changed: false,\n      locked: false,\n      shouldMove: true,\n    };\n    const target = interaction.target;\n    const coords = extend({}, coordsArg);\n\n    let currentStatus;\n\n    for (const modifierName of modifiers.names) {\n      const modifier = modifiers[modifierName];\n\n      if (!modifier.shouldDo(target, interaction.prepared.name, preEnd, requireEndOnly)) { continue; }\n\n      currentStatus = modifier.set(coords, interaction, statuses[modifierName]);\n\n      if (currentStatus.locked) {\n        coords.x += currentStatus.dx;\n        coords.y += currentStatus.dy;\n\n        result.dx += currentStatus.dx;\n        result.dy += currentStatus.dy;\n\n        result.locked = true;\n      }\n    }\n\n    // a move should be fired if the modified coords of\n    // the last modifier status that was calculated changes\n    result.shouldMove = !currentStatus || currentStatus.changed;\n\n    return result;\n  },\n\n  resetStatuses: function (statuses) {\n    for (const modifierName of modifiers.names) {\n      statuses[modifierName] = modifiers[modifierName].reset(statuses[modifierName] || {});\n    }\n\n    return statuses;\n  },\n};\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.startOffset      = { left: 0, right: 0, top: 0, bottom: 0 };\n  interaction.modifierOffsets  = {};\n  interaction.modifierStatuses = modifiers.resetStatuses({});\n});\n\nInteraction.signals.on('start', function ({ interaction }) {\n  modifiers.setStartOffsets(interaction);\n\n  modifiers.resetStatuses(interaction.modifierStatuses);\n  modifiers.setAll(interaction, interaction.startCoords.page, interaction.modifierStatuses);\n});\n\nInteraction.signals.on('before-action-move', function ({ interaction, preEnd, interactingBeforeMove }) {\n  const modifierResult = modifiers.setAll(interaction, interaction.curCoords.page, interaction.modifierStatuses, preEnd);\n\n  // don't fire an action move if a modifier would keep the event in the same\n  // cordinates as before\n  if (!modifierResult.shouldMove && interactingBeforeMove) {\n    interaction._dontFireMove = true;\n  }\n});\n\nInteraction.signals.on('action-end', function ({ interaction }) {\n  for (let i = 0; i < modifiers.names.length; i++) {\n    // if the endOnly option is true for any modifier\n    if (modifiers[modifiers.names[i]].shouldDo(interaction.target, interaction.prepared.name, true, true)) {\n      // fire a move event at the modified coordinates\n      interaction.doMove({ preEnd: true });\n      break;\n    }\n  }\n});\n\nInteractEvent.signals.on('set-xy', function ({ iEvent, interaction, page, client, phase, action: actionName }) {\n  const target = interaction.target;\n\n  for (let i = 0; i < modifiers.names.length; i++) {\n    const modifierName = modifiers.names[i];\n    const modifier = modifiers[modifierName];\n\n    iEvent[modifierName] = modifier.modifyCoords(page, client, target, interaction.modifierStatuses[modifierName], actionName, phase);\n  }\n});\n\nmodule.exports = modifiers;\n","const modifiers = require('./index');\nconst utils = require('../utils');\nconst defaultOptions = require('../defaultOptions');\n\nconst restrict = {\n  defaults: {\n    enabled    : false,\n    endOnly    : false,\n    restriction: null,\n    elementRect: null,\n  },\n\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\n    const restrictOptions = interactable.options[actionName].restrict;\n\n    return (restrictOptions && restrictOptions.enabled\n            && (preEnd || !restrictOptions.endOnly)\n            && (!requireEndOnly || restrictOptions.endOnly));\n  },\n\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\n    const elementRect = interactable.options[interaction.prepared.name].restrict.elementRect;\n    const offset = {};\n\n    if (rect && elementRect) {\n      offset.left = startOffset.left - (rect.width  * elementRect.left);\n      offset.top  = startOffset.top  - (rect.height * elementRect.top);\n\n      offset.right  = startOffset.right  - (rect.width  * (1 - elementRect.right));\n      offset.bottom = startOffset.bottom - (rect.height * (1 - elementRect.bottom));\n    }\n    else {\n      offset.left = offset.top = offset.right = offset.bottom = 0;\n    }\n\n    return offset;\n  },\n\n  set: function (pageCoords, interaction, status) {\n    const target    = interaction.target;\n    const restrictOptions  = target && target.options[interaction.prepared.name].restrict;\n    let restriction = restrictOptions && restrictOptions.restriction;\n\n    if (!restriction) {\n      return status;\n    }\n\n    const page = status.useStatusXY\n      ? { x: status.x, y: status.y }\n      : utils.extend({}, pageCoords);\n\n    if (interaction.simulation) {\n      page.x -= interaction.simulation.resumeDx;\n      page.y -= interaction.simulation.resumeDy;\n    }\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    let rect;\n    let restrictedX;\n    let restrictedY;\n\n    if (utils.isString(restriction)) {\n      if (restriction === 'parent') {\n        restriction = utils.parentElement(interaction.element);\n      }\n      else if (restriction === 'self') {\n        restriction = target.getRect(interaction.element);\n      }\n      else {\n        restriction = utils.closest(interaction.element, restriction);\n      }\n\n      if (!restriction) { return status; }\n    }\n\n    if (utils.isFunction(restriction)) {\n      restriction = restriction(page.x, page.y, interaction.element);\n    }\n\n    if (utils.isElement(restriction)) {\n      restriction = utils.getElementRect(restriction);\n    }\n\n    rect = restriction;\n\n    const offset = interaction.modifierOffsets.restrict;\n\n    if (!restriction) {\n      restrictedX = page.x;\n      restrictedY = page.y;\n    }\n    // object is assumed to have\n    // x, y, width, height or\n    // left, top, right, bottom\n    else if ('x' in restriction && 'y' in restriction) {\n      restrictedX = Math.max(Math.min(rect.x + rect.width  - offset.right , page.x), rect.x + offset.left);\n      restrictedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top );\n    }\n    else {\n      restrictedX = Math.max(Math.min(rect.right  - offset.right , page.x), rect.left + offset.left);\n      restrictedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top  + offset.top );\n    }\n\n    status.dx = restrictedX - page.x;\n    status.dy = restrictedY - page.y;\n\n    status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.restrictedX = restrictedX;\n    status.restrictedY = restrictedY;\n\n    return status;\n  },\n\n  reset: function (status) {\n    status.dx = status.dy = 0;\n    status.modifiedX = status.modifiedY = NaN;\n    status.locked = false;\n    status.changed = true;\n\n    return status;\n  },\n\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\n    const options = interactable.options[actionName].restrict;\n    const elementRect = options && options.elementRect;\n\n    if (options && options.enabled\n        && !(phase === 'start' && elementRect && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy,\n        };\n      }\n    }\n  },\n};\n\nmodifiers.restrict = restrict;\nmodifiers.names.push('restrict');\n\ndefaultOptions.perAction.restrict = restrict.defaults;\n\nmodule.exports = restrict;\n","const modifiers = require('./index');\nconst interact = require('../interact');\nconst utils = require('../utils');\nconst defaultOptions = require('../defaultOptions');\n\nconst snap = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range  : Infinity,\n    targets: null,\n    offsets: null,\n\n    relativePoints: null,\n  },\n\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\n    const snapOptions = interactable.options[actionName].snap;\n\n    return (snapOptions && snapOptions.enabled\n            && (preEnd || !snapOptions.endOnly)\n            && (!requireEndOnly || snapOptions.endOnly));\n  },\n\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\n    const offsets = [];\n    const origin = utils.getOriginXY(interactable, element);\n    const snapOptions = interactable.options[interaction.prepared.name].snap || {};\n    let snapOffset;\n\n    if (snapOptions.offset === 'startCoords') {\n      snapOffset = {\n        x: interaction.startCoords.page.x - origin.x,\n        y: interaction.startCoords.page.y - origin.y,\n      };\n    }\n    else if (snapOptions.offset === 'self') {\n      snapOffset = {\n        x: rect.left - origin.x,\n        y: rect.top - origin.y,\n      };\n    }\n    else {\n      snapOffset = snapOptions.offset || { x: 0, y: 0 };\n    }\n\n    if (rect && snapOptions.relativePoints && snapOptions.relativePoints.length) {\n      for (const { x: relativeX, y: relativeY } of snapOptions.relativePoints) {\n        offsets.push({\n          x: startOffset.left - (rect.width  * relativeX) + snapOffset.x,\n          y: startOffset.top  - (rect.height * relativeY) + snapOffset.y,\n        });\n      }\n    }\n    else {\n      offsets.push(snapOffset);\n    }\n\n    return offsets;\n  },\n\n  set: function (pageCoords, interaction, status) {\n    const snapOptions = interaction.target.options[interaction.prepared.name].snap;\n    const targets = [];\n    let target;\n    let page;\n    let i;\n\n    if (status.useStatusXY) {\n      page = { x: status.x, y: status.y };\n    }\n    else {\n      const origin = utils.getOriginXY(interaction.target, interaction.element);\n\n      page = utils.extend({}, pageCoords);\n\n      page.x -= origin.x;\n      page.y -= origin.y;\n    }\n\n    status.realX = page.x;\n    status.realY = page.y;\n\n    if (interaction.simulation) {\n      page.x -= interaction.simulation.resumeDx;\n      page.y -= interaction.simulation.resumeDy;\n    }\n\n    const offsets = interaction.modifierOffsets.snap;\n    let len = snapOptions.targets? snapOptions.targets.length : 0;\n\n    for (const { x: offsetX, y: offsetY } of offsets) {\n      const relativeX = page.x - offsetX;\n      const relativeY = page.y - offsetY;\n\n      for (const snapTarget of snapOptions.targets) {\n        if (utils.isFunction(snapTarget)) {\n          target = snapTarget(relativeX, relativeY, interaction);\n        }\n        else {\n          target = snapTarget;\n        }\n\n        if (!target) { continue; }\n\n        targets.push({\n          x: utils.isNumber(target.x) ? (target.x + offsetX) : relativeX,\n          y: utils.isNumber(target.y) ? (target.y + offsetY) : relativeY,\n\n          range: utils.isNumber(target.range)? target.range: snapOptions.range,\n        });\n      }\n    }\n\n    const closest = {\n      target: null,\n      inRange: false,\n      distance: 0,\n      range: 0,\n      dx: 0,\n      dy: 0,\n    };\n\n    for (i = 0, len = targets.length; i < len; i++) {\n      target = targets[i];\n\n      const range = target.range;\n      const dx = target.x - page.x;\n      const dy = target.y - page.y;\n      const distance = utils.hypot(dx, dy);\n      let inRange = distance <= range;\n\n      // Infinite targets count as being out of range\n      // compared to non infinite ones that are in range\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n        inRange = false;\n      }\n\n      if (!closest.target || (inRange\n          // is the closest target in range?\n          ? (closest.inRange && range !== Infinity\n          // the pointer is relatively deeper in this target\n          ? distance / range < closest.distance / closest.range\n          // this target has Infinite range and the closest doesn't\n          : (range === Infinity && closest.range !== Infinity)\n          // OR this target is closer that the previous closest\n        || distance < closest.distance)\n          // The other is not in range and the pointer is closer to this target\n          : (!closest.inRange && distance < closest.distance))) {\n\n        closest.target = target;\n        closest.distance = distance;\n        closest.range = range;\n        closest.inRange = inRange;\n        closest.dx = dx;\n        closest.dy = dy;\n\n        status.range = range;\n      }\n    }\n\n    let snapChanged;\n\n    if (closest.target) {\n      snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\n      status.snappedX = closest.target.x;\n      status.snappedY = closest.target.y;\n    }\n    else {\n      snapChanged = true;\n\n      status.snappedX = NaN;\n      status.snappedY = NaN;\n    }\n\n    status.dx = closest.dx;\n    status.dy = closest.dy;\n\n    status.changed = (snapChanged || (closest.inRange && !status.locked));\n    status.locked = closest.inRange;\n\n    return status;\n  },\n\n  reset: function (status) {\n    status.dx = status.dy = 0;\n    status.snappedX = status.snappedY = NaN;\n    status.locked = false;\n    status.changed = true;\n\n    return status;\n  },\n\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\n    const snapOptions = interactable.options[actionName].snap;\n    const relativePoints = snapOptions && snapOptions.relativePoints;\n\n    if (snapOptions && snapOptions.enabled\n        && !(phase === 'start' && relativePoints && relativePoints.length)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n      }\n\n      return {\n        range  : status.range,\n        locked : status.locked,\n        x      : status.snappedX,\n        y      : status.snappedY,\n        realX  : status.realX,\n        realY  : status.realY,\n        dx     : status.dx,\n        dy     : status.dy,\n      };\n    }\n  },\n};\n\ninteract.createSnapGrid = function (grid) {\n  return function (x, y) {\n    let offsetX = 0;\n    let offsetY = 0;\n\n    if (utils.isObject(grid.offset)) {\n      offsetX = grid.offset.x;\n      offsetY = grid.offset.y;\n    }\n\n    const gridx = Math.round((x - offsetX) / grid.x);\n    const gridy = Math.round((y - offsetY) / grid.y);\n\n    const newX = gridx * grid.x + offsetX;\n    const newY = gridy * grid.y + offsetY;\n\n    return {\n      x: newX,\n      y: newY,\n      range: grid.range,\n    };\n  };\n};\n\nmodifiers.snap = snap;\nmodifiers.names.push('snap');\n\ndefaultOptions.perAction.snap = snap.defaults;\n\nmodule.exports = snap;\n","const scope = require('./scope');\nconst InteractEvent = require('./InteractEvent');\nconst Interaction = require('./Interaction');\nconst utils = require('./utils');\nconst browser = require('./utils/browser');\n\nconst simpleSignals = [ 'down', 'up', 'up', 'cancel' ];\nconst simpleEvents = [ 'down', 'up', 'tap', 'cancel' ];\n\nfunction preventOriginalDefault () {\n  this.originalEvent.preventDefault();\n}\n\nfunction firePointers (interaction, pointer, event, eventTarget, targets, elements, eventType) {\n  const pointerIndex = interaction.mouse? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n  let pointerEvent = {};\n  let i;\n  // for tap events\n  let interval;\n  let createNewDoubleTap;\n\n  // if it's a doubletap then the event properties would have been\n  // copied from the tap event and provided as the pointer argument\n  if (eventType === 'doubletap') {\n    pointerEvent = pointer;\n  }\n  else {\n    utils.pointerExtend(pointerEvent, event);\n    if (event !== pointer) {\n      utils.pointerExtend(pointerEvent, pointer);\n    }\n\n    pointerEvent.preventDefault           = preventOriginalDefault;\n    pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n    pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n    pointerEvent.interaction              = interaction;\n\n    pointerEvent.timeStamp     = new Date().getTime();\n    pointerEvent.originalEvent = event;\n    pointerEvent.type          = eventType;\n    pointerEvent.pointerId     = utils.getPointerId(pointer);\n    pointerEvent.pointerType   = interaction.mouse? 'mouse' : !browser.supportsPointerEvent? 'touch'\n      : utils.isString(pointer.pointerType)\n        ? pointer.pointerType\n        : [undefined, undefined,'touch', 'pen', 'mouse'][pointer.pointerType];\n  }\n\n  if (eventType === 'tap') {\n    pointerEvent.dt = pointerEvent.timeStamp - interaction.downTimes[pointerIndex];\n\n    interval = pointerEvent.timeStamp - interaction.tapTime;\n    createNewDoubleTap = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap'\n                            && interaction.prevTap.target === pointerEvent.target\n                            && interval < 500);\n\n    pointerEvent.double = createNewDoubleTap;\n\n    interaction.tapTime = pointerEvent.timeStamp;\n  }\n\n  for (i = 0; i < targets.length; i++) {\n    pointerEvent.currentTarget = elements[i];\n    pointerEvent.interactable = targets[i];\n    targets[i].fire(pointerEvent);\n\n    if (pointerEvent.immediatePropagationStopped\n        || (pointerEvent.propagationStopped\n            && elements[i + 1] !== pointerEvent.currentTarget)) {\n      break;\n    }\n  }\n\n  if (createNewDoubleTap) {\n    const doubleTap = {};\n\n    utils.extend(doubleTap, pointerEvent);\n\n    doubleTap.dt   = interval;\n    doubleTap.type = 'doubletap';\n\n    collectEventTargets(interaction, doubleTap, event, eventTarget, 'doubletap');\n\n    interaction.prevTap = doubleTap;\n  }\n  else if (eventType === 'tap') {\n    interaction.prevTap = pointerEvent;\n  }\n}\n\nfunction collectEventTargets (interaction, pointer, event, eventTarget, eventType) {\n  const pointerIndex = interaction.mouse? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (eventType === 'tap' && (interaction.pointerWasMoved\n      // or if the pointerup target is different to the pointerdown target\n      || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n    return;\n  }\n\n  const targets = [];\n  const elements = [];\n  let element = eventTarget;\n\n  function collectSelectors (interactable, selector, context) {\n    const els = browser.useMatchesSelectorPolyfill\n        ? context.querySelectorAll(selector)\n        : undefined;\n\n    if (interactable._iEvents[eventType]\n        && utils.isElement(element)\n        && scope.inContext(interactable, element)\n        && !scope.testIgnore(interactable, element, eventTarget)\n        && scope.testAllow(interactable, element, eventTarget)\n        && utils.matchesSelector(element, selector, els)) {\n\n      targets.push(interactable);\n      elements.push(element);\n    }\n  }\n\n  const interact = scope.interact;\n\n  while (element) {\n    if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n      targets.push(interact(element));\n      elements.push(element);\n    }\n\n    scope.interactables.forEachSelector(collectSelectors);\n\n    element = utils.parentElement(element);\n  }\n\n  // create the tap event even if there are no listeners so that\n  // doubletap can still be created and fired\n  if (targets.length || eventType === 'tap') {\n    firePointers(interaction, pointer, event, eventTarget, targets, elements, eventType);\n  }\n}\n\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget, duplicateMove }) {\n  const pointerIndex = (interaction.mouse\n    ? 0\n    : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer)));\n\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearTimeout(interaction.holdTimers[pointerIndex]);\n    }\n\n    collectEventTargets(interaction, pointer, event, eventTarget, 'move');\n  }\n});\n\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget, pointerIndex }) {\n  // copy event to be used in timeout for IE8\n  const eventCopy = browser.isIE8? utils.extend({}, event) : event;\n\n  interaction.holdTimers[pointerIndex] = setTimeout(function () {\n\n    collectEventTargets(interaction,\n                        browser.isIE8? eventCopy : pointer,\n                        eventCopy,\n                        eventTarget,\n                        'hold');\n\n  }, scope.defaultOptions._holdDuration);\n});\n\nfunction createSignalListener (event) {\n  return function (arg) {\n    collectEventTargets(arg.interaction,\n                        arg.pointer,\n                        arg.event,\n                        arg.eventTarget,\n                        event);\n  };\n}\n\nfor (let i = 0; i < simpleSignals.length; i++) {\n  Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.prevTap = null;  // the most recent tap event on this interaction\n  interaction.tapTime = 0;     // time of the most recent tap event\n});\n\nutils.merge(scope.eventTypes, [\n  'down',\n  'move',\n  'up',\n  'cancel',\n  'tap',\n  'doubletap',\n  'hold',\n]);\n\nmodule.exports = scope.pointerEvents = {\n  firePointers,\n  collectEventTargets,\n  preventOriginalDefault,\n};\n","const scope   = {};\nconst utils   = require('./utils');\nconst signals = require('./utils/Signals').new();\n\nscope.defaultOptions = require('./defaultOptions');\nscope.events         = require('./utils/events');\n\nscope.signals        = signals;\n\nutils.extend(scope, require('./utils/window'));\nutils.extend(scope, require('./utils/domObjects'));\n\nscope.documents  = [];  // all documents being listened to\nscope.eventTypes = [];  // all event types specific to interact.js\n\nscope.withinInteractionLimit = function (interactable, element, action) {\n  const options = interactable.options;\n  const maxActions = options[action.name].max;\n  const maxPerElement = options[action.name].maxPerElement;\n  let activeInteractions = 0;\n  let targetCount = 0;\n  let targetElementCount = 0;\n\n  for (let i = 0, len = scope.interactions.length; i < len; i++) {\n    const interaction = scope.interactions[i];\n    const otherAction = interaction.prepared.name;\n\n    if (!interaction.interacting()) { continue; }\n\n    activeInteractions++;\n\n    if (activeInteractions >= scope.maxInteractions) {\n      return false;\n    }\n\n    if (interaction.target !== interactable) { continue; }\n\n    targetCount += (otherAction === action.name)|0;\n\n    if (targetCount >= maxActions) {\n      return false;\n    }\n\n    if (interaction.element === element) {\n      targetElementCount++;\n\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n        return false;\n      }\n    }\n  }\n\n  return scope.maxInteractions > 0;\n};\n\nscope.endAllInteractions = function (event) {\n  for (let i = 0; i < scope.interactions.length; i++) {\n    scope.interactions[i].end(event);\n  }\n};\n\nscope.prefixedPropREs = utils.prefixedPropREs;\n\nscope.signals.on('listen-to-document', function ({ doc }) {\n  // if document is already known\n  if (utils.contains(scope.documents, doc)) {\n    // don't call any further signal listeners\n    return false;\n  }\n});\n\nmodule.exports = scope;\n","const { indexOf } = require('./arr');\n\nclass Signals {\n  constructor () {\n    this.listeners = {\n      // signalName: [listeners],\n    };\n  }\n\n  on (name, listener) {\n    if (!this.listeners[name]) {\n      this.listeners[name] = [listener];\n      return;\n    }\n\n    this.listeners[name].push(listener);\n  }\n\n  off (name, listener) {\n    if (!this.listeners[name]) { return; }\n\n    const index = indexOf(this.listeners[name], listener);\n\n    if (index !== -1) {\n      this.listeners[name].splice(index, 1);\n    }\n  }\n\n  fire (name, arg) {\n    const targetListeners = this.listeners[name];\n\n    if (!targetListeners) { return; }\n\n    for (let i = 0; i < targetListeners.length; i++) {\n      if (targetListeners[i](arg, name) === false) {\n        return;\n      }\n    }\n  }\n}\n\nSignals.new = function () {\n  return new Signals();\n};\n\nmodule.exports = Signals;\n","function indexOf (array, target) {\n  for (let i = 0, len = array.length; i < len; i++) {\n    if (array[i] === target) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction contains (array, target) {\n  return indexOf(array, target) !== -1;\n}\n\nfunction merge (target, source) {\n  for (let i = 0; i < source.length; i++) {\n    target.push(source[i]);\n  }\n\n  return target;\n}\n\nmodule.exports = {\n  indexOf,\n  contains,\n  merge,\n};\n","const win        = require('./window');\nconst isType     = require('./isType');\nconst domObjects = require('./domObjects');\n\nconst browser = {\n  // Does the browser support touch input?\n  supportsTouch: !!(('ontouchstart' in win.window) || isType.isFunction(win.window.DocumentTouch)\n                     && domObjects.document instanceof win.DocumentTouch),\n\n  // Does the browser support PointerEvents\n  supportsPointerEvent: !!domObjects.PointerEvent,\n\n  isIE8: ('attachEvent' in win.window) && !('addEventListener' in win.window),\n\n  // Opera Mobile must be handled differently\n  isOperaMobile: (navigator.appName === 'Opera'\n      && browser.supportsTouch\n      && navigator.userAgent.match('Presto')),\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  isIOS7: (/iP(hone|od|ad)/.test(navigator.platform)\n           && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n  isIe9OrOlder: domObjects.document.all && !win.window.atob,\n\n  // prefix matchesSelector\n  prefixedMatchesSelector: 'matches' in Element.prototype\n    ? 'matches': 'webkitMatchesSelector' in Element.prototype\n    ? 'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype\n    ? 'mozMatchesSelector': 'oMatchesSelector' in Element.prototype\n    ? 'oMatchesSelector': 'msMatchesSelector',\n\n  useMatchesSelectorPolyfill: false,\n\n  pEventTypes: (domObjects.PointerEvent\n    ? (domObjects.PointerEvent === win.window.MSPointerEvent\n      ? { up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n          out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' }\n      : { up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n          out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' })\n    : null),\n};\n\nbrowser.useMatchesSelectorPolyfill = !isType.isFunction(Element.prototype[browser.prefixedMatchesSelector]);\n\nmodule.exports = browser;\n","const domObjects = {};\nconst win = require('./window').window;\n\nfunction blank () {}\n\ndomObjects.document           = win.document;\ndomObjects.DocumentFragment   = win.DocumentFragment   || blank;\ndomObjects.SVGElement         = win.SVGElement         || blank;\ndomObjects.SVGSVGElement      = win.SVGSVGElement      || blank;\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\ndomObjects.HTMLElement        = win.HTMLElement        || win.Element;\n\ndomObjects.Event        = win.Event;\ndomObjects.Touch        = win.Touch || blank;\ndomObjects.PointerEvent = (win.PointerEvent || win.MSPointerEvent);\n\nmodule.exports = domObjects;\n","const win        = require('./window');\nconst browser    = require('./browser');\nconst isType     = require('./isType');\nconst domObjects = require('./domObjects');\n\nconst domUtils = {\n  nodeContains: function (parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  },\n\n  closest: function (child, selector) {\n    let parent = domUtils.parentElement(child);\n\n    while (isType.isElement(parent)) {\n      if (domUtils.matchesSelector(parent, selector)) { return parent; }\n\n      parent = domUtils.parentElement(parent);\n    }\n\n    return null;\n  },\n\n  parentElement: function (node) {\n    let parent = node.parentNode;\n\n    if (isType.isDocFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && isType.isDocFrag(parent)) {\n        continue;\n      }\n\n      return parent;\n    }\n\n    return parent;\n  },\n\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n  matchesSelectorPolyfill: browser.useMatchesSelectorPolyfill\n    ? function (element, selector, elems) {\n      elems = elems || element.parentNode.querySelectorAll(selector);\n\n      for (let i = 0, len = elems.length; i < len; i++) {\n        if (elems[i] === element) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    : null,\n\n  matchesSelector: function (element, selector, nodeList) {\n    if (browser.useMatchesSelectorPolyfill) {\n      return domUtils.matchesSelectorPolyfill(element, selector, nodeList);\n    }\n\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (win.window !== win.realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[browser.prefixedMatchesSelector](selector);\n  },\n\n  // Test for the element that's \"above\" all other qualifiers\n  indexOfDeepestElement: function (elements) {\n    let deepestZoneParents = [];\n    let dropzoneParents = [];\n    let dropzone;\n    let deepestZone = elements[0];\n    let index = deepestZone? 0: -1;\n    let parent;\n    let child;\n    let i;\n    let n;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (deepestZone instanceof domObjects.HTMLElement\n          && dropzone instanceof domObjects.SVGElement\n          && !(dropzone instanceof domObjects.SVGSVGElement)) {\n\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      }\n      else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      const parents = [\n        dropzoneParents[n - 1],\n        dropzoneParents[n],\n        deepestZoneParents[n],\n      ];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        }\n        else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  },\n\n  matchesUpTo: function (element, selector, limit) {\n    while (domUtils.isElement(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = domUtils.parentElement(element);\n\n      if (element === limit) {\n        return domUtils.matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  },\n\n  getActualElement: function (element) {\n    return (element instanceof domObjects.SVGElementInstance\n      ? element.correspondingUseElement\n      : element);\n  },\n\n  getScrollXY: function (relevantWindow) {\n    relevantWindow = relevantWindow || win.window;\n    return {\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n    };\n  },\n\n  getElementClientRect: function (element) {\n    const clientRect = (element instanceof domObjects.SVGElement\n      ? element.getBoundingClientRect()\n      : element.getClientRects()[0]);\n\n    return clientRect && {\n      left  : clientRect.left,\n      right : clientRect.right,\n      top   : clientRect.top,\n      bottom: clientRect.bottom,\n      width : clientRect.width  || clientRect.right  - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    };\n  },\n\n  getElementRect: function (element) {\n    const clientRect = domUtils.getElementClientRect(element);\n\n    if (!browser.isIOS7 && clientRect) {\n      const scroll = domUtils.getScrollXY(win.getWindow(element));\n\n      clientRect.left   += scroll.x;\n      clientRect.right  += scroll.x;\n      clientRect.top    += scroll.y;\n      clientRect.bottom += scroll.y;\n    }\n\n    return clientRect;\n  },\n};\n\nmodule.exports = domUtils;\n","const arr       = require('./arr');\nconst isType    = require('./isType');\nconst domUtils  = require('./domUtils');\nconst indexOf   = arr.indexOf;\nconst contains  = arr.contains;\nconst getWindow = require('./window').getWindow;\n\nconst useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window);\nconst addEvent       = useAttachEvent?  'attachEvent': 'addEventListener';\nconst removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener';\nconst on             = useAttachEvent? 'on': '';\n\nconst elements          = [];\nconst targets           = [];\nconst attachedListeners = [];\n\n// {\n//   type: {\n//     selectors: ['selector', ...],\n//     contexts : [document, ...],\n//     listeners: [[listener, useCapture], ...]\n//   }\n//  }\nconst delegatedEvents = {};\n\nconst documents = [];\n\nfunction add (element, type, listener, useCapture) {\n  let elementIndex = indexOf(elements, element);\n  let target = targets[elementIndex];\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0,\n    };\n\n    elementIndex = elements.push(element) - 1;\n    targets.push(target);\n\n    attachedListeners.push((useAttachEvent ? {\n      supplied: [],\n      wrapped : [],\n      useCount: [],\n    } : null));\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = [];\n    target.typeCount++;\n  }\n\n  if (!contains(target.events[type], listener)) {\n    let ret;\n\n    if (useAttachEvent) {\n      const { supplied, wrapped, useCount } = attachedListeners[elementIndex];\n      const listenerIndex = indexOf(supplied, listener);\n\n      const wrappedListener = wrapped[listenerIndex] || function (event) {\n        if (!event.immediatePropagationStopped) {\n          event.target = event.srcElement;\n          event.currentTarget = element;\n\n          event.preventDefault           = event.preventDefault           || preventDef;\n          event.stopPropagation          = event.stopPropagation          || stopProp;\n          event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n          if (/mouse|click/.test(event.type)) {\n            event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n            event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n          }\n\n          listener(event);\n        }\n      };\n\n      ret = element[addEvent](on + type, wrappedListener, !!useCapture);\n\n      if (listenerIndex === -1) {\n        supplied.push(listener);\n        wrapped.push(wrappedListener);\n        useCount.push(1);\n      }\n      else {\n        useCount[listenerIndex]++;\n      }\n    }\n    else {\n      ret = element[addEvent](type, listener, !!useCapture);\n    }\n    target.events[type].push(listener);\n\n    return ret;\n  }\n}\n\nfunction remove (element, type, listener, useCapture) {\n  const elementIndex = indexOf(elements, element);\n  const target = targets[elementIndex];\n\n  if (!target || !target.events) {\n    return;\n  }\n\n  let wrappedListener = listener;\n  let listeners;\n  let listenerIndex;\n\n  if (useAttachEvent) {\n    listeners = attachedListeners[elementIndex];\n    listenerIndex = indexOf(listeners.supplied, listener);\n    wrappedListener = listeners.wrapped[listenerIndex];\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all');\n      }\n    }\n    return;\n  }\n\n  if (target.events[type]) {\n    const len = target.events[type].length;\n\n    if (listener === 'all') {\n      for (let i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], !!useCapture);\n      }\n      return;\n    }\n    else {\n      for (let i = 0; i < len; i++) {\n        if (target.events[type][i] === listener) {\n          element[removeEvent](on + type, wrappedListener, !!useCapture);\n          target.events[type].splice(i, 1);\n\n          if (useAttachEvent && listeners) {\n            listeners.useCount[listenerIndex]--;\n            if (listeners.useCount[listenerIndex] === 0) {\n              listeners.supplied.splice(listenerIndex, 1);\n              listeners.wrapped.splice(listenerIndex, 1);\n              listeners.useCount.splice(listenerIndex, 1);\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      target.events[type] = null;\n      target.typeCount--;\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1);\n    elements.splice(elementIndex, 1);\n    attachedListeners.splice(elementIndex, 1);\n  }\n}\n\nfunction addDelegate (selector, context, type, listener, useCapture) {\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      selectors: [],\n      contexts : [],\n      listeners: [],\n    };\n\n    // add delegate listener functions\n    for (let i = 0; i < documents.length; i++) {\n      add(documents[i], type, delegateListener);\n      add(documents[i], type, delegateUseCapture, true);\n    }\n  }\n\n  const delegated = delegatedEvents[type];\n  let index;\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector\n        && delegated.contexts[index] === context) {\n      break;\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length;\n\n    delegated.selectors.push(selector);\n    delegated.contexts .push(context);\n    delegated.listeners.push([]);\n  }\n\n  // keep listener and useCapture flag\n  delegated.listeners[index].push([listener, useCapture]);\n}\n\nfunction removeDelegate (selector, context, type, listener, useCapture) {\n  const delegated = delegatedEvents[type];\n  let matchFound = false;\n  let index;\n\n  if (!delegated) { return; }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector\n        && delegated.contexts[index] === context) {\n\n      const listeners = delegated.listeners[index];\n\n      // each item of the listeners array is an array: [function, useCaptureFlag]\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        const fn = listeners[i][0];\n        const useCap = listeners[i][1];\n\n        // check if the listener functions and useCapture flags match\n        if (fn === listener && useCap === useCapture) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1);\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1);\n            delegated.contexts .splice(index, 1);\n            delegated.listeners.splice(index, 1);\n\n            // remove delegate function from context\n            remove(context, type, delegateListener);\n            remove(context, type, delegateUseCapture, true);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null;\n            }\n          }\n\n          // only remove one listener\n          matchFound = true;\n          break;\n        }\n      }\n\n      if (matchFound) { break; }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener (event, useCapture) {\n  const fakeEvent = {};\n  const delegated = delegatedEvents[event.type];\n  const eventTarget = (domUtils.getActualElement(event.path\n    ? event.path[0]\n    : event.target));\n  let element = eventTarget;\n\n  useCapture = useCapture? true: false;\n\n  // duplicate the event so that currentTarget can be changed\n  for (const prop in event) {\n    fakeEvent[prop] = event[prop];\n  }\n\n  fakeEvent.originalEvent = event;\n  fakeEvent.preventDefault = preventOriginalDefault;\n\n  // climb up document tree looking for selector matches\n  while (isType.isElement(element)) {\n    for (let i = 0; i < delegated.selectors.length; i++) {\n      const selector = delegated.selectors[i];\n      const context = delegated.contexts[i];\n\n      if (domUtils.matchesSelector(element, selector)\n          && domUtils.nodeContains(context, eventTarget)\n          && domUtils.nodeContains(context, element)) {\n\n        const listeners = delegated.listeners[i];\n\n        fakeEvent.currentTarget = element;\n\n        for (let j = 0; j < listeners.length; j++) {\n          if (listeners[j][1] === useCapture) {\n            listeners[j][0](fakeEvent);\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentElement(element);\n  }\n}\n\nfunction delegateUseCapture (event) {\n  return delegateListener.call(this, event, true);\n}\n\nfunction preventDef () {\n  this.returnValue = false;\n}\n\nfunction preventOriginalDefault () {\n  this.originalEvent.preventDefault();\n}\n\nfunction stopProp () {\n  this.cancelBubble = true;\n}\n\nfunction stopImmProp () {\n  this.cancelBubble = true;\n  this.immediatePropagationStopped = true;\n}\n\nmodule.exports = {\n  add,\n  remove,\n\n  addDelegate,\n  removeDelegate,\n\n  delegateListener,\n  delegateUseCapture,\n  delegatedEvents,\n  documents,\n\n  useAttachEvent,\n\n  _elements: elements,\n  _targets: targets,\n  _attachedListeners: attachedListeners,\n};\n","module.exports = function extend (dest, source) {\n  for (const prop in source) {\n    dest[prop] = source[prop];\n  }\n  return dest;\n};\n","const { closest, parentElement, getElementRect } = require('./domUtils');\nconst { isElement, isFunction, trySelector }     = require('./isType');\n\nmodule.exports = function (interactable, element) {\n  let origin = interactable.options.origin;\n\n  if (origin === 'parent') {\n    origin = parentElement(element);\n  }\n  else if (origin === 'self') {\n    origin = interactable.getRect(element);\n  }\n  else if (trySelector(origin)) {\n    origin = closest(element, origin) || { x: 0, y: 0 };\n  }\n\n  if (isFunction(origin)) {\n    origin = origin(interactable && element);\n  }\n\n  if (isElement(origin))  {\n    origin = getElementRect(origin);\n  }\n\n  origin.x = ('x' in origin)? origin.x : origin.left;\n  origin.y = ('y' in origin)? origin.y : origin.top;\n\n  return origin;\n};\n","module.exports = (x, y) =>  Math.sqrt(x * x + y * y);\n","const utils = module.exports;\nconst extend = require('./extend');\nconst win = require('./window');\n\nutils.blank = function () {};\n\nutils.warnOnce = function (method, message) {\n  let warned = false;\n\n  return function () {\n    if (!warned) {\n      win.window.console.warn(message);\n      warned = true;\n    }\n\n    return method.apply(this, arguments);\n  };\n};\n\n// http://stackoverflow.com/a/5634528/2280888\nutils._getQBezierValue = function (t, p1, p2, p3) {\n  const iT = 1 - t;\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n};\n\nutils.getQuadraticCurvePoint = function (startX, startY, cpX, cpY, endX, endY, position) {\n  return {\n    x:  utils._getQBezierValue(position, startX, cpX, endX),\n    y:  utils._getQBezierValue(position, startY, cpY, endY),\n  };\n};\n\n// http://gizma.com/easing/\nutils.easeOutQuad = function (t, b, c, d) {\n  t /= d;\n  return -c * t*(t-2) + b;\n};\n\nutils.copyAction = function (dest, src) {\n  dest.name  = src.name;\n  dest.axis  = src.axis;\n  dest.edges = src.edges;\n\n  return dest;\n};\n\nutils.extend      = extend;\nutils.hypot       = require('./hypot');\nutils.raf         = require('./raf');\nutils.browser     = require('./browser');\nutils.getOriginXY = require('./getOriginXY');\n\nextend(utils, require('./arr'));\nextend(utils, require('./isType'));\nextend(utils, require('./domUtils'));\nextend(utils, require('./pointerUtils'));\n","const scope = require('../scope');\nconst utils = require('./index');\nconst browser = require('./browser');\n\nconst finder = {\n  methodOrder: [ 'simulationResume', 'mouse', 'hasPointer', 'idle' ],\n\n  search: function (pointer, eventType, eventTarget) {\n    const mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n                        // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                        || pointer.pointerType === 4);\n    const pointerId = utils.getPointerId(pointer);\n    const details = { pointer, pointerId, mouseEvent, eventType, eventTarget };\n\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details);\n\n      if (interaction) {\n        return interaction;\n      }\n    }\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume: function ({ mouseEvent, eventType, eventTarget }) {\n    if (!/down|start/i.test(eventType)) {\n      return null;\n    }\n\n    for (const interaction of scope.interactions) {\n      let element = eventTarget;\n\n      if (interaction.simulation && interaction.simulation.allowResume\n          && (interaction.mouse === mouseEvent)) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction;\n          }\n          element = utils.parentElement(element);\n        }\n      }\n    }\n\n    return null;\n  },\n\n  // if it's a mouse interaction\n  mouse: function ({ mouseEvent, eventType }) {\n    if (!mouseEvent && (browser.supportsTouch || browser.supportsPointerEvent)) {\n      return null;\n    }\n\n    let firstNonActive;\n\n    for (const interaction of scope.interactions) {\n      if (interaction.mouse) {\n        // if it's a down event, skip interactions with running simulations\n        if (/down/i.test(eventType) && interaction.simulation) { continue; }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction;\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction;\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive;\n    }\n\n    // Find any interaction specifically for mouse.\n    // ignore the interaction if the eventType is a mousedown, and a simulation\n    // is active\n    for (const interaction of scope.interactions) {\n      if (interaction.mouse && !(/down/.test(eventType) && interaction.simulation)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n\n  // get interaction that has this pointer\n  hasPointer: function ({ pointerId }) {\n    for (const interaction of scope.interactions) {\n      if (utils.contains(interaction.pointerIds, pointerId)) {\n        return interaction;\n      }\n    }\n  },\n\n  // get first idle interaction\n  idle: function ({ mouseEvent }) {\n    for (const interaction of scope.interactions) {\n      // if there's already a pointer held down\n      if (interaction.pointerIds.length === 1) {\n        const target = interaction.target;\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !target.options.gesture.enabled) {\n          continue;\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointerIds.length >= 2) {\n        continue;\n      }\n\n      if (!interaction.interacting() && !(!mouseEvent && interaction.mouse)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n};\n\nmodule.exports = finder;\n","const win        = require('./window');\nconst isWindow   = require('./isWindow');\nconst domObjects = require('./domObjects');\n\nconst isType = {\n  isElement  : function (o) {\n    if (!o || (typeof o !== 'object')) { return false; }\n\n    const _window = win.getWindow(o) || win.window;\n\n    return (/object|function/.test(typeof _window.Element)\n      ? o instanceof _window.Element //DOM2\n      : o.nodeType === 1 && typeof o.nodeName === 'string');\n  },\n\n  isArray    : null,\n\n  isWindow   : function (thing) { return thing === win.window || isWindow(thing); },\n\n  isDocFrag  : function (thing) { return isType.isObject(thing) && thing.nodeType === 11; },\n\n  isObject   : function (thing) { return !!thing && (typeof thing === 'object'); },\n\n  isFunction : function (thing) { return typeof thing === 'function'; },\n\n  isNumber   : function (thing) { return typeof thing === 'number'  ; },\n\n  isBool     : function (thing) { return typeof thing === 'boolean' ; },\n\n  isString   : function (thing) { return typeof thing === 'string'  ; },\n\n  trySelector: function (value) {\n    if (!isType.isString(value)) { return false; }\n\n    // an exception will be raised if it is invalid\n    domObjects.document.querySelector(value);\n    return true;\n  },\n};\n\nisType.isArray = function (thing) {\n  return (isType.isObject(thing)\n      && (typeof thing.length !== 'undefined')\n      && isType.isFunction(thing.splice));\n};\n\nmodule.exports = isType;\n","module.exports = (thing) => !!(thing && thing.Window) && (thing instanceof thing.Window);\n","const hypot   = require('./hypot');\nconst browser = require('./browser');\nconst dom     = require('./domObjects');\nconst isType  = require('./isType');\n\nconst pointerUtils = {\n  copyCoords: function (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  },\n\n  setEventDeltas: function (targetObj, prev, cur) {\n    const now = new Date().getTime();\n\n    targetObj.page.x    = cur.page.x   - prev.page.x;\n    targetObj.page.y    = cur.page.y   - prev.page.y;\n    targetObj.client.x  = cur.client.x - prev.client.x;\n    targetObj.client.y  = cur.client.y - prev.client.y;\n    targetObj.timeStamp = now          - prev.timeStamp;\n\n    // set pointer velocity\n    const dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\n    targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx      = targetObj.page.x / dt;\n    targetObj.page.vy      = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx    = targetObj.client.x / dt;\n    targetObj.client.vy    = targetObj.client.y / dt;\n  },\n\n  isNativePointer: function  (pointer) {\n    return (pointer instanceof dom.Event || pointer instanceof dom.Touch);\n  },\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  getXY: function (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  },\n\n  getPageXY: function (pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      pointerUtils.getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    }\n    else {\n      pointerUtils.getXY('page', pointer, page);\n    }\n\n    return page;\n  },\n\n  getClientXY: function (pointer, client) {\n    client = client || {};\n\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      pointerUtils.getXY('screen', pointer, client);\n    }\n    else {\n      pointerUtils.getXY('client', pointer, client);\n    }\n\n    return client;\n  },\n\n  getPointerId: function (pointer) {\n    return isType.isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n  },\n\n  prefixedPropREs: {\n    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n  },\n\n  pointerExtend: function (dest, source) {\n    for (const prop in source) {\n      const prefixedPropREs = pointerUtils.prefixedPropREs;\n      let deprecated = false;\n\n      // skip deprecated prefixed properties\n      for (const vendor in prefixedPropREs) {\n        if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n          deprecated = true;\n          break;\n        }\n      }\n\n      if (!deprecated) {\n        dest[prop] = source[prop];\n      }\n    }\n    return dest;\n  },\n\n  getTouchPair: function (event) {\n    const touches = [];\n\n    // array of touches is supplied\n    if (isType.isArray(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n      if (event.type === 'touchend') {\n        if (event.touches.length === 1) {\n          touches[0] = event.touches[0];\n          touches[1] = event.changedTouches[0];\n        }\n        else if (event.touches.length === 0) {\n          touches[0] = event.changedTouches[0];\n          touches[1] = event.changedTouches[1];\n        }\n      }\n      else {\n        touches[0] = event.touches[0];\n        touches[1] = event.touches[1];\n      }\n    }\n\n    return touches;\n  },\n\n  pointerAverage: function (pointers) {\n    const average = {\n      pageX  : 0,\n      pageY  : 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0,\n    };\n\n    for (const pointer of pointers) {\n      for (const prop in average) {\n        average[prop] += pointer[prop];\n      }\n    }\n    for (const prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  },\n\n  touchBBox: function (event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    const touches = pointerUtils.getTouchPair(event);\n    const minX = Math.min(touches[0].pageX, touches[1].pageX);\n    const minY = Math.min(touches[0].pageY, touches[1].pageY);\n    const maxX = Math.max(touches[0].pageX, touches[1].pageX);\n    const maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  },\n\n  touchDistance: function (event, deltaSource) {\n    deltaSource = deltaSource;\n\n    const sourceX = deltaSource + 'X';\n    const sourceY = deltaSource + 'Y';\n    const touches = pointerUtils.getTouchPair(event);\n\n\n    const dx = touches[0][sourceX] - touches[1][sourceX];\n    const dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  },\n\n  touchAngle: function (event, prevAngle, deltaSource) {\n    deltaSource = deltaSource;\n\n    const sourceX = deltaSource + 'X';\n    const sourceY = deltaSource + 'Y';\n    const touches = pointerUtils.getTouchPair(event);\n    const dx = touches[1][sourceX] - touches[0][sourceX];\n    const dy = touches[1][sourceY] - touches[0][sourceY];\n    let angle = 180 * Math.atan2(dy , dx) / Math.PI;\n\n    return  angle;\n  },\n};\n\nmodule.exports = pointerUtils;\n","const vendors = ['ms', 'moz', 'webkit', 'o'];\nlet lastTime = 0;\nlet request;\nlet cancel;\n\nfor (let x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n  request = window[vendors[x] + 'RequestAnimationFrame'];\n  cancel = window[vendors[x] +'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  request = function (callback) {\n    const currTime = new Date().getTime();\n    const timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    const id = setTimeout(function () { callback(currTime + timeToCall); },\n                          timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  cancel = function (id) {\n    clearTimeout(id);\n  };\n}\n\nmodule.exports = {\n  request,\n  cancel,\n};\n","const win = module.exports;\nconst isWindow = require('./isWindow');\n\nfunction init (window) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  win.realWindow = window;\n\n  // create a TextNode\n  const el = window.document.createTextNode('');\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document\n      && typeof window.wrap === 'function'\n    && window.wrap(el) === el) {\n    // return wrapped window\n    win.window = window.wrap(window);\n  }\n\n  // no Shadow DOM polyfil or native implementation\n  win.window = window;\n}\n\nif (typeof window === 'undefined') {\n  win.window     = undefined;\n  win.realWindow = undefined;\n}\nelse {\n  init(window);\n}\n\nwin.getWindow = function getWindow (node) {\n  if (isWindow(node)) {\n    return node;\n  }\n\n  const rootNode = (node.ownerDocument || node);\n\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\n};\n\nwin.init = init;\n"],"sourceRoot":"/source/"}