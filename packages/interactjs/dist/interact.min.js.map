{"version":3,"sources":["../../scripts/minHeader.js","../../scripts/header.js","../utils/arr.ts","../utils/window.ts","../actions/drag.ts","../utils/domObjects.ts","../utils/browser.ts","../utils/clone.ts","../utils/domUtils.ts","../utils/pointerExtend.ts","../utils/events.ts","../utils/extend.ts","../utils/rect.ts","../utils/getOriginXY.ts","../utils/normalizeListeners.ts","../utils/raf.ts","../utils/index.ts","../actions/drop/index.ts","../actions/gesture.ts","../actions/resize.ts","../actions/index.ts","../auto-scroll/index.ts","../auto-start/InteractableMethods.ts","../auto-start/base.ts","../auto-start/dragAxis.ts","../auto-start/hold.ts","../auto-start/index.ts","../core/interactablePreventDefault.ts","../modifiers/base.ts","../inertia/index.ts","../core/Eventable.ts","../utils/interactionFinder.ts","../core/interactions.ts","../core/scope.ts","../interact/interact.ts","../modifiers/restrict/pointer.ts","../modifiers/restrict/edges.ts","../modifiers/restrict/size.ts","../modifiers/snap/pointer.ts","../modifiers/snap/size.ts","../modifiers/snap/edges.ts","../pointer-events/base.ts","../pointer-events/holdRepeat.ts","../pointer-events/interactableTargets.ts","../pointer-events/index.ts","../reflow/index.ts","../interact/index.ts","../utils/snappers/grid.ts","index.ts","../utils/isWindow.ts","../utils/is.ts","../actions/drop/DropEvent.ts","../utils/Signals.ts","../utils/hypot.ts","../utils/pointerUtils.ts","../core/defaultOptions.ts","../core/InteractEvent.ts","../core/Interactable.ts","../core/PointerInfo.ts","../core/Interaction.ts","../modifiers/index.ts","../pointer-events/PointerEvent.ts","../utils/snappers/index.ts","../../node_modules/browser-pack-flat/_postlude"],"names":[],"mappings":"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","file":"interact.min.js","sourceRoot":"","sourcesContent":["/* interact.js v1.4.0-alpha.25+sha.c3a67ce-dirty | https://raw.github.com/taye/interact.js/master/LICENSE */\n","/**\n * interact.js v1.4.0-alpha.25+sha.c3a67ce-dirty\n *\n * Copyright (c) 2012-2019 Taye Adeyemi <dev@taye.me>\n * Released under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n","export function contains (array, target) {\n  return array.indexOf(target) !== -1\n}\n\nexport function remove (array, target) {\n  return array.splice(array.indexOf(target), 1)\n}\n\nexport function merge (target, source) {\n  for (const item of source) {\n    target.push(item)\n  }\n\n  return target\n}\n\nexport function from (source) {\n  return merge([], source)\n}\n\nexport function findIndex (array, func) {\n  for (let i = 0; i < array.length; i++) {\n    if (func(array[i], i, array)) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport function find (array, func) {\n  return array[findIndex(array, func)]\n}\n\nexport function some (array, func) {\n  return findIndex(array, func) !== -1\n}\n","import isWindow from './isWindow'\n\nconst win = {\n  realWindow: undefined,\n  window: undefined,\n  getWindow,\n  init,\n}\n\nexport function init (window) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  win.realWindow = window\n\n  // create a TextNode\n  const el = window.document.createTextNode('')\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document &&\n      typeof window.wrap === 'function' &&\n    window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window)\n  }\n\n  win.window = window\n}\n\nif (typeof window === 'undefined') {\n  win.window     = undefined\n  win.realWindow = undefined\n}\nelse {\n  init(window)\n}\n\nexport function getWindow (node) {\n  if (isWindow(node)) {\n    return node\n  }\n\n  const rootNode = (node.ownerDocument || node)\n\n  return rootNode.defaultView || win.window\n}\n\nwin.init = init\n\nexport default win\n","import { Scope } from '@interactjs/core/scope'\nimport * as arr from '@interactjs/utils/arr'\nimport * as is from '@interactjs/utils/is'\n\nexport type DraggableMethod = (options?: Interact.OrBoolean<Interact.DraggableOptions> | boolean)\n  => Interact.Interactable | Interact.DropzoneOptions\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    Interactable,\n    interactions,\n    defaults,\n  } = scope\n\n  interactions.signals.on('before-action-move', beforeMove)\n  interactions.signals.on('action-resume', beforeMove)\n\n  // dragmove\n  interactions.signals.on('action-move', move)\n\n  Interactable.prototype.draggable = drag.draggable\n\n  actions.drag = drag\n  actions.names.push('drag')\n  arr.merge(actions.eventTypes, [\n    'dragstart',\n    'dragmove',\n    'draginertiastart',\n    'dragresume',\n    'dragend',\n  ])\n  actions.methodDict.drag = 'draggable'\n\n  defaults.actions.drag = drag.defaults\n}\n\nfunction beforeMove ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') { return }\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x') {\n    interaction.coords.cur.page.y   = interaction.coords.start.page.y\n    interaction.coords.cur.client.y = interaction.coords.start.client.y\n\n    interaction.coords.velocity.client.y = 0\n    interaction.coords.velocity.page.y   = 0\n  }\n  else if (axis === 'y') {\n    interaction.coords.cur.page.x   = interaction.coords.start.page.x\n    interaction.coords.cur.client.x = interaction.coords.start.client.x\n\n    interaction.coords.velocity.client.x = 0\n    interaction.coords.velocity.page.x   = 0\n  }\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'drag') { return }\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x' || axis === 'y') {\n    const opposite = axis === 'x' ? 'y' : 'x'\n\n    iEvent.page[opposite]   = interaction.coords.start.page[opposite]\n    iEvent.client[opposite] = interaction.coords.start.client[opposite]\n    iEvent.delta[opposite] = 0\n  }\n}\n\n/**\n * ```js\n * interact(element).draggable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // the axis in which the first movement must be\n *     // for the drag sequence to start\n *     // 'xy' by default - any direction\n *     startAxis: 'x' || 'y' || 'xy',\n *\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\n *     // 'x' or 'y' to restrict movement to either axis\n *     // 'start' to restrict movement to the axis the drag started in\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n *\n *     // max number of drags that can happen concurrently\n *     // with elements of this Interactable. Infinity by default\n *     max: Infinity,\n *\n *     // max number of drags that can target the same element+Interactable\n *     // 1 by default\n *     maxPerElement: 2\n * });\n *\n * var isDraggable = interact('element').draggable(); // true\n * ```\n *\n * Get or set whether drag actions can be performed on the target\n *\n * @alias Interactable.prototype.draggable\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on drag events (object makes the Interactable\n * draggable)\n * @return {boolean | Interactable} boolean indicating if this can be the\n * target of drag events, or this Interctable\n */\nfunction draggable (this: Interact.Interactable, options?: Interact.DraggableOptions | boolean) {\n  if (is.object(options)) {\n    this.options.drag.enabled = options.enabled !== false\n    this.setPerAction('drag', options)\n    this.setOnEvents('drag', options)\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis\n    }\n\n    return this\n  }\n\n  if (is.bool(options)) {\n    this.options.drag.enabled = options\n\n    return this\n  }\n\n  return this.options.drag\n}\n\nconst drag = {\n  install,\n  draggable,\n  beforeMove,\n  move,\n  defaults: {\n    startAxis : 'xy',\n    lockAxis  : 'xy',\n  } as Interact.DropzoneOptions,\n\n  checker (_pointer, _event, interactable) {\n    const dragOptions = interactable.options.drag\n\n    return dragOptions.enabled\n      ? {\n        name: 'drag',\n        axis: (dragOptions.lockAxis === 'start'\n          ? dragOptions.startAxis\n          : dragOptions.lockAxis),\n      }\n      : null\n  },\n\n  getCursor () {\n    return 'move'\n  },\n}\n\nexport default drag\n","const domObjects: {\n  init: any,\n  document: Document,\n  DocumentFragment: typeof DocumentFragment,\n  SVGElement: typeof SVGElement,\n  SVGSVGElement: typeof SVGSVGElement,\n  SVGElementInstance: any,\n  Element: typeof Element,\n  HTMLElement: typeof HTMLElement,\n  Event: typeof Event,\n  Touch: typeof Touch,\n  PointerEvent: typeof PointerEvent,\n} =\n{\n  init,\n  document: null as any,\n  DocumentFragment: null as any,\n  SVGElement: null as any,\n  SVGSVGElement: null as any,\n  // eslint-disable-next-line no-undef\n  SVGElementInstance: null as any,\n  Element: null as any,\n  HTMLElement: null as any,\n  Event: null as any,\n  Touch: null as any,\n  PointerEvent: null as any,\n}\n\nfunction blank () {}\n\nexport default domObjects\n\nfunction init (window: Window) {\n  const win = window as any\n\n  domObjects.document           = win.document\n  domObjects.DocumentFragment   = win.DocumentFragment   || blank\n  domObjects.SVGElement         = win.SVGElement         || blank\n  domObjects.SVGSVGElement      = win.SVGSVGElement      || blank\n  domObjects.SVGElementInstance = win.SVGElementInstance || blank\n  domObjects.Element            = win.Element            || blank\n  domObjects.HTMLElement        = win.HTMLElement        || domObjects.Element\n\n  domObjects.Event        = win.Event\n  domObjects.Touch        = win.Touch || blank\n  domObjects.PointerEvent = (win.PointerEvent || win.MSPointerEvent)\n}\n","import domObjects from './domObjects'\nimport * as is from './is'\nimport win from './window'\n\nconst browser = {\n  init,\n  supportsTouch: null as boolean,\n  supportsPointerEvent: null as boolean,\n  isIOS7: null as boolean,\n  isIOS: null as boolean,\n  isIe9: null as boolean,\n  isOperaMobile: null as boolean,\n  prefixedMatchesSelector: null as string,\n  pEventTypes: null as {\n    up: string,\n    down: string,\n    over: string,\n    out: string,\n    move: string,\n    cancel: string,\n  },\n  wheelEvent: null as string,\n}\n\nfunction init (window) {\n  const Element = domObjects.Element as any\n  const navigator  = win.window.navigator\n\n  // Does the browser support touch input?\n  browser.supportsTouch = !!(('ontouchstart' in window) || is.func(window.DocumentTouch)) &&\n    domObjects.document instanceof window.DocumentTouch\n\n  // Does the browser support PointerEvents\n  browser.supportsPointerEvent = !!domObjects.PointerEvent\n\n  browser.isIOS = (/iP(hone|od|ad)/.test(navigator.platform))\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  browser.isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform) &&\n           /OS 7[^\\d]/.test(navigator.appVersion))\n\n  browser.isIe9 = /MSIE 9/.test(navigator.userAgent)\n\n  // Opera Mobile must be handled differently\n  browser.isOperaMobile = (navigator.appName === 'Opera' &&\n    browser.supportsTouch &&\n    navigator.userAgent.match('Presto'))\n\n  // prefix matchesSelector\n  browser.prefixedMatchesSelector = 'matches' in Element.prototype\n    ? 'matches'\n    : 'webkitMatchesSelector' in Element.prototype\n      ? 'webkitMatchesSelector'\n      : 'mozMatchesSelector' in Element.prototype\n        ? 'mozMatchesSelector'\n        : 'oMatchesSelector' in Element.prototype\n          ? 'oMatchesSelector'\n          : 'msMatchesSelector'\n\n  browser.pEventTypes = (domObjects.PointerEvent\n    ? (domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n        up:     'MSPointerUp',\n        down:   'MSPointerDown',\n        over:   'mouseover',\n        out:    'mouseout',\n        move:   'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up:     'pointerup',\n        down:   'pointerdown',\n        over:   'pointerover',\n        out:    'pointerout',\n        move:   'pointermove',\n        cancel: 'pointercancel',\n      })\n    : null)\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  browser.wheelEvent = 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n}\n\nexport default browser\n","import * as arr from './arr'\nimport * as is from './is'\n\nexport default function clone<T extends { [key: string]: any }> (source: T): Partial<T> {\n  const dest = {} as Partial<T>\n\n  for (const prop in source) {\n    const value = source[prop]\n\n    if (is.plainObject(value)) {\n      dest[prop] = clone(value) as any\n    }\n    else if (is.array(value)) {\n      dest[prop] = arr.from(value)\n    }\n    else {\n      dest[prop] = value\n    }\n  }\n\n  return dest\n}\n","import browser from './browser'\nimport domObjects from './domObjects'\nimport * as is from './is'\nimport win from './window'\n\nexport function nodeContains (parent, child) {\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = child.parentNode\n  }\n\n  return false\n}\n\nexport function closest (element, selector) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) { return element }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode (node) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector (element, selector) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement (elements) {\n  let deepestZoneParents = []\n  let dropzoneParents = []\n  let dropzone\n  let deepestZone = elements[0]\n  let index = deepestZone ? 0 : -1\n  let parent\n  let child\n  let i\n  let n\n\n  for (i = 1; i < elements.length; i++) {\n    dropzone = elements[i]\n\n    // an element might belong to multiple selector dropzones\n    if (!dropzone || dropzone === deepestZone) {\n      continue\n    }\n\n    if (!deepestZone) {\n      deepestZone = dropzone\n      index = i\n      continue\n    }\n\n    // check if the deepest or current are document.documentElement or document.rootElement\n    // - if the current dropzone is, do nothing and continue\n    if (dropzone.parentNode === dropzone.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current dropzone and continue to next\n    else if (deepestZone.parentNode === dropzone.ownerDocument) {\n      deepestZone = dropzone\n      index = i\n      continue\n    }\n\n    if (!deepestZoneParents.length) {\n      parent = deepestZone\n      while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n        deepestZoneParents.unshift(parent)\n        parent = parent.parentNode\n      }\n    }\n\n    // if this element is an svg element and the current deepest is\n    // an HTMLElement\n    if (deepestZone instanceof domObjects.HTMLElement &&\n        dropzone instanceof domObjects.SVGElement &&\n        !(dropzone instanceof domObjects.SVGSVGElement)) {\n      if (dropzone === deepestZone.parentNode) {\n        continue\n      }\n\n      parent = dropzone.ownerSVGElement\n    }\n    else {\n      parent = dropzone\n    }\n\n    dropzoneParents = []\n\n    while (parent.parentNode !== parent.ownerDocument) {\n      dropzoneParents.unshift(parent)\n      parent = parent.parentNode\n    }\n\n    n = 0\n\n    // get (position of last common ancestor) + 1\n    while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n      n++\n    }\n\n    const parents = [\n      dropzoneParents[n - 1],\n      dropzoneParents[n],\n      deepestZoneParents[n],\n    ]\n\n    child = parents[0].lastChild\n\n    while (child) {\n      if (child === parents[1]) {\n        deepestZone = dropzone\n        index = i\n        deepestZoneParents = []\n\n        break\n      }\n      else if (child === parents[2]) {\n        break\n      }\n\n      child = child.previousSibling\n    }\n  }\n\n  return index\n}\n\nexport function matchesUpTo (element, selector, limit) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element)\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement (element) {\n  return (element instanceof domObjects.SVGElementInstance\n    ? element.correspondingUseElement\n    : element)\n}\n\nexport function getScrollXY (relevantWindow) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect (element) {\n  const clientRect = (element instanceof domObjects.SVGElement\n    ? element.getBoundingClientRect()\n    : element.getClientRects()[0])\n\n  return clientRect && {\n    left  : clientRect.left,\n    right : clientRect.right,\n    top   : clientRect.top,\n    bottom: clientRect.bottom,\n    width : clientRect.width  || clientRect.right  - clientRect.left,\n    height: clientRect.height || clientRect.bottom - clientRect.top,\n  }\n}\n\nexport function getElementRect (element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left   += scroll.x\n    clientRect.right  += scroll.x\n    clientRect.top    += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath (element) {\n  const path = []\n\n  while (element) {\n    path.push(element)\n    element = parentNode(element)\n  }\n\n  return path\n}\n\nexport function trySelector (value) {\n  if (!is.string(value)) { return false }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n","export interface PointerExtend {\n  webkit: RegExp\n  [prefix: string]: RegExp\n}\n\nexport function pointerExtend<PointerExtend> (dest, source) {\n  for (const prop in source) {\n    const prefixedPropREs = pointerExtend.prefixedPropREs\n    let deprecated = false\n\n    // skip deprecated prefixed properties\n    for (const vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n        deprecated = true\n        break\n      }\n    }\n\n    if (!deprecated && typeof source[prop] !== 'function') {\n      dest[prop] = source[prop]\n    }\n  }\n  return dest\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n}\n\nexport default pointerExtend\n","import { contains } from './arr'\nimport * as domUtils from './domUtils'\nimport * as is from './is'\nimport pExtend from './pointerExtend'\nimport pointerUtils from './pointerUtils'\n\ntype Listener = (event: Event | FakeEvent) => any\n\nconst elements: EventTarget[] = []\nconst targets: Array<{\n  events: { [type: string]: Listener[] },\n  typeCount: number,\n}> = []\n\nconst delegatedEvents: {\n  [type: string]: {\n    selectors: string[],\n    contexts: EventTarget[],\n    listeners: Array<Array<[Listener, boolean, boolean]>>,\n  },\n} = {}\nconst documents: Document[] = []\n\nfunction add (element: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\n  const options = getOptions(optionalArg)\n  let elementIndex = elements.indexOf(element)\n  let target = targets[elementIndex]\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0,\n    }\n\n    elementIndex = elements.push(element) - 1\n    targets.push(target)\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = []\n    target.typeCount++\n  }\n\n  if (!contains(target.events[type], listener)) {\n    element.addEventListener(type, listener as any, events.supportsOptions ? options : !!options.capture)\n    target.events[type].push(listener)\n  }\n}\n\nfunction remove (element: EventTarget, type: string, listener?: 'all' | Listener, optionalArg?: boolean | any) {\n  const options = getOptions(optionalArg)\n  const elementIndex = elements.indexOf(element)\n  const target = targets[elementIndex]\n\n  if (!target || !target.events) {\n    return\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all')\n      }\n    }\n    return\n  }\n\n  if (target.events[type]) {\n    const len = target.events[type].length\n\n    if (listener === 'all') {\n      for (let i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], options)\n      }\n      return\n    }\n    else {\n      for (let i = 0; i < len; i++) {\n        if (target.events[type][i] === listener) {\n          element.removeEventListener(type, listener as any, events.supportsOptions ? options : !!options.capture)\n          target.events[type].splice(i, 1)\n\n          break\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      (target.events[type] as any) = null\n      target.typeCount--\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1)\n    elements.splice(elementIndex, 1)\n  }\n}\n\nfunction addDelegate (selector: string, context: EventTarget, type: string, listener: Listener, optionalArg?: any) {\n  const options = getOptions(optionalArg)\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      contexts : [],\n      listeners: [],\n      selectors: [],\n    }\n\n    // add delegate listener functions\n    for (const doc of documents) {\n      add(doc, type, delegateListener)\n      add(doc, type, delegateUseCapture, true)\n    }\n  }\n\n  const delegated = delegatedEvents[type]\n  let index\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector &&\n        delegated.contexts[index] === context) {\n      break\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length\n\n    delegated.selectors.push(selector)\n    delegated.contexts.push(context)\n    delegated.listeners.push([])\n  }\n\n  // keep listener and capture and passive flags\n  delegated.listeners[index].push([listener, !!options.capture, options.passive])\n}\n\nfunction removeDelegate (selector, context, type, listener?, optionalArg?: any) {\n  const options = getOptions(optionalArg)\n  const delegated = delegatedEvents[type]\n  let matchFound = false\n  let index\n\n  if (!delegated) { return }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector &&\n        delegated.contexts[index] === context) {\n      const listeners = delegated.listeners[index]\n\n      // each item of the listeners array is an array: [function, capture, passive]\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        const [fn, capture, passive] = listeners[i]\n\n        // check if the listener functions and capture and passive flags match\n        if (fn === listener && capture === !!options.capture && passive === options.passive) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1)\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1)\n            delegated.contexts.splice(index, 1)\n            delegated.listeners.splice(index, 1)\n\n            // remove delegate function from context\n            remove(context, type, delegateListener)\n            remove(context, type, delegateUseCapture, true)\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null\n            }\n          }\n\n          // only remove one listener\n          matchFound = true\n          break\n        }\n      }\n\n      if (matchFound) { break }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener (event: Event, optionalArg?: any) {\n  const options = getOptions(optionalArg)\n  const fakeEvent = new FakeEvent(event)\n  const delegated = delegatedEvents[event.type]\n  const [eventTarget] = (pointerUtils.getEventTargets(event))\n  let element = eventTarget\n\n  // climb up document tree looking for selector matches\n  while (is.element(element)) {\n    for (let i = 0; i < delegated.selectors.length; i++) {\n      const selector = delegated.selectors[i]\n      const context = delegated.contexts[i]\n\n      if (domUtils.matchesSelector(element, selector) &&\n          domUtils.nodeContains(context, eventTarget) &&\n          domUtils.nodeContains(context, element)) {\n        const listeners = delegated.listeners[i]\n\n        fakeEvent.currentTarget = element\n\n        for (const [fn, capture, passive] of listeners) {\n          if (capture === !!options.capture && passive === options.passive) {\n            fn(fakeEvent)\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentNode(element)\n  }\n}\n\nfunction delegateUseCapture (event: Event) {\n  return delegateListener.call(this, event, true)\n}\n\nfunction getOptions (param) {\n  return is.object(param) ? param : { capture: param }\n}\n\nexport class FakeEvent implements Partial<Event> {\n  currentTarget: EventTarget\n\n  constructor (public originalEvent) {\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation () {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation () {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nconst events = {\n  add,\n  remove,\n\n  addDelegate,\n  removeDelegate,\n\n  delegateListener,\n  delegateUseCapture,\n  delegatedEvents,\n  documents,\n\n  supportsOptions: false,\n  supportsPassive: false,\n\n  _elements: elements,\n  _targets: targets,\n\n  init (window: Window) {\n    window.document.createElement('div').addEventListener('test', null, {\n      get capture () { return (events.supportsOptions = true) },\n      get passive () { return (events.supportsPassive = true) },\n    })\n  },\n}\n\nexport default events\n","export default function extend<T, U extends Partial<T>> (dest: U, source: T) {\n  for (const prop in source) {\n    dest[prop] = source[prop]\n  }\n  return dest as T & U\n}\n","import { closest, getElementRect, parentNode } from './domUtils'\nimport extend from './extend'\nimport * as is from './is'\n\nexport function getStringOptionResult (value, interactable, element) {\n  if (!is.string(value)) {\n    return null\n  }\n\n  if (value === 'parent') {\n    value = parentNode(element)\n  }\n  else if (value === 'self') {\n    value = interactable.getRect(element)\n  }\n  else {\n    value = closest(element, value)\n  }\n\n  return value\n}\n\nexport function resolveRectLike (value, interactable?, element?, functionArgs?) {\n  value = getStringOptionResult(value, interactable, element) || value\n\n  if (is.func(value)) {\n    value = value.apply(null, functionArgs)\n  }\n\n  if (is.element(value)) {\n    value = getElementRect(value)\n  }\n\n  return value\n}\n\nexport function rectToXY (rect) {\n  return  rect && {\n    x: 'x' in rect ? rect.x : rect.left,\n    y: 'y' in rect ? rect.y : rect.top,\n  }\n}\n\nexport function xywhToTlbr (rect) {\n  if (rect && !('left' in rect && 'top' in rect)) {\n    rect = extend({}, rect)\n\n    rect.left   = rect.x || 0\n    rect.top    = rect.y || 0\n    rect.right  = rect.right   || (rect.left + rect.width)\n    rect.bottom = rect.bottom  || (rect.top + rect.height)\n  }\n\n  return rect\n}\n\nexport function tlbrToXywh (rect) {\n  if (rect && !('x' in rect && 'y' in rect)) {\n    rect = extend({}, rect)\n\n    rect.x      = rect.left || 0\n    rect.y      = rect.top  || 0\n    rect.width  = rect.width  || (rect.right  - rect.x)\n    rect.height = rect.height || (rect.bottom - rect.y)\n  }\n\n  return rect\n}\n\nexport default {\n  getStringOptionResult,\n  resolveRectLike,\n  rectToXY,\n  xywhToTlbr,\n  tlbrToXywh,\n}\n","import { rectToXY, resolveRectLike } from './rect'\n\nexport default function (target, element, action?) {\n  const actionOptions = target.options[action]\n  const actionOrigin = actionOptions && actionOptions.origin\n  const origin = actionOrigin || target.options.origin\n\n  const originRect = resolveRectLike(origin, target, element, [target && element])\n\n  return rectToXY(originRect) || { x: 0, y: 0 }\n}\n","import extend from './extend'\nimport * as is from './is'\n\nexport interface NormalizedListeners {\n  [type: string]: Interact.Listener[]\n}\n\nexport default function normalize (\n  type: Interact.EventTypes,\n  listeners?: Interact.ListenersArg | Interact.ListenersArg[],\n  result?: NormalizedListeners,\n): NormalizedListeners {\n  result = result || {}\n\n  if (is.string(type) && type.search(' ') !== -1) {\n    type = split(type)\n  }\n\n  if (is.array(type)) {\n    return type.reduce<NormalizedListeners>(\n      (acc, t) => extend(acc, normalize(t, listeners, result)),\n      result\n    )\n  }\n\n  // ({ type: fn }) -> ('', { type: fn })\n  if (is.object(type)) {\n    listeners = type\n    type = ''\n  }\n\n  if (is.func(listeners)) {\n    result[type] = result[type] || []\n    result[type].push(listeners)\n  }\n  else if (is.array(listeners)) {\n    for (const l of listeners) {\n      normalize(type, l, result)\n    }\n  }\n  else if (is.object(listeners)) {\n    for (const prefix in listeners) {\n      const combinedTypes = split(prefix).map((p) => `${type}${p}`)\n\n      normalize(combinedTypes, listeners[prefix], result)\n    }\n  }\n\n  return result as NormalizedListeners\n}\n\nfunction split (type: string) {\n  return type.trim().split(/ +/)\n}\n","let lastTime = 0\nlet request\nlet cancel\n\nfunction init (window) {\n  request = window.requestAnimationFrame\n  cancel = window.cancelAnimationFrame\n\n  if (!request) {\n    const vendors = ['ms', 'moz', 'webkit', 'o']\n\n    for (const vendor of vendors) {\n      request = window[`${vendor}RequestAnimationFrame`]\n      cancel = window[`${vendor}CancelAnimationFrame`] || window[`${vendor}CancelRequestAnimationFrame`]\n    }\n  }\n\n  if (!request) {\n    request = (callback) => {\n      const currTime = new Date().getTime()\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime))\n      // eslint-disable-next-line standard/no-callback-literal\n      const token = setTimeout(() => { callback(currTime + timeToCall) },\n        timeToCall)\n\n      lastTime = currTime + timeToCall\n      return token\n    }\n\n    cancel = (token) => clearTimeout(token)\n  }\n}\n\nexport default {\n  request: (callback) => request(callback),\n  cancel: (token) => cancel(token),\n  init,\n}\n","import * as arr from './arr'\nimport * as dom from './domUtils'\nimport * as is from './is'\nimport win from './window'\n\nexport function warnOnce<T> (this: T, method: (...args: any) => any, message: string) {\n  let warned = false\n\n  // eslint-disable-next-line no-shadow\n  return function (this: T) {\n    if (!warned) {\n      (win as any).window.console.warn(message)\n      warned = true\n    }\n\n    return method.apply(this, arguments)\n  }\n}\n\n// http://stackoverflow.com/a/5634528/2280888\nexport function _getQBezierValue (t: number, p1: number, p2: number, p3: number) {\n  const iT = 1 - t\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3\n}\n\nexport function getQuadraticCurvePoint (\n  startX: number, startY: number, cpX: number, cpY: number, endX: number, endY: number, position: number) {\n  return {\n    x:  _getQBezierValue(position, startX, cpX, endX),\n    y:  _getQBezierValue(position, startY, cpY, endY),\n  }\n}\n\n// http://gizma.com/easing/\nexport function easeOutQuad (t: number, b: number, c: number, d: number) {\n  t /= d\n  return -c * t * (t - 2) + b\n}\n\nexport function copyAction (dest: any, src: any) {\n  dest.name  = src.name\n  dest.axis  = src.axis\n  dest.edges = src.edges\n\n  return dest\n}\n\nexport { default as browser } from './browser'\nexport { default as clone } from './clone'\nexport { default as events } from './events'\nexport { default as extend } from './extend'\nexport { default as getOriginXY } from './getOriginXY'\nexport { default as hypot } from './hypot'\nexport { default as normalizeListeners } from './normalizeListeners'\nexport { default as pointer } from './pointerUtils'\nexport { default as raf } from './raf'\nexport { default as rect } from './rect'\nexport { default as Signals } from './Signals'\nexport { win, arr, dom, is }\n","import InteractEvent from '@interactjs/core/InteractEvent'\nimport { Scope } from '@interactjs/core/scope'\nimport * as utils from '@interactjs/utils'\nimport DropEvent from './DropEvent'\n\nexport type DropzoneMethod = (options?: Interact.DropzoneOptions | boolean) => Interact.Interactable | Interact.DropzoneOptions\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    dropzone: DropzoneMethod\n    dropCheck: (\n      dragEvent: InteractEvent,\n      event: Interact.PointerEventType,\n      draggable: Interactable,\n      draggableElement: Element,\n      dropElemen: Element,\n      rect: any\n    ) => boolean\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    dropStatus?: { [key: string]: any }\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    drop?: Interact.DropzoneOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    dynamicDrop?: boolean\n  }\n}\n\ndeclare module '@interactjs/interact/interact' {\n  interface InteractStatic {\n    dynamicDrop: (newValue?: boolean) => boolean | Interact.interact\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    /** @lends module:interact */\n    interact,\n    /** @lends Interactable */\n    Interactable,\n    interactions,\n    defaults,\n  } = scope\n\n  interactions.signals.on('after-action-start', ({ interaction, event, iEvent: dragEvent }) => {\n    if (interaction.prepared.name !== 'drag') { return }\n\n    const { dropStatus } = interaction\n\n    // reset active dropzones\n    dropStatus.activeDrops = null\n    dropStatus.events = null\n\n    if (!scope.dynamicDrop) {\n      dropStatus.activeDrops = getActiveDrops(scope, interaction.element)\n    }\n\n    dropStatus.events = getDropEvents(interaction, event, dragEvent)\n\n    if (dropStatus.events.activate) {\n      fireActivationEvents(dropStatus.activeDrops, dropStatus.events.activate)\n    }\n  })\n\n  interactions.signals.on('action-move', (arg) => onEventCreated(arg, scope))\n  interactions.signals.on('action-end', (arg) => onEventCreated(arg, scope))\n\n  interactions.signals.on('after-action-move', ({ interaction }) => {\n    if (interaction.prepared.name !== 'drag') { return }\n\n    fireDropEvents(interaction, interaction.dropStatus.events)\n    interaction.dropStatus.events = {}\n  })\n\n  interactions.signals.on('after-action-end', ({ interaction }) => {\n    if (interaction.prepared.name === 'drag') {\n      fireDropEvents(interaction, interaction.dropStatus.events)\n    }\n  })\n\n  interactions.signals.on('stop', ({ interaction }) => {\n    interaction.dropStatus.activeDrops = null\n    interaction.dropStatus.events = null\n  })\n\n  interactions.signals.on('new', (interaction) => {\n    interaction.dropStatus = {\n      cur: {\n        dropzone : null,  // the dropzone a drag target might be dropped into\n        element  : null,  // the element at the time of checking\n      },\n      prev: {\n        dropzone : null,  // the dropzone that was recently dragged away from\n        element  : null,  // the element at the time of checking\n      },\n      rejected   : false, // wheather the potential drop was rejected from a listener\n      events     : null,  // the drop events related to the current drag event\n      activeDrops: null,  // an array of { dropzone, element, rect }\n    }\n  })\n\n  interactions.signals.on('stop', ({ interaction: { dropStatus } }) => {\n    dropStatus.cur.dropzone = dropStatus.cur.element =\n      dropStatus.prev.dropzone = dropStatus.prev.element = null\n    dropStatus.rejected = false\n  })\n\n  /**\n   *\n   * ```js\n   * interact('.drop').dropzone({\n   *   accept: '.can-drop' || document.getElementById('single-drop'),\n   *   overlap: 'pointer' || 'center' || zeroToOne\n   * }\n   * ```\n   *\n   * Returns or sets whether draggables can be dropped onto this target to\n   * trigger drop events\n   *\n   * Dropzones can receive the following events:\n   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n   *  - `dragmove` when a draggable that has entered the dropzone is moved\n   *  - `drop` when a draggable is dropped into this dropzone\n   *\n   * Use the `accept` option to allow only elements that match the given CSS\n   * selector or element. The value can be:\n   *\n   *  - **an Element** - only that element can be dropped into this dropzone.\n   *  - **a string**, - the element being dragged must match it as a CSS selector.\n   *  - **`null`** - accept options is cleared - it accepts any element.\n   *\n   * Use the `overlap` option to set how drops are checked for. The allowed\n   * values are:\n   *\n   *   - `'pointer'`, the pointer must be over the dropzone (default)\n   *   - `'center'`, the draggable element's center must be over the dropzone\n   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n   *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n   *   over the dropzone\n   *\n   * Use the `checker` option to specify a function to check if a dragged element\n   * is over this Interactable.\n   *\n   * @param {boolean | object | null} [options] The new options to be set.\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.dropzone = function (this: Interact.Interactable, options) {\n    return dropzoneMethod(this, options)\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n   *                       event,             // TouchEvent/PointerEvent/MouseEvent\n   *                       dropped,           // bool result of the default checker\n   *                       dropzone,          // dropzone Interactable\n   *                       dropElement,       // dropzone elemnt\n   *                       draggable,         // draggable Interactable\n   *                       draggableElement) {// draggable element\n   *\n   *   return dropped && event.target.hasAttribute('allow-drop');\n   * }\n   * ```\n   */\n  Interactable.prototype.dropCheck = function (this: Interact.Interactable, dragEvent, event, draggable, draggableElement, dropElement, rect) {\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\n  }\n\n  /**\n   * Returns or sets whether the dimensions of dropzone elements are calculated\n   * on every dragmove or only on dragstart for the default dropChecker\n   *\n   * @param {boolean} [newValue] True to check on each move. False to check only\n   * before start\n   * @return {boolean | interact} The current setting or interact\n   */\n  interact.dynamicDrop = function (newValue?: boolean) {\n    if (utils.is.bool(newValue)) {\n      // if (dragging && scope.dynamicDrop !== newValue && !newValue) {\n      //  calcRects(dropzones);\n      // }\n\n      scope.dynamicDrop = newValue\n\n      return interact\n    }\n    return scope.dynamicDrop\n  }\n\n  utils.arr.merge(actions.eventTypes, [\n    'dragenter',\n    'dragleave',\n    'dropactivate',\n    'dropdeactivate',\n    'dropmove',\n    'drop',\n  ])\n  actions.methodDict.drop = 'dropzone'\n\n  scope.dynamicDrop = false\n\n  defaults.actions.drop = drop.defaults\n}\n\nfunction collectDrops ({ interactables }, draggableElement) {\n  const drops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const dropzone of interactables.list) {\n    if (!dropzone.options.drop.enabled) { continue }\n\n    const accept = dropzone.options.drop.accept\n\n    // test the draggable draggableElement against the dropzone's accept setting\n    if ((utils.is.element(accept) && accept !== draggableElement) ||\n        (utils.is.string(accept) &&\n        !utils.dom.matchesSelector(draggableElement, accept)) ||\n        (utils.is.func(accept) && !accept({ dropzone, draggableElement }))) {\n      continue\n    }\n\n    // query for new elements if necessary\n    const dropElements = utils.is.string(dropzone.target)\n      ? dropzone._context.querySelectorAll(dropzone.target)\n      : utils.is.array(dropzone.target) ? dropzone.target : [dropzone.target]\n\n    for (const dropzoneElement of dropElements) {\n      if (dropzoneElement !== draggableElement) {\n        drops.push({\n          dropzone,\n          element: dropzoneElement,\n        })\n      }\n    }\n  }\n\n  return drops\n}\n\nfunction fireActivationEvents (activeDrops, event) {\n  // loop through all active dropzones and trigger event\n  for (const { dropzone, element } of activeDrops) {\n    event.dropzone = dropzone\n\n    // set current element as event target\n    event.target = element\n    dropzone.fire(event)\n    event.propagationStopped = event.immediatePropagationStopped = false\n  }\n}\n\n// return a new array of possible drops. getActiveDrops should always be\n// called when a drag has just started or a drag event happens while\n// dynamicDrop is true\nfunction getActiveDrops (scope: Scope, dragElement: Element) {\n  // get dropzones and their elements that could receive the draggable\n  const activeDrops = collectDrops(scope, dragElement)\n\n  for (const activeDrop of activeDrops) {\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\n  }\n\n  return activeDrops\n}\n\nfunction getDrop ({ dropStatus, target: draggable, element: dragElement }, dragEvent, pointerEvent) {\n  const validDrops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const { dropzone, element: dropzoneElement, rect } of dropStatus.activeDrops) {\n    validDrops.push(dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)\n      ? dropzoneElement\n      : null)\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = utils.dom.indexOfDeepestElement(validDrops)\n\n  return dropStatus.activeDrops[dropIndex] || null\n}\n\nfunction getDropEvents (interaction, _pointerEvent, dragEvent) {\n  const { dropStatus } = interaction\n  const dropEvents = {\n    enter     : null,\n    leave     : null,\n    activate  : null,\n    deactivate: null,\n    move      : null,\n    drop      : null,\n  }\n\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = new DropEvent(dropStatus, dragEvent, 'dropactivate')\n\n    dropEvents.activate.target   = null\n    dropEvents.activate.dropzone = null\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = new DropEvent(dropStatus, dragEvent, 'dropdeactivate')\n\n    dropEvents.deactivate.target   = null\n    dropEvents.deactivate.dropzone = null\n  }\n\n  if (dropStatus.rejected) {\n    return dropEvents\n  }\n\n  if (dropStatus.cur.element !== dropStatus.prev.element) {\n    // if there was a previous dropzone, create a dragleave event\n    if (dropStatus.prev.dropzone) {\n      dropEvents.leave = new DropEvent(dropStatus, dragEvent, 'dragleave')\n\n      dragEvent.dragLeave    = dropEvents.leave.target   = dropStatus.prev.element\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropStatus.prev.dropzone\n    }\n    // if dropzone is not null, create a dragenter event\n    if (dropStatus.cur.dropzone) {\n      dropEvents.enter = new DropEvent(dropStatus, dragEvent, 'dragenter')\n\n      dragEvent.dragEnter = dropStatus.cur.element\n      dragEvent.dropzone = dropStatus.cur.dropzone\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && dropStatus.cur.dropzone) {\n    dropEvents.drop = new DropEvent(dropStatus, dragEvent, 'drop')\n\n    dragEvent.dropzone = dropStatus.cur.dropzone\n    dragEvent.relatedTarget = dropStatus.cur.element\n  }\n  if (dragEvent.type === 'dragmove' && dropStatus.cur.dropzone) {\n    dropEvents.move = new DropEvent(dropStatus, dragEvent, 'dropmove')\n\n    dropEvents.move.dragmove = dragEvent\n    dragEvent.dropzone = dropStatus.cur.dropzone\n  }\n\n  return dropEvents\n}\n\nfunction fireDropEvents (interaction, events) {\n  const { dropStatus } = interaction\n  const {\n    activeDrops,\n    cur,\n    prev,\n  } = dropStatus\n\n  if (events.leave) { prev.dropzone.fire(events.leave) }\n  if (events.move) { cur.dropzone.fire(events.move) }\n  if (events.enter) { cur.dropzone.fire(events.enter) }\n  if (events.drop) { cur.dropzone.fire(events.drop) }\n\n  if (events.deactivate) {\n    fireActivationEvents(activeDrops, events.deactivate)\n  }\n\n  dropStatus.prev.dropzone  = cur.dropzone\n  dropStatus.prev.element = cur.element\n}\n\nfunction onEventCreated ({ interaction, iEvent, event }, scope) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') { return }\n\n  const { dropStatus } = interaction\n\n  if (scope.dynamicDrop) {\n    dropStatus.activeDrops = getActiveDrops(scope, interaction.element)\n  }\n\n  const dragEvent = iEvent\n  const dropResult = getDrop(interaction, dragEvent, event)\n\n  // update rejected status\n  dropStatus.rejected = dropStatus.rejected &&\n    !!dropResult &&\n    dropResult.dropzone === dropStatus.cur.dropzone &&\n    dropResult.element === dropStatus.cur.element\n\n  dropStatus.cur.dropzone  = dropResult && dropResult.dropzone\n  dropStatus.cur.element = dropResult && dropResult.element\n\n  dropStatus.events = getDropEvents(interaction, event, dragEvent)\n}\n\nfunction dropzoneMethod (interactable: Interact.Interactable, options: Interact.DropzoneOptions | boolean) {\n  if (utils.is.object(options)) {\n    interactable.options.drop.enabled = options.enabled !== false\n\n    if (options.listeners) {\n      const normalized = utils.normalizeListeners(options.listeners)\n      // rename 'drop' to '' as it will be prefixed with 'drop'\n      const corrected = Object.keys(normalized).reduce((acc, type) => {\n        const correctedType = /^(enter|leave)/.test(type)\n          ? `drag${type}`\n          : /^(activate|deactivate|move)/.test(type)\n            ? `drop${type}`\n            : type\n\n        acc[correctedType] = normalized[type]\n\n        return acc\n      }, {})\n\n      interactable.off(interactable.options.drop.listeners)\n      interactable.on(corrected)\n      interactable.options.drop.listeners = corrected\n    }\n\n    if (utils.is.func(options.ondrop)) { interactable.on('drop', options.ondrop) }\n    if (utils.is.func(options.ondropactivate)) { interactable.on('dropactivate', options.ondropactivate) }\n    if (utils.is.func(options.ondropdeactivate)) { interactable.on('dropdeactivate', options.ondropdeactivate) }\n    if (utils.is.func(options.ondragenter)) { interactable.on('dragenter', options.ondragenter) }\n    if (utils.is.func(options.ondragleave)) { interactable.on('dragleave', options.ondragleave) }\n    if (utils.is.func(options.ondropmove)) { interactable.on('dropmove', options.ondropmove) }\n\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\n      interactable.options.drop.overlap = options.overlap\n    }\n    else if (utils.is.number(options.overlap)) {\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\n    }\n    if ('accept' in options) {\n      interactable.options.drop.accept = options.accept\n    }\n    if ('checker' in options) {\n      interactable.options.drop.checker = options.checker\n    }\n\n    return interactable\n  }\n\n  if (utils.is.bool(options)) {\n    interactable.options.drop.enabled = options\n\n    return interactable\n  }\n\n  return interactable.options.drop\n}\n\nfunction dropCheckMethod (\n  interactable: Interact.Interactable,\n  dragEvent: InteractEvent,\n  event: Interact.PointerEventType,\n  draggable: Interact.Interactable,\n  draggableElement: Element,\n  dropElement: Element,\n  rect: any\n) {\n  let dropped = false\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || interactable.getRect(dropElement))) {\n    return (interactable.options.drop.checker\n      ? interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement)\n      : false)\n  }\n\n  const dropOverlap = interactable.options.drop.overlap\n\n  if (dropOverlap === 'pointer') {\n    const origin = utils.getOriginXY(draggable, draggableElement, 'drag')\n    const page = utils.pointer.getPageXY(dragEvent)\n\n    page.x += origin.x\n    page.y += origin.y\n\n    const horizontal = (page.x > rect.left) && (page.x < rect.right)\n    const vertical   = (page.y > rect.top) && (page.y < rect.bottom)\n\n    dropped = horizontal && vertical\n  }\n\n  const dragRect = draggable.getRect(draggableElement)\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width  / 2\n    const cy = dragRect.top  + dragRect.height / 2\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom\n  }\n\n  if (dragRect && utils.is.number(dropOverlap)) {\n    const overlapArea  = (Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\n                          Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top)))\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\n\n    dropped = overlapRatio >= dropOverlap\n  }\n\n  if (interactable.options.drop.checker) {\n    dropped = interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement)\n  }\n\n  return dropped\n}\n\nconst drop = {\n  install,\n  getActiveDrops,\n  getDrop,\n  getDropEvents,\n  fireDropEvents,\n  defaults: {\n    enabled: false,\n    accept : null,\n    overlap: 'pointer',\n  } as Interact.DropzoneOptions,\n}\n\nexport default drop\n","import InteractEvent from '@interactjs/core/InteractEvent'\nimport { Scope } from '@interactjs/core/scope'\nimport * as utils from '@interactjs/utils'\n\nexport type GesturableMethod = (options?: Interact.GesturableOptions | boolean) => Interact.Interactable | Interact.GesturableOptions\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    Interactable,\n    interactions,\n    defaults,\n  } = scope\n\n  /**\n   * ```js\n   * interact(element).gesturable({\n   *     onstart: function (event) {},\n   *     onmove : function (event) {},\n   *     onend  : function (event) {},\n   *\n   *     // limit multiple gestures.\n   *     // See the explanation in {@link Interactable.draggable} example\n   *     max: Infinity,\n   *     maxPerElement: 1,\n   * });\n   *\n   * var isGestureable = interact(element).gesturable();\n   * ```\n   *\n   * Gets or sets whether multitouch gestures can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of gesture events, or this Interactable\n   */\n  Interactable.prototype.gesturable = function (this: Interact.Interactable, options: Interact.GesturableOptions | boolean) {\n    if (utils.is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction('gesture', options)\n      this.setOnEvents('gesture', options)\n\n      return this\n    }\n\n    if (utils.is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as Interact.Options\n  }\n\n  interactions.signals.on('action-start', updateGestureProps)\n  interactions.signals.on('action-move', updateGestureProps)\n  interactions.signals.on('action-end', updateGestureProps)\n\n  interactions.signals.on('action-start', start)\n  interactions.signals.on('action-move', move)\n\n  interactions.signals.on('new', (interaction) => {\n    interaction.gesture = {\n      start: { x: 0, y: 0 },\n\n      startDistance: 0,   // distance between two touches of touchStart\n      prevDistance : 0,\n      distance     : 0,\n\n      scale: 1,           // gesture.distance / gesture.startDistance\n\n      startAngle: 0,      // angle of line joining two touches\n      prevAngle : 0,      // angle of the previous gesture event\n    }\n  })\n\n  actions.gesture = gesture\n  actions.names.push('gesture')\n  utils.arr.merge(actions.eventTypes, [\n    'gesturestart',\n    'gesturemove',\n    'gestureend',\n  ])\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nconst gesture = {\n  install,\n  defaults: {\n  },\n\n  checker (_pointer, _event, _interactable, _element, interaction: { pointers: { length: number; }; }) {\n    if (interaction.pointers.length >= 2) {\n      return { name: 'gesture' }\n    }\n\n    return null\n  },\n\n  getCursor () {\n    return ''\n  },\n}\n\nfunction start ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'gesture') { return }\n\n  iEvent.ds = 0\n\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = iEvent.distance\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = iEvent.angle\n  interaction.gesture.scale = 1\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'gesture') { return }\n\n  iEvent.ds = iEvent.scale - interaction.gesture.scale\n\n  interaction.target.fire(iEvent)\n\n  interaction.gesture.prevAngle = iEvent.angle\n  interaction.gesture.prevDistance = iEvent.distance\n\n  if (iEvent.scale !== Infinity &&\n      iEvent.scale !== null &&\n      iEvent.scale !== undefined &&\n      !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nfunction updateGestureProps ({ interaction, iEvent, event, phase }) {\n  if (interaction.prepared.name !== 'gesture') { return }\n\n  const pointers = interaction.pointers.map((p) => p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.target.options.deltaSource\n\n  iEvent.touches = [pointers[0].pointer, pointers[1].pointer]\n\n  if (starting) {\n    iEvent.distance = utils.pointer.touchDistance(pointers, deltaSource)\n    iEvent.box      = utils.pointer.touchBBox(pointers)\n    iEvent.scale    = 1\n    iEvent.ds       = 0\n    iEvent.angle    = utils.pointer.touchAngle(pointers, deltaSource)\n    iEvent.da       = 0\n  }\n  else if (ending || event instanceof InteractEvent) {\n    iEvent.distance = interaction.prevEvent.distance\n    iEvent.box      = interaction.prevEvent.box\n    iEvent.scale    = interaction.prevEvent.scale\n    iEvent.ds       = iEvent.scale - 1\n    iEvent.angle    = interaction.prevEvent.angle\n    iEvent.da       = iEvent.angle - interaction.gesture.startAngle\n  }\n  else {\n    iEvent.distance = utils.pointer.touchDistance(pointers, deltaSource)\n    iEvent.box      = utils.pointer.touchBBox(pointers)\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle    = utils.pointer.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle\n  }\n}\n\nexport default gesture\n","import { Action, Interaction } from '@interactjs/core/Interaction'\nimport { Scope } from '@interactjs/core/scope'\nimport * as utils from '@interactjs/utils'\n\nexport type EdgeName = 'top' | 'left' | 'bottom' | 'right'\nexport type ResizableMethod = (options?: Interact.OrBoolean<Interact.ResizableOptions> | boolean) => Interact.Interactable | Interact.ResizableOptions\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    browser,\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n    interactions,\n    defaults,\n  } = scope\n\n  // Less Precision with touch input\n\n  interactions.signals.on('new', (interaction: Interaction) => {\n    interaction.resizeAxes = 'xy'\n  })\n\n  interactions.signals.on('action-start', start)\n  interactions.signals.on('action-move', move)\n\n  interactions.signals.on('action-start', updateEventAxes)\n  interactions.signals.on('action-move', updateEventAxes)\n\n  resize.cursors = initCursors(browser)\n  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10\n\n  /**\n   * ```js\n   * interact(element).resizable({\n   *   onstart: function (event) {},\n   *   onmove : function (event) {},\n   *   onend  : function (event) {},\n   *\n   *   edges: {\n   *     top   : true,       // Use pointer coords to check for resize.\n   *     left  : false,      // Disable resizing from left edge.\n   *     bottom: '.resize-s',// Resize if pointer target matches selector\n   *     right : handleEl    // Resize if pointer target is the given Element\n   *   },\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height are adjusted at a 1:1 ratio.\n   *     square: false,\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height maintain the aspect ratio they had when resizing started.\n   *     preserveAspectRatio: false,\n   *\n   *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   *   // 'negate' will allow the rect to have negative width/height\n   *   // 'reposition' will keep the width/height positive by swapping\n   *   // the top and bottom edges and/or swapping the left and right edges\n   *   invert: 'none' || 'negate' || 'reposition'\n   *\n   *   // limit multiple resizes.\n   *   // See the explanation in the {@link Interactable.draggable} example\n   *   max: Infinity,\n   *   maxPerElement: 1,\n   * });\n   *\n   * var isResizeable = interact(element).resizable();\n   * ```\n   *\n   * Gets or sets whether resize actions can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on resize events (object makes the Interactable\n   * resizable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of resize elements, or this Interactable\n   */\n  Interactable.prototype.resizable = function (this: Interact.Interactable, options: Interact.RestrictOption | boolean) {\n    return resizable(this, options, scope)\n  }\n\n  actions.resize = resize\n  actions.names.push('resize')\n  utils.arr.merge(actions.eventTypes, [\n    'resizestart',\n    'resizemove',\n    'resizeinertiastart',\n    'resizeresume',\n    'resizeend',\n  ])\n  actions.methodDict.resize = 'resizable'\n\n  defaults.actions.resize = resize.defaults\n}\n\nconst resize = {\n  install,\n  defaults: {\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  } as Interact.ResizableOptions,\n\n  checker (\n    _pointer: Interact.PointerType,\n    _event: Interact.PointerEventType,\n    interactable: Interact.Interactable,\n    element: Element,\n    interaction: Interaction,\n    rect: Interact.Rect\n  ) {\n    if (!rect) { return null }\n\n    const page = utils.extend({}, interaction.coords.cur.page)\n    const options = interactable.options\n\n    if (options.resize.enabled) {\n      const resizeOptions = options.resize\n      const resizeEdges: { [edge: string]: boolean } = { left: false, right: false, top: false, bottom: false }\n\n      // if using resize.edges\n      if (utils.is.object(resizeOptions.edges)) {\n        for (const edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge,\n            resizeOptions.edges[edge],\n            page,\n            interaction._latestPointer.eventTarget,\n            element,\n            rect,\n            resizeOptions.margin || this.defaultMargin)\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right\n        resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: 'resize',\n            edges: resizeEdges,\n          }\n        }\n      }\n      else {\n        const right  = options.resize.axis !== 'y' && page.x > (rect.right  - this.defaultMargin)\n        const bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - this.defaultMargin)\n\n        if (right || bottom) {\n          return {\n            name: 'resize',\n            axes: (right ? 'x' : '') + (bottom ? 'y' : ''),\n          }\n        }\n      }\n    }\n\n    return null\n  },\n\n  cursors: null as unknown as ReturnType<typeof initCursors>,\n\n  getCursor (action: Action) {\n    const cursors = resize.cursors as { [key: string]: string }\n    if (action.axis) {\n      return cursors[action.name + action.axis]\n    }\n    else if (action.edges) {\n      let cursorKey = ''\n      const edgeNames = ['top', 'bottom', 'left', 'right']\n\n      for (let i = 0; i < 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i]\n        }\n      }\n\n      return cursors[cursorKey]\n    }\n\n    return null\n  },\n\n  defaultMargin: null as unknown as number,\n}\n\nfunction resizable (interactable: Interact.Interactable, options: Interact.OrBoolean<Interact.ResizableOptions> | boolean, scope: Scope) {\n  if (utils.is.object(options)) {\n    interactable.options.resize.enabled = options.enabled !== false\n    interactable.setPerAction('resize', options)\n    interactable.setOnEvents('resize', options)\n\n    if (/^x$|^y$|^xy$/.test(options.axis as string)) {\n      interactable.options.resize.axis = options.axis\n    }\n    else if (options.axis === null) {\n      interactable.options.resize.axis = scope.defaults.actions.resize.axis\n    }\n\n    if (utils.is.bool(options.preserveAspectRatio)) {\n      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio\n    }\n    else if (utils.is.bool(options.square)) {\n      interactable.options.resize.square = options.square\n    }\n\n    return interactable\n  }\n  if (utils.is.bool(options)) {\n    interactable.options.resize.enabled = options\n\n    return interactable\n  }\n  return interactable.options.resize\n}\n\nfunction checkResizeEdge (name: string, value: any, page: Interact.Point, element: Node, interactableElement: Element, rect: Interact.Rect, margin: number) {\n  // false, '', undefined, null\n  if (!value) { return false }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width  = utils.is.number(rect.width) ? rect.width  : rect.right  - rect.left\n    const height = utils.is.number(rect.height) ? rect.height : rect.bottom - rect.top\n\n    // don't use margin greater than half the relevent dimension\n    margin = Math.min(margin, (name === 'left' || name === 'right' ? width : height) / 2)\n\n    if (width < 0) {\n      if      (name === 'left')  { name = 'right' }\n      else if (name === 'right') { name = 'left'  }\n    }\n    if (height < 0) {\n      if      (name === 'top')    { name = 'bottom' }\n      else if (name === 'bottom') { name = 'top'    }\n    }\n\n    if (name === 'left') { return page.x < ((width  >= 0 ? rect.left : rect.right) + margin) }\n    if (name === 'top') { return page.y < ((height >= 0 ? rect.top : rect.bottom) + margin) }\n\n    if (name === 'right') { return page.x > ((width  >= 0 ? rect.right : rect.left) - margin) }\n    if (name === 'bottom') { return page.y > ((height >= 0 ? rect.bottom : rect.top) - margin) }\n  }\n\n  // the remaining checks require an element\n  if (!utils.is.element(element)) { return false }\n\n  return utils.is.element(value)\n  // the value is an element to use as a resize handle\n    ? value === element\n    // otherwise check if element matches value as selector\n    : utils.dom.matchesUpTo(element, value, interactableElement)\n}\n\nfunction initCursors (browser: typeof import('@interactjs/utils/browser').default) {\n  return (browser.isIe9 ? {\n    x : 'e-resize',\n    y : 's-resize',\n    xy: 'se-resize',\n\n    top        : 'n-resize',\n    left       : 'w-resize',\n    bottom     : 's-resize',\n    right      : 'e-resize',\n    topleft    : 'se-resize',\n    bottomright: 'se-resize',\n    topright   : 'ne-resize',\n    bottomleft : 'ne-resize',\n  } : {\n    x : 'ew-resize',\n    y : 'ns-resize',\n    xy: 'nwse-resize',\n\n    top        : 'ns-resize',\n    left       : 'ew-resize',\n    bottom     : 'ns-resize',\n    right      : 'ew-resize',\n    topleft    : 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright   : 'nesw-resize',\n    bottomleft : 'nesw-resize',\n  })\n}\n\nfunction start ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {\n    return\n  }\n\n  const startRect = interaction.target.getRect(interaction.element)\n  const resizeOptions = interaction.target.options.resize\n\n  /*\n   * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n   * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n   * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n   * on the active edges and the edge being interacted with.\n   */\n  if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n    const linkedEdges = utils.extend({}, interaction.prepared.edges)\n\n    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom)\n    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right)\n    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top)\n    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left)\n\n    interaction.prepared._linkedEdges = linkedEdges\n  }\n  else {\n    interaction.prepared._linkedEdges = null\n  }\n\n  // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n  if (resizeOptions.preserveAspectRatio) {\n    interaction.resizeStartAspectRatio = startRect.width / startRect.height\n  }\n\n  interaction.resizeRects = {\n    start     : startRect,\n    current   : utils.extend({}, startRect),\n    inverted  : utils.extend({}, startRect),\n    previous  : utils.extend({}, startRect),\n    delta     : {\n      left: 0,\n      right : 0,\n      width : 0,\n      top : 0,\n      bottom: 0,\n      height: 0,\n    },\n  }\n\n  iEvent.rect = interaction.resizeRects.inverted\n  iEvent.deltaRect = interaction.resizeRects.delta\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) { return }\n\n  const resizeOptions = interaction.target.options.resize\n  const invert = resizeOptions.invert\n  const invertible = invert === 'reposition' || invert === 'negate'\n\n  let edges = interaction.prepared.edges\n\n  // eslint-disable-next-line no-shadow\n  const start      = interaction.resizeRects.start\n  const current    = interaction.resizeRects.current\n  const inverted   = interaction.resizeRects.inverted\n  const deltaRect  = interaction.resizeRects.delta\n  const previous   = utils.extend(interaction.resizeRects.previous, inverted)\n  const originalEdges = edges\n\n  const eventDelta = utils.extend({}, iEvent.delta)\n\n  if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n    // `resize.preserveAspectRatio` takes precedence over `resize.square`\n    const startAspectRatio = resizeOptions.preserveAspectRatio\n      ? interaction.resizeStartAspectRatio\n      : 1\n\n    edges = interaction.prepared._linkedEdges\n\n    if ((originalEdges.left && originalEdges.bottom) ||\n        (originalEdges.right && originalEdges.top)) {\n      eventDelta.y = -eventDelta.x / startAspectRatio\n    }\n    else if (originalEdges.left || originalEdges.right) { eventDelta.y = eventDelta.x / startAspectRatio }\n    else if (originalEdges.top  || originalEdges.bottom) { eventDelta.x = eventDelta.y * startAspectRatio }\n  }\n\n  // update the 'current' rect without modifications\n  if (edges.top) { current.top    += eventDelta.y }\n  if (edges.bottom) { current.bottom += eventDelta.y }\n  if (edges.left) { current.left   += eventDelta.x }\n  if (edges.right) { current.right  += eventDelta.x }\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    utils.extend(inverted, current)\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      let swap\n\n      if (inverted.top > inverted.bottom) {\n        swap = inverted.top\n\n        inverted.top = inverted.bottom\n        inverted.bottom = swap\n      }\n      if (inverted.left > inverted.right) {\n        swap = inverted.left\n\n        inverted.left = inverted.right\n        inverted.right = swap\n      }\n    }\n  }\n  else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    inverted.top    = Math.min(current.top, start.bottom)\n    inverted.bottom = Math.max(current.bottom, start.top)\n    inverted.left   = Math.min(current.left, start.right)\n    inverted.right  = Math.max(current.right, start.left)\n  }\n\n  inverted.width  = inverted.right  - inverted.left\n  inverted.height = inverted.bottom - inverted.top\n\n  for (const edge in inverted) {\n    deltaRect[edge] = inverted[edge] - previous[edge]\n  }\n\n  iEvent.edges = interaction.prepared.edges\n  iEvent.rect = inverted\n  iEvent.deltaRect = deltaRect\n}\n\nfunction updateEventAxes ({ interaction, iEvent, action }) {\n  if (action !== 'resize' || !interaction.resizeAxes) { return }\n\n  const options = interaction.target.options\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      iEvent.delta.x = iEvent.delta.y\n    }\n    else {\n      iEvent.delta.y = iEvent.delta.x\n    }\n    iEvent.axes = 'xy'\n  }\n  else {\n    iEvent.axes = interaction.resizeAxes\n\n    if (interaction.resizeAxes === 'x') {\n      iEvent.delta.y = 0\n    }\n    else if (interaction.resizeAxes === 'y') {\n      iEvent.delta.x = 0\n    }\n  }\n}\n\nexport default resize\n","/// <reference path=\"./types.d.ts\" />\nimport { Scope } from '@interactjs/core/scope'\nimport drag from './drag'\nimport drop from './drop'\nimport gesture from './gesture'\nimport resize from './resize'\n\nfunction install (scope: Scope) {\n  gesture.install(scope)\n  resize.install(scope)\n  drag.install(scope)\n  drop.install(scope)\n}\n\nexport {\n  gesture,\n  resize,\n  drag,\n  drop,\n  install,\n}\n","import * as domUtils from '@interactjs/utils/domUtils'\nimport * as is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport { getStringOptionResult } from '@interactjs/utils/rect'\nimport { getWindow } from '@interactjs/utils/window'\n\ntype Scope = import ('@interactjs/core/scope').Scope\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoScroll: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    autoScroll?: Interact.AutoScrollOption\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    interactions,\n    defaults,\n    actions,\n  } = scope\n\n  scope.autoScroll = autoScroll\n\n  interactions.signals.on('new', (interaction) => {\n    interaction.autoScroll = null\n  })\n\n  interactions.signals.on('stop', autoScroll.stop)\n\n  interactions.signals.on('action-move', autoScroll.onInteractionMove)\n\n  actions.eventTypes.push('autoscroll')\n  defaults.perAction.autoScroll = autoScroll.defaults\n}\n\nconst autoScroll = {\n  defaults: {\n    enabled  : false,\n    margin   : 60,\n\n    // the item that is scrolled (Window or HTMLElement)\n    container: null as Window | Element,\n\n    // the scroll speed in pixels per second\n    speed    : 300,\n  } as Interact.AutoScrollOption,\n\n  interaction: null,\n  i: null,    // the handle returned by window.setInterval\n  x: 0,\n  y: 0, // Direction each pulse is to scroll in\n\n  isScrolling: false,\n  prevTime: 0,\n  margin: 0,\n  speed: 0,\n\n  start (interaction) {\n    autoScroll.isScrolling = true\n    raf.cancel(autoScroll.i)\n\n    interaction.autoScroll = autoScroll\n    autoScroll.interaction = interaction\n    autoScroll.prevTime = new Date().getTime()\n    autoScroll.i = raf.request(autoScroll.scroll)\n  },\n\n  stop () {\n    autoScroll.isScrolling = false\n    if (autoScroll.interaction) {\n      autoScroll.interaction.autoScroll = null\n    }\n    raf.cancel(autoScroll.i)\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll () {\n    const { interaction } = autoScroll\n    const { target: interactable, element } = interaction\n    const options = interactable.options[autoScroll.interaction.prepared.name].autoScroll\n    const container = getContainer(options.container, interactable, element)\n    const now = new Date().getTime()\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000\n    // displacement\n    const s = options.speed * dt\n\n    if (s >= 1) {\n      const scrollBy = {\n        x: autoScroll.x * s,\n        y: autoScroll.y * s,\n      }\n\n      if (scrollBy.x || scrollBy.y) {\n        const prevScroll = getScroll(container)\n\n        if (is.window(container)) {\n          container.scrollBy(scrollBy.x, scrollBy.y)\n        }\n        else if (container) {\n          container.scrollLeft += scrollBy.x\n          container.scrollTop  += scrollBy.y\n        }\n\n        const curScroll = getScroll(container)\n        const delta = {\n          x: curScroll.x - prevScroll.x,\n          y: curScroll.y - prevScroll.y,\n        }\n\n        if (delta.x || delta.y) {\n          interactable.fire({\n            type: 'autoscroll',\n            target: element,\n            interactable,\n            delta,\n            interaction,\n            container,\n          })\n        }\n      }\n\n      autoScroll.prevTime = now\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i)\n      autoScroll.i = raf.request(autoScroll.scroll)\n    }\n  },\n  check (interactable, actionName) {\n    const options = interactable.options\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled\n  },\n  onInteractionMove ({ interaction, pointer }) {\n    if (!(interaction.interacting() &&\n          autoScroll.check(interaction.target, interaction.prepared.name))) {\n      return\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0\n      return\n    }\n\n    let top\n    let right\n    let bottom\n    let left\n\n    const { target: interactable, element } = interaction\n    const options = interactable.options[interaction.prepared.name].autoScroll\n    const container = getContainer(options.container, interactable, element)\n\n    if (is.window(container)) {\n      left   = pointer.clientX < autoScroll.margin\n      top    = pointer.clientY < autoScroll.margin\n      right  = pointer.clientX > container.innerWidth  - autoScroll.margin\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin\n    }\n    else {\n      const rect = domUtils.getElementClientRect(container)\n\n      left   = pointer.clientX < rect.left   + autoScroll.margin\n      top    = pointer.clientY < rect.top    + autoScroll.margin\n      right  = pointer.clientX > rect.right  - autoScroll.margin\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin\n    }\n\n    autoScroll.x = (right ? 1 : left ? -1 : 0)\n    autoScroll.y = (bottom ? 1 :  top ? -1 : 0)\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin\n      autoScroll.speed  = options.speed\n\n      autoScroll.start(interaction)\n    }\n  },\n}\n\nexport function getContainer (value, interactable, element) {\n  return (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element)\n}\n\nexport function getScroll (container) {\n  if (is.window(container)) { container = window.document.body }\n\n  return { x: container.scrollLeft, y: container.scrollTop }\n}\n\nexport function getScrollSize (container) {\n  if (is.window(container)) { container = window.document.body }\n\n  return { x: container.scrollWidth, y: container.scrollHeight }\n}\n\nexport function getScrollSizeDelta ({ interaction, element }, func) {\n  const scrollOptions = interaction && interaction.target.options[interaction.prepared.name].autoScroll\n\n  if (!scrollOptions || !scrollOptions.enabled) {\n    func()\n    return { x: 0, y: 0 }\n  }\n\n  const scrollContainer = getContainer(\n    scrollOptions.container,\n    interaction.target,\n    element\n  )\n\n  const prevSize = getScroll(scrollContainer)\n  func()\n  const curSize = getScroll(scrollContainer)\n\n  return {\n    x: curSize.x - prevSize.x,\n    y: curSize.y - prevSize.y,\n  }\n}\n\nexport default { install }\n","import { warnOnce } from '@interactjs/utils'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport * as is from '@interactjs/utils/is'\n\n// TODO: there seems to be a @babel/preset-typescript bug causing regular import\n// syntax to remain in js output\ntype Scope = import ('@interactjs/core/scope').Scope\ntype Actions = import ('@interactjs/core/scope').Actions\ntype Interaction = import ('@interactjs/core/Interaction').default\ntype Interactable = import ('@interactjs/core/Interactable').default\n\ntype IgnoreValue = string | Element | boolean\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: typeof getAction\n    defaultActionChecker: (pointer: any, event: any, interaction: any, element: any) => any\n    styleCursor: typeof styleCursor\n    actionChecker: typeof actionChecker\n    testIgnoreAllow: typeof testIgnoreAllow\n    testAllow: typeof testAllow\n    testIgnore: typeof testIgnore\n    ignoreFrom: (...args: any) => boolean\n    allowFrom: (...args: any) => boolean\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    pointerIsDown: boolean\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n    actions,\n  } = scope\n\n  Interactable.prototype.getAction = getAction\n\n  /**\n   * ```js\n   * interact(element, { ignoreFrom: document.getElementById('no-action') });\n   * // or\n   * interact(element).ignoreFrom('input, textarea, a');\n   * ```\n   * @deprecated\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n   * of it's parents match the given CSS selector or Element, no\n   * drag/resize/gesture is started.\n   *\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * @example\n   * interact(targett)\n   *   .draggable({\n   *     ignoreFrom: 'input, textarea, a[href]'',\n   *   })\n   *   .pointerEvents({\n   *     ignoreFrom: '[no-pointer]',\n   *   });\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to not ignore any elements\n   * @return {string | Element | object} The current ignoreFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  /**\n   * @deprecated\n   *\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\n   * CSS selector or Element.\n   *\n   * Don't use this method. Instead set the `allowFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * @example\n   * interact(targett)\n   *   .resizable({\n   *     allowFrom: '.resize-handle',\n   *   .pointerEvents({\n   *     allowFrom: '.handle',,\n   *   });\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to allow from any element\n   * @return {string | Element | object} The current allowFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  Interactable.prototype.testIgnore = testIgnore\n\n  Interactable.prototype.testAllow = testAllow\n\n  Interactable.prototype.testIgnoreAllow = testIgnoreAllow\n\n  /**\n   * ```js\n   * interact('.resize-drag')\n   *   .resizable(true)\n   *   .draggable(true)\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   *\n   *   if (interact.matchesSelector(event.target, '.drag-handle') {\n   *     // force drag with handle target\n   *     action.name = drag;\n   *   }\n   *   else {\n   *     // resize from the top and right edges\n   *     action.name  = 'resize';\n   *     action.edges = { top: true, right: true };\n   *   }\n   *\n   *   return action;\n   * });\n   * ```\n   *\n   * Gets or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   * @param {function | null} [checker] A function which takes a pointer event,\n   * defaultAction string, interactable, element and interaction as parameters\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n   * props.\n   * @return {Function | Interactable} The checker function or this Interactable\n   */\n  Interactable.prototype.actionChecker = actionChecker\n\n  /**\n   * Returns or sets whether the the cursor should be changed depending on the\n   * action that would be performed if the mouse were pressed and dragged.\n   *\n   * @param {boolean} [newValue]\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.styleCursor = styleCursor\n\n  Interactable.prototype.defaultActionChecker = function (this: Interactable, pointer, event, interaction, element) {\n    return defaultActionChecker(this, pointer, event, interaction, element, actions)\n  }\n}\n\nfunction getAction (this: Interactable, pointer: Interact.PointerType, event: Interact.PointerEventType, interaction: Interaction, element: Element) {\n  const action = this.defaultActionChecker(pointer, event, interaction, element)\n\n  if (this.options.actionChecker) {\n    return this.options.actionChecker(pointer, event, action, this, element, interaction)\n  }\n\n  return action\n}\n\nfunction defaultActionChecker (interactable: Interactable, pointer: Interact.PointerType, event: Interact.PointerEventType, interaction: Interaction, element: Element, actions: Actions) {\n  const rect = interactable.getRect(element)\n  const buttons = (event as MouseEvent).buttons || ({\n    0: 1,\n    1: 4,\n    3: 8,\n    4: 16,\n  })[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  let action = null\n\n  for (const actionName of actions.names) {\n    // check mouseButton setting if the pointer is down\n    if (interaction.pointerIsDown &&\n        /mouse|pointer/.test(interaction.pointerType) &&\n      (buttons & interactable.options[actionName].mouseButtons) === 0) {\n      continue\n    }\n\n    action = (actions[actionName as keyof Actions] as any).checker(pointer, event, interactable, element, interaction, rect)\n\n    if (action) {\n      return action\n    }\n  }\n}\n\nfunction styleCursor (this: Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker (this: Interactable, checker: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nfunction testIgnoreAllow (this: Interactable, options: { ignoreFrom: IgnoreValue, allowFrom: IgnoreValue }, interactableElement: Element, eventTarget: Element) {\n  return (!this.testIgnore(options.ignoreFrom, interactableElement, eventTarget) &&\n          this.testAllow(options.allowFrom, interactableElement, eventTarget))\n}\n\nfunction testAllow (this: Interactable, allowFrom: IgnoreValue, interactableElement: Element, element: Element) {\n  if (!allowFrom) { return true }\n\n  if (!is.element(element)) { return false }\n\n  if (is.string(allowFrom)) {\n    return domUtils.matchesUpTo(element, allowFrom, interactableElement)\n  }\n  else if (is.element(allowFrom)) {\n    return domUtils.nodeContains(allowFrom, element)\n  }\n\n  return false\n}\n\nfunction testIgnore (this: Interactable, ignoreFrom: IgnoreValue, interactableElement: Element, element: Element) {\n  if (!ignoreFrom || !is.element(element)) { return false }\n\n  if (is.string(ignoreFrom)) {\n    return domUtils.matchesUpTo(element, ignoreFrom, interactableElement)\n  }\n  else if (is.element(ignoreFrom)) {\n    return domUtils.nodeContains(ignoreFrom, element)\n  }\n\n  return false\n}\n\nexport default { install }\n","import * as utils from '@interactjs/utils'\nimport InteractableMethods from './InteractableMethods'\ntype Scope = import ('@interactjs/core/scope').Scope\n\ndeclare module '@interactjs/interact/interact' {\n  interface InteractStatic {\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n    maxInteractions: (...args: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons?: 0 | 1 | 2 | 4 | 16\n  }\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n  signals: utils.Signals\n}\n\nfunction install (scope: Scope) {\n  const {\n    interact,\n    interactions,\n    defaults,\n  } = scope\n\n  interact.use(InteractableMethods)\n\n  // set cursor style on mousedown\n  interactions.signals.on('down', ({ interaction, pointer, event, eventTarget }) => {\n    if (interaction.interacting()) { return }\n\n    const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n    prepare(interaction, actionInfo, scope)\n  })\n\n  // set cursor style on mousemove\n  interactions.signals.on('move', ({ interaction, pointer, event, eventTarget }) => {\n    if (interaction.pointerType !== 'mouse' ||\n        interaction.pointerIsDown ||\n        interaction.interacting()) { return }\n\n    const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n    prepare(interaction, actionInfo, scope)\n  })\n\n  interactions.signals.on('move', (arg) => {\n    const { interaction, event } = arg\n\n    if (!interaction.pointerIsDown ||\n        interaction.interacting() ||\n        !interaction.pointerWasMoved ||\n        !interaction.prepared.name) {\n      return\n    }\n\n    scope.autoStart.signals.fire('before-start', arg)\n\n    const target = interaction.target\n\n    if (interaction.prepared.name && target) {\n      // check manualStart and interaction limit\n      if (target.options[interaction.prepared.name].manualStart ||\n          !withinInteractionLimit(target, interaction.element, interaction.prepared, scope)) {\n        interaction.stop(event)\n      }\n      else {\n        interaction.start(interaction.prepared, target, interaction.element)\n      }\n    }\n  })\n\n  interactions.signals.on('stop', ({ interaction }) => {\n    const target = interaction.target\n\n    if (target && target.options.styleCursor) {\n      setCursor(interaction.element, '', scope)\n    }\n  })\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  utils.extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom:  null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  });\n\n  /**\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\n   * default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables and\n   * elements, you need to enable it in the draggable, resizable and gesturable\n   * `'max'` and `'maxPerElement'` options.\n   *\n   * @alias module:interact.maxInteractions\n   *\n   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n   */\n  (interact as any /* FIXME */).maxInteractions = (newValue) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n    signals: new utils.Signals(),\n  }\n}\n\n// Check if the current target supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction (action, interactable, element, eventTarget, scope) {\n  if (utils.is.object(action) &&\n      interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n      interactable.options[action.name].enabled &&\n      withinInteractionLimit(interactable, element, action, scope)) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateSelector (interaction, pointer, event, matches, matchElements, eventTarget, scope) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const action = validateAction(\n      match.getAction(pointer, event, interaction, matchElement),\n      match,\n      matchElement,\n      eventTarget,\n      scope)\n\n    if (action) {\n      return {\n        action,\n        target: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, target: null, element: null }\n}\n\nfunction getActionInfo (interaction, pointer, event, eventTarget, scope) {\n  let matches = []\n  let matchElements = []\n\n  let element = eventTarget\n\n  function pushMatches (interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (utils.is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateSelector(interaction, pointer, event, matches, matchElements, eventTarget, scope)\n\n    if (actionInfo.action &&\n      !actionInfo.target.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = utils.dom.parentNode(element)\n  }\n\n  return { action: null, target: null, element: null }\n}\n\nfunction prepare (interaction, { action, target, element }, scope) {\n  action = action || {}\n\n  if (interaction.target && interaction.target.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n\n  interaction.target = target\n  interaction.element = element\n  utils.copyAction(interaction.prepared, action)\n\n  if (target && target.options.styleCursor) {\n    const cursor = action ? scope.actions[action.name].getCursor(action) : ''\n    setCursor(interaction.element, cursor, scope)\n  }\n\n  scope.autoStart.signals.fire('prepared', { interaction })\n}\n\nfunction withinInteractionLimit (interactable, element, action, scope) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let targetCount = 0\n  let targetElementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) { return false }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) { continue }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.target !== interactable) { continue }\n\n    targetCount += otherAction === action.name ? 1 : 0\n\n    if (targetCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      targetElementCount++\n\n      if (otherAction === action.name && targetElementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions (newValue, scope) {\n  if (utils.is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor (element, cursor, scope) {\n  if (scope.autoStart.cursorElement) {\n    scope.autoStart.cursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nexport default {\n  install,\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n","import { parentNode } from '@interactjs/utils/domUtils'\nimport * as is from '@interactjs/utils/is'\nimport autoStart from './base'\n\ntype Scope = import ('@interactjs/core/scope').Scope\n\nfunction install (scope: Scope) {\n  scope.autoStart.signals.on('before-start',  ({ interaction, eventTarget, dx, dy }) => {\n    if (interaction.prepared.name !== 'drag') { return }\n\n    // check if a drag is in the correct axis\n    const absX = Math.abs(dx)\n    const absY = Math.abs(dy)\n    const targetOptions = interaction.target.options.drag\n    const startAxis = targetOptions.startAxis\n    const currentAxis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy')\n\n    interaction.prepared.axis = targetOptions.lockAxis === 'start'\n      ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\n      : targetOptions.lockAxis\n\n    // if the movement isn't in the startAxis of the interactable\n    if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n      // cancel the prepared action\n      interaction.prepared.name = null\n\n      // then try to get a drag from another ineractable\n      let element = eventTarget\n\n      const getDraggable = function (interactable) {\n        if (interactable === interaction.target) { return }\n\n        const options = interaction.target.options.drag\n\n        if (!options.manualStart &&\n            interactable.testIgnoreAllow(options, element, eventTarget)) {\n          const action = interactable.getAction(\n            interaction.downPointer, interaction.downEvent, interaction, element)\n\n          if (action &&\n              action.name === 'drag' &&\n              checkStartAxis(currentAxis, interactable) &&\n              autoStart.validateAction(action, interactable, element, eventTarget, scope)) {\n            return interactable\n          }\n        }\n      }\n\n      // check all interactables\n      while (is.element(element)) {\n        const interactable = scope.interactables.forEachMatch(element, getDraggable)\n\n        if (interactable) {\n          interaction.prepared.name = 'drag'\n          interaction.target = interactable\n          interaction.element = element\n          break\n        }\n\n        element = parentNode(element)\n      }\n    }\n  })\n\n  function checkStartAxis (startAxis, interactable) {\n    if (!interactable) { return false }\n\n    const thisAxis = interactable.options.drag.startAxis\n\n    return (startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis)\n  }\n}\n\nexport default { install }\n","type Scope = import ('@interactjs/core/scope').Scope\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    hold?: number\n    delay?: number\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    autoStart,\n    interactions,\n    defaults,\n  } = scope\n\n  defaults.perAction.hold = 0\n  defaults.perAction.delay = 0\n\n  interactions.signals.on('new', (interaction) => {\n    interaction.autoStartHoldTimer = null\n  })\n\n  autoStart.signals.on('prepared', ({ interaction }) => {\n    const hold = getHoldDuration(interaction)\n\n    if (hold > 0) {\n      interaction.autoStartHoldTimer = setTimeout(() => {\n        interaction.start(interaction.prepared, interaction.target, interaction.element)\n      }, hold)\n    }\n  })\n\n  interactions.signals.on('move', ({ interaction, duplicate }) => {\n    if (interaction.pointerWasMoved && !duplicate) {\n      clearTimeout(interaction.autoStartHoldTimer)\n    }\n  })\n\n  // prevent regular down->move autoStart\n  autoStart.signals.on('before-start', ({ interaction }) => {\n    const hold = getHoldDuration(interaction)\n\n    if (hold > 0) {\n      interaction.prepared.name = null\n    }\n  })\n}\n\nfunction getHoldDuration (interaction) {\n  const actionName = interaction.prepared && interaction.prepared.name\n\n  if (!actionName) { return null }\n\n  const options = interaction.target.options\n\n  return options[actionName].hold || options[actionName].delay\n}\n\nexport default {\n  install,\n  getHoldDuration,\n}\n","import autoStart from './base'\nimport dragAxis from './dragAxis'\nimport hold from './hold'\n\nfunction install (scope) {\n  autoStart.install(scope)\n  hold.install(scope)\n  dragAxis.install(scope)\n}\n\nexport {\n  autoStart,\n  hold,\n  dragAxis,\n  install,\n}\n","import { matchesSelector, nodeContains } from '@interactjs/utils/domUtils'\nimport events from '@interactjs/utils/events'\nimport * as is from '@interactjs/utils/is'\nimport { getWindow } from '@interactjs/utils/window'\n\nfunction preventDefault (interactable, newValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    interactable.options.preventDefault = newValue\n    return interactable\n  }\n\n  if (is.bool(newValue)) {\n    interactable.options.preventDefault = newValue ? 'always' : 'never'\n    return interactable\n  }\n\n  return interactable.options.preventDefault\n}\n\nfunction checkAndPreventDefault (interactable, scope, event) {\n  const setting = interactable.options.preventDefault\n\n  if (setting === 'never') { return }\n\n  if (setting === 'always') {\n    event.preventDefault()\n    return\n  }\n\n  // setting === 'auto'\n\n  // if the browser supports passive event listeners and isn't running on iOS,\n  // don't preventDefault of touch{start,move} events. CSS touch-action and\n  // user-select should be used instead of calling event.preventDefault().\n  if (events.supportsPassive && /^touch(start|move)$/.test(event.type)) {\n    const doc = getWindow(event.target).document\n    const docOptions = scope.getDocOptions(doc)\n\n    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {\n      return\n    }\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return\n  }\n\n  // don't preventDefault on editable elements\n  if (is.element(event.target) &&\n      matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {\n    return\n  }\n\n  event.preventDefault()\n}\n\nfunction onInteractionEvent ({ interaction, event }) {\n  if (interaction.target) {\n    interaction.target.checkAndPreventDefault(event)\n  }\n}\n\nexport function install (scope) {\n  /** @lends Interactable */\n  const Interactable = scope.Interactable\n\n  /**\n   * Returns or sets whether to prevent the browser's default behaviour in\n   * response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`\n   * @return {string | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.preventDefault = function (newValue) {\n    return preventDefault(this, newValue)\n  }\n\n  Interactable.prototype.checkAndPreventDefault = function (event) {\n    return checkAndPreventDefault(this, scope, event)\n  }\n\n  for (const eventSignal of ['down', 'move', 'up', 'cancel']) {\n    scope.interactions.signals.on(eventSignal, onInteractionEvent)\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  scope.interactions.eventMap.dragstart = function preventNativeDrag (event) {\n    for (const interaction of scope.interactions.list) {\n      if (interaction.element &&\n        (interaction.element === event.target ||\n          nodeContains(interaction.element, event.target))) {\n        interaction.target.checkAndPreventDefault(event)\n        return\n      }\n    }\n  }\n}\n\nexport type Install = typeof install\n\nexport default { install }\n","import Interaction from '@interactjs/core/Interaction'\nimport { Scope } from '@interactjs/core/scope'\nimport extend from '@interactjs/utils/extend'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    modifiers?: any\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    modifiers?: any\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    modifiers?: any[]\n  }\n  interface Options {\n    drag?: Interact.DraggableOptions\n    modifiers?: any[]\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    interactions,\n  } = scope\n\n  scope.defaults.perAction.modifiers = []\n  scope.modifiers = {}\n\n  interactions.signals.on('new', (interaction) => {\n    interaction.modifiers = {\n      startOffset: { left: 0, right: 0, top: 0, bottom: 0 },\n      offsets    : {},\n      states   : null,\n      result     : null,\n    }\n  })\n\n  interactions.signals.on('before-action-start', (arg) => {\n    start(arg, arg.interaction.coords.start.page, scope.modifiers)\n  })\n\n  interactions.signals.on('action-resume', (arg) => {\n    beforeMove(arg)\n    start(arg, arg.interaction.coords.cur.page, scope.modifiers)\n  })\n\n  interactions.signals.on('before-action-move', beforeMove)\n  interactions.signals.on('before-action-end', beforeEnd)\n\n  interactions.signals.on('before-action-start', setCoords)\n  interactions.signals.on('before-action-move', setCoords)\n\n  interactions.signals.on('after-action-start', restoreCoords)\n  interactions.signals.on('after-action-move', restoreCoords)\n  interactions.signals.on('stop', stop)\n}\n\nfunction startAll (arg) {\n  for (const state of arg.states) {\n    if (state.methods.start) {\n      arg.state = state\n      state.methods.start(arg)\n    }\n  }\n}\n\nfunction getRectOffset (rect, coords) {\n  return rect\n    ? {\n      left  : coords.x - rect.left,\n      top   : coords.y - rect.top,\n      right : rect.right  - coords.x,\n      bottom: rect.bottom - coords.y,\n    }\n    : {\n      left  : 0,\n      top   : 0,\n      right : 0,\n      bottom: 0,\n    }\n}\n\nfunction start (\n  { interaction, phase }: { interaction: Interaction, phase: string },\n  pageCoords,\n  registeredModifiers,\n) {\n  const { target: interactable, element } = interaction\n  const modifierList = getModifierList(interaction, registeredModifiers)\n  const states = prepareStates(modifierList)\n\n  const rect = extend({}, interactable.getRect(element as Element)) as  Interact.Rect & Interact.Rect2\n\n  if (!('width'  in rect)) { rect.width  = rect.right  - rect.left }\n  if (!('height' in rect)) { rect.height = rect.bottom - rect.top  }\n\n  const startOffset = getRectOffset(rect, pageCoords)\n\n  interaction.modifiers.startOffset = startOffset\n  interaction.modifiers.startDelta = { x: 0, y: 0 }\n\n  const arg = {\n    interaction,\n    interactable,\n    element,\n    pageCoords,\n    phase,\n    rect,\n    startOffset,\n    states,\n    preEnd: false,\n    requireEndOnly: false,\n  }\n\n  interaction.modifiers.states = states\n  interaction.modifiers.result = null\n  startAll(arg)\n\n  arg.pageCoords = extend({}, interaction.coords.start.page)\n\n  const result = interaction.modifiers.result = setAll(arg)\n\n  return result\n}\n\nfunction setAll (arg) {\n  const { interaction, phase, preEnd, requireEndOnly, rect, skipModifiers } = arg\n\n  const states = skipModifiers\n    ? arg.states.slice(interaction.modifiers.skip)\n    : arg.states\n\n  arg.coords = extend({}, arg.pageCoords)\n  arg.rect = extend({}, rect)\n\n  const result = {\n    delta: { x: 0, y: 0 },\n    coords: arg.coords,\n    changed: true,\n  }\n\n  for (const state of states) {\n    const { options } = state\n\n    if (!state.methods.set ||\n      !shouldDo(options, preEnd, requireEndOnly, phase)) { continue }\n\n    arg.state = state\n    state.methods.set(arg)\n  }\n\n  result.delta.x = arg.coords.x - arg.pageCoords.x\n  result.delta.y = arg.coords.y - arg.pageCoords.y\n\n  const prevCoords = interaction.modifiers.result\n    ? interaction.modifiers.result.coords\n    : interaction.coords.prev.page\n\n  result.changed = (\n    prevCoords.x !== result.coords.x ||\n    prevCoords.y !== result.coords.y)\n\n  return result\n}\n\nfunction prepareStates (modifierList) {\n  const states = []\n\n  for (let index = 0; index < modifierList.length; index++) {\n    const { options, methods } = modifierList[index]\n\n    if (options && options.enabled === false) { continue }\n\n    const state = {\n      options,\n      methods,\n      index,\n    }\n\n    states.push(state)\n  }\n\n  return states\n}\n\nfunction beforeMove ({ interaction, phase, preEnd, skipModifiers }): void | false {\n  const { target: interactable, element } = interaction\n  const modifierResult = setAll(\n    {\n      interaction,\n      interactable,\n      element,\n      preEnd,\n      phase,\n      pageCoords: interaction.coords.cur.page,\n      rect: interactable.getRect(element),\n      states: interaction.modifiers.states,\n      requireEndOnly: false,\n      skipModifiers,\n    })\n\n  interaction.modifiers.result = modifierResult\n\n  // don't fire an action move if a modifier would keep the event in the same\n  // cordinates as before\n  if (!modifierResult.changed && interaction.interacting()) {\n    return false\n  }\n}\n\nfunction beforeEnd (arg): void | false {\n  const { interaction, event, noPreEnd } = arg\n  const states = interaction.modifiers.states\n\n  if (noPreEnd || !states || !states.length) {\n    return\n  }\n\n  let didPreEnd = false\n\n  for (const state of states) {\n    arg.state = state\n    const { options, methods } = state\n\n    const endResult = methods.beforeEnd && methods.beforeEnd(arg)\n\n    if (endResult === false) {\n      return false\n    }\n\n    // if the endOnly option is true for any modifier\n    if (!didPreEnd && shouldDo(options, true, true)) {\n      // fire a move event at the modified coordinates\n      interaction.move({ event, preEnd: true })\n      didPreEnd = true\n    }\n  }\n}\n\nfunction stop (arg) {\n  const { interaction } = arg\n  const states = interaction.modifiers.states\n\n  if (!states || !states.length) {\n    return\n  }\n\n  const modifierArg = extend({\n    states,\n    interactable: interaction.target,\n    element: interaction.element,\n  }, arg)\n\n  restoreCoords(arg)\n\n  for (const state of states) {\n    modifierArg.state = state\n\n    if (state.methods.stop) { state.methods.stop(modifierArg) }\n  }\n\n  arg.interaction.modifiers.states = null\n}\n\nfunction setCoords (arg) {\n  const { interaction, phase } = arg\n  const curCoords = arg.curCoords || interaction.coords.cur\n  const startCoords = arg.startCoords || interaction.coords.start\n  const { result, startDelta } = interaction.modifiers\n  const curDelta = result.delta\n\n  if (phase === 'start') {\n    extend(interaction.modifiers.startDelta, result.delta)\n  }\n\n  for (const [coordsSet, delta] of [[startCoords, startDelta], [curCoords, curDelta]]) {\n    coordsSet.page.x   += delta.x\n    coordsSet.page.y   += delta.y\n    coordsSet.client.x += delta.x\n    coordsSet.client.y += delta.y\n  }\n}\n\nfunction restoreCoords ({ interaction: { coords, modifiers } }) {\n  const { startDelta, result: { delta: curDelta } } = modifiers\n\n  for (const [coordsSet, delta] of [[coords.start, startDelta], [coords.cur, curDelta]]) {\n    coordsSet.page.x -= delta.x\n    coordsSet.page.y -= delta.y\n    coordsSet.client.x -= delta.x\n    coordsSet.client.y -= delta.y\n  }\n}\n\nfunction getModifierList (interaction, registeredModifiers) {\n  const actionOptions = interaction.target.options[interaction.prepared.name]\n  const actionModifiers = actionOptions.modifiers\n\n  if (actionModifiers && actionModifiers.length) {\n    return actionModifiers.map((modifier) => {\n      if (!modifier.methods && modifier.type) {\n        return registeredModifiers[modifier.type](modifier)\n      }\n\n      return modifier\n    })\n  }\n\n  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize']\n    .map((type) => {\n      const options = actionOptions[type]\n\n      return options && options.enabled && {\n        options,\n        methods: options._methods,\n      }\n    })\n    .filter((m) => !!m)\n}\n\nfunction shouldDo (options, preEnd?: boolean, requireEndOnly?: boolean, phase?: string) {\n  return options\n    ? options.enabled !== false &&\n      (preEnd || !options.endOnly) &&\n      (!requireEndOnly || options.endOnly) &&\n      (options.setStart || phase !== 'start')\n    : !requireEndOnly\n}\n\nfunction makeModifier (module, name) {\n  const { defaults } = module\n  const methods = {\n    start: module.start,\n    set: module.set,\n    beforeEnd: module.beforeEnd,\n    stop: module.stop,\n  }\n\n  const modifier = (options) => {\n    options = options || {}\n\n    // add missing defaults to options\n    options.enabled = options.enabled !== false\n\n    for (const prop in defaults) {\n      if (!(prop in options)) {\n        options[prop] = defaults[prop]\n      }\n    }\n\n    return { options, methods }\n  }\n\n  if (typeof name === 'string') {\n    Object.defineProperty(\n      modifier,\n      'name',\n      { value: name })\n\n    // for backwrads compatibility\n    modifier._defaults = defaults\n    modifier._methods = methods\n  }\n\n  return modifier\n}\n\nexport default {\n  install,\n  startAll,\n  setAll,\n  prepareStates,\n  start,\n  beforeMove,\n  beforeEnd,\n  stop,\n  shouldDo,\n  getModifierList,\n  getRectOffset,\n  makeModifier,\n}\n","import modifiers from '@interactjs/modifiers/base'\nimport * as utils from '@interactjs/utils'\nimport raf from '@interactjs/utils/raf'\n\ntype Scope = import ('@interactjs/core/scope').Scope\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    inertia?: {\n      enabled?: boolean,\n      resistance?: number,        // the lambda in exponential decay\n      minSpeed?: number,          // target speed must be above this for inertia to start\n      endSpeed?: number,          // the speed at which inertia is slow enough to stop\n      allowResume?: true,         // allow resuming an action in inertia phase\n      smoothEndDuration?: number, // animate to snap/restrict endOnly if there's no inertia\n    }\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    interactions,\n    defaults,\n  } = scope\n\n  interactions.signals.on('new', (interaction) => {\n    interaction.inertia = {\n      active     : false,\n      smoothEnd  : false,\n      allowResume: false,\n\n      startEvent: null,\n      upCoords  : {},\n\n      xe: 0,\n      ye: 0,\n      sx: 0,\n      sy: 0,\n\n      t0: 0,\n      vx0: 0,\n      vys: 0,\n      duration: 0,\n\n      lambda_v0: 0,\n      one_ve_v0: 0,\n      i  : null,\n    }\n  })\n\n  interactions.signals.on('before-action-end', (arg) => release(arg, scope))\n  interactions.signals.on('down', (arg) => resume(arg, scope))\n  interactions.signals.on('stop', (arg) => stop(arg))\n\n  defaults.perAction.inertia = {\n    enabled          : false,\n    resistance       : 10,    // the lambda in exponential decay\n    minSpeed         : 100,   // target speed must be above this for inertia to start\n    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n    allowResume      : true,  // allow resuming an action in inertia phase\n    smoothEndDuration: 300,   // animate to snap/restrict endOnly if there's no inertia\n  }\n}\n\nfunction resume ({ interaction, event, pointer, eventTarget }, scope: Scope) {\n  const state = interaction.inertia\n\n  // Check if the down event hits the current inertia target\n  if (state.active) {\n    let element = eventTarget\n\n    // climb up the DOM tree from the event target\n    while (utils.is.element(element)) {\n      // if interaction element is the current inertia target element\n      if (element === interaction.element) {\n        // stop inertia\n        raf.cancel(state.i)\n        state.active = false\n        interaction.simulation = null\n\n        // update pointers to the down event's coordinates\n        interaction.updatePointer(pointer, event, eventTarget, true)\n        utils.pointer.setCoords(\n          interaction.coords.cur,\n          interaction.pointers.map((p) => p.pointer)\n        )\n\n        // fire appropriate signals\n        const signalArg = {\n          interaction,\n        }\n\n        scope.interactions.signals.fire('action-resume', signalArg)\n\n        // fire a reume event\n        const resumeEvent = new scope.InteractEvent(\n          interaction, event, interaction.prepared.name, 'resume', interaction.element)\n\n        interaction._fireEvent(resumeEvent)\n\n        utils.pointer.copyCoords(interaction.coords.prev, interaction.coords.cur)\n        break\n      }\n\n      element = utils.dom.parentNode(element)\n    }\n  }\n}\n\nfunction release ({ interaction, event, noPreEnd }, scope: Scope) {\n  const state = interaction.inertia\n\n  if (!interaction.interacting() ||\n    (interaction.simulation && interaction.simulation.active) ||\n  noPreEnd) {\n    return null\n  }\n\n  const options = getOptions(interaction)\n\n  const now = new Date().getTime()\n  const { client: velocityClient } = interaction.coords.velocity\n  const pointerSpeed = utils.hypot(velocityClient.x, velocityClient.y)\n\n  let smoothEnd = false\n  let modifierResult\n\n  // check if inertia should be started\n  const inertiaPossible = (options && options.enabled &&\n                     interaction.prepared.name !== 'gesture' &&\n                     event !== state.startEvent)\n\n  const inertia = (inertiaPossible &&\n    (now - interaction.coords.cur.timeStamp) < 50 &&\n    pointerSpeed > options.minSpeed &&\n    pointerSpeed > options.endSpeed)\n\n  const modifierArg = {\n    interaction,\n    pageCoords: utils.extend({}, interaction.coords.cur.page),\n    states: inertiaPossible && interaction.modifiers.states.map(\n      (modifierStatus) => utils.extend({}, modifierStatus)\n    ),\n    preEnd: true,\n    requireEndOnly: true,\n  }\n\n  // smoothEnd\n  if (inertiaPossible && !inertia) {\n    modifierResult = modifiers.setAll(modifierArg)\n\n    if (modifierResult.shouldMove) {\n      smoothEnd = true\n    }\n  }\n\n  if (!(inertia || smoothEnd)) { return null }\n\n  utils.pointer.copyCoords(state.upCoords, interaction.coords.cur)\n\n  interaction.pointers[0].pointer = state.startEvent = new scope.InteractEvent(\n    interaction, event, interaction.prepared.name, 'inertiastart', interaction.element)\n\n  state.t0 = now\n\n  state.active = true\n  state.allowResume = options.allowResume\n  interaction.simulation = state\n\n  interaction.target.fire(state.startEvent)\n\n  if (inertia) {\n    state.vx0 = interaction.coords.velocity.client.x\n    state.vy0 = interaction.coords.velocity.client.y\n    state.v0 = pointerSpeed\n\n    calcInertia(interaction, state)\n\n    utils.extend(modifierArg.pageCoords, interaction.coords.cur.page)\n\n    modifierArg.pageCoords.x += state.xe\n    modifierArg.pageCoords.y += state.ye\n\n    modifierResult = modifiers.setAll(modifierArg)\n\n    state.modifiedXe += modifierResult.delta.x\n    state.modifiedYe += modifierResult.delta.y\n\n    state.i = raf.request(() => inertiaTick(interaction))\n  }\n  else {\n    state.smoothEnd = true\n    state.xe = modifierResult.delta.x\n    state.ye = modifierResult.delta.y\n\n    state.sx = state.sy = 0\n\n    state.i = raf.request(() => smothEndTick(interaction))\n  }\n\n  return false\n}\n\nfunction stop ({ interaction }) {\n  const state = interaction.inertia\n\n  if (state.active) {\n    raf.cancel(state.i)\n    state.active = false\n    interaction.simulation = null\n  }\n}\n\nfunction calcInertia (interaction, state) {\n  const options = getOptions(interaction)\n  const lambda = options.resistance\n  const inertiaDur = -Math.log(options.endSpeed / state.v0) / lambda\n\n  state.x0 = interaction.prevEvent.page.x\n  state.y0 = interaction.prevEvent.page.y\n  state.t0 = state.startEvent.timeStamp / 1000\n  state.sx = state.sy = 0\n\n  state.modifiedXe = state.xe = (state.vx0 - inertiaDur) / lambda\n  state.modifiedYe = state.ye = (state.vy0 - inertiaDur) / lambda\n  state.te = inertiaDur\n\n  state.lambda_v0 = lambda / state.v0\n  state.one_ve_v0 = 1 - options.endSpeed / state.v0\n}\n\nfunction inertiaTick (interaction) {\n  updateInertiaCoords(interaction)\n  utils.pointer.setCoordDeltas(interaction.coords.delta, interaction.coords.prev, interaction.coords.cur)\n  utils.pointer.setCoordVelocity(interaction.coords.velocity, interaction.coords.delta)\n\n  const state = interaction.inertia\n  const options = getOptions(interaction)\n  const lambda = options.resistance\n  const t = new Date().getTime() / 1000 - state.t0\n\n  if (t < state.te) {\n    const progress =  1 - (Math.exp(-lambda * t) - state.lambda_v0) / state.one_ve_v0\n\n    if (state.modifiedXe === state.xe && state.modifiedYe === state.ye) {\n      state.sx = state.xe * progress\n      state.sy = state.ye * progress\n    }\n    else {\n      const quadPoint = utils.getQuadraticCurvePoint(\n        0, 0,\n        state.xe, state.ye,\n        state.modifiedXe, state.modifiedYe,\n        progress)\n\n      state.sx = quadPoint.x\n      state.sy = quadPoint.y\n    }\n\n    interaction.move()\n\n    state.i = raf.request(() => inertiaTick(interaction))\n  }\n  else {\n    state.sx = state.modifiedXe\n    state.sy = state.modifiedYe\n\n    interaction.move()\n    interaction.end(state.startEvent)\n    state.active = false\n    interaction.simulation = null\n  }\n\n  utils.pointer.copyCoords(interaction.coords.prev, interaction.coords.cur)\n}\n\nfunction smothEndTick (interaction) {\n  updateInertiaCoords(interaction)\n\n  const state = interaction.inertia\n  const t = new Date().getTime() - state.t0\n  const { smoothEndDuration: duration } = getOptions(interaction)\n\n  if (t < duration) {\n    state.sx = utils.easeOutQuad(t, 0, state.xe, duration)\n    state.sy = utils.easeOutQuad(t, 0, state.ye, duration)\n\n    interaction.move()\n\n    state.i = raf.request(() => smothEndTick(interaction))\n  }\n  else {\n    state.sx = state.xe\n    state.sy = state.ye\n\n    interaction.move()\n    interaction.end(state.startEvent)\n\n    state.smoothEnd =\n      state.active = false\n    interaction.simulation = null\n  }\n}\n\nfunction updateInertiaCoords (interaction) {\n  const state = interaction.inertia\n\n  // return if inertia isn't running\n  if (!state.active) { return }\n\n  const pageUp   = state.upCoords.page\n  const clientUp = state.upCoords.client\n\n  utils.pointer.setCoords(interaction.coords.cur, [ {\n    pageX  : pageUp.x   + state.sx,\n    pageY  : pageUp.y   + state.sy,\n    clientX: clientUp.x + state.sx,\n    clientY: clientUp.y + state.sy,\n  } ])\n}\n\nfunction getOptions ({ target, prepared }) {\n  return target && target.options && prepared.name && target.options[prepared.name].inertia\n}\n\nexport default {\n  install,\n  calcInertia,\n  inertiaTick,\n  smothEndTick,\n  updateInertiaCoords,\n}\n","import * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport normalize, { NormalizedListeners } from '@interactjs/utils/normalizeListeners'\nimport InteractEvent from './InteractEvent'\n\nfunction fireUntilImmediateStopped (event: InteractEvent, listeners: Interact.Listener[]) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) { break }\n\n    listener(event)\n  }\n}\n\nclass Eventable {\n  options: any\n  types: NormalizedListeners = {}\n  propagationStopped = false\n  immediatePropagationStopped = false\n  global: any\n\n  constructor (options?: { [index: string]: any }) {\n    this.options = extend({}, options || {})\n  }\n\n  fire (event: any) {\n    let listeners\n    const global = this.global\n\n    // Interactable#on() listeners\n    // tslint:disable no-conditional-assignment\n    if ((listeners = this.types[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type]))  {\n      fireUntilImmediateStopped(event, listeners)\n    }\n  }\n\n  on (type: string, listener: Interact.ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      this.types[type] = arr.merge(this.types[type] || [], listeners[type])\n    }\n  }\n\n  off (type: string, listener: Interact.ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      const eventList = this.types[type]\n\n      if (!eventList || !eventList.length) { continue }\n\n      for (const subListener of listeners[type]) {\n        const index = eventList.indexOf(subListener)\n\n        if (index !== -1) {\n          eventList.splice(index, 1)\n        }\n      }\n    }\n  }\n}\n\nexport default Eventable\n","import * as utils from './index'\n\nconst finder = {\n  methodOrder: [ 'simulationResume', 'mouseOrPen', 'hasPointer', 'idle' ],\n\n  search (details) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume ({ pointerType, eventType, eventTarget, scope }) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget\n\n      if (interaction.simulation && interaction.simulation.allowResume &&\n          (interaction.pointerType === pointerType)) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = utils.dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen ({ pointerId, pointerType, eventType, scope }) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) { continue }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer ({ pointerId, scope }) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle ({ pointerType, scope }) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.target\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !target.options.gesture.enabled) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && (pointerType === interaction.pointerType)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId (interaction, pointerId) {\n  return utils.arr.some(interaction.pointers, ({ id }) => id === pointerId)\n}\n\nexport default finder\n","import browser from '@interactjs/utils/browser'\nimport domObjects from '@interactjs/utils/domObjects'\nimport events from '@interactjs/utils/events'\nimport finder from '@interactjs/utils/interactionFinder'\nimport pointerUtils from '@interactjs/utils/pointerUtils'\nimport Signals from '@interactjs/utils/Signals'\nimport InteractionBase from './Interaction'\nimport { Scope } from './scope'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    Interaction: typeof InteractionBase\n    interactions: {\n      signals: Signals\n      new: (options: any) => InteractionBase\n      list: InteractionBase[]\n      listeners: { [type: string]: Interact.Listener }\n      eventMap: any\n      pointerMoveTolerance: number\n    }\n    actions: Actions\n    prevTouchTime: number\n  }\n\n  interface Actions {\n    names: string[]\n    methodDict: { [key: string]: string }\n    eventTypes: string[]\n  }\n}\n\nconst methodNames = [\n  'pointerDown', 'pointerMove', 'pointerUp',\n  'updatePointer', 'removePointer', 'windowBlur',\n]\n\nfunction install (scope: Scope) {\n  const signals = new Signals()\n\n  const listeners = {} as any\n\n  for (const method of methodNames) {\n    listeners[method] = doOnInteractions(method, scope)\n  }\n\n  const pEventTypes = browser.pEventTypes\n  const eventMap = {} as { [key: string]: Interact.Listener }\n\n  if (domObjects.PointerEvent) {\n    eventMap[pEventTypes.down  ] = listeners.pointerDown\n    eventMap[pEventTypes.move  ] = listeners.pointerMove\n    eventMap[pEventTypes.up    ] = listeners.pointerUp\n    eventMap[pEventTypes.cancel] = listeners.pointerUp\n  }\n  else {\n    eventMap.mousedown   = listeners.pointerDown\n    eventMap.mousemove   = listeners.pointerMove\n    eventMap.mouseup     = listeners.pointerUp\n\n    eventMap.touchstart  = listeners.pointerDown\n    eventMap.touchmove   = listeners.pointerMove\n    eventMap.touchend    = listeners.pointerUp\n    eventMap.touchcancel = listeners.pointerUp\n  }\n\n  eventMap.blur = (event) => {\n    for (const interaction of scope.interactions.list) {\n      interaction.documentBlur(event)\n    }\n  }\n\n  scope.signals.on('add-document', onDocSignal)\n  scope.signals.on('remove-document', onDocSignal)\n\n  // for ignoring browser's simulated mouse events\n  scope.prevTouchTime = 0\n\n  scope.Interaction = class Interaction extends InteractionBase {\n    get pointerMoveTolerance () {\n      return scope.interactions.pointerMoveTolerance\n    }\n\n    set pointerMoveTolerance (value) {\n      scope.interactions.pointerMoveTolerance = value\n    }\n  }\n  scope.interactions = {\n    signals,\n    // all active and idle interactions\n    list: [],\n    new (options) {\n      options.signals = signals\n\n      return new scope.Interaction(options)\n    },\n    listeners,\n    eventMap,\n    pointerMoveTolerance: 1,\n  }\n\n  scope.actions = {\n    names: [],\n    methodDict: {},\n    eventTypes: [],\n  }\n}\n\nfunction doOnInteractions (method, scope) {\n  return function (event) {\n    const interactions = scope.interactions.list\n\n    const pointerType = pointerUtils.getPointerType(event)\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\n    const matches = [] // [ [pointer, interaction], ...]\n\n    if (browser.supportsTouch && /touch/.test(event.type)) {\n      scope.prevTouchTime = new Date().getTime()\n\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch\n        const pointerId = pointerUtils.getPointerId(pointer)\n        const searchDetails = {\n          pointer,\n          pointerId,\n          pointerType,\n          eventType: event.type,\n          eventTarget,\n          curEventTarget,\n          scope,\n        }\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n    else {\n      let invalidPointer = false\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < interactions.length && !invalidPointer; i++) {\n          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer ||\n          (new Date().getTime() - scope.prevTouchTime < 500) ||\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          event.timeStamp === 0\n      }\n\n      if (!invalidPointer) {\n        const searchDetails = {\n          pointer: event,\n          pointerId: pointerUtils.getPointerId(event),\n          pointerType,\n          eventType: event.type,\n          curEventTarget,\n          eventTarget,\n          scope,\n        }\n\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n\n    // eslint-disable-next-line no-shadow\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\n      interaction[method](pointer, event, eventTarget, curEventTarget)\n    }\n  }\n}\n\nfunction getInteraction (searchDetails) {\n  const { pointerType, scope } = searchDetails\n\n  const foundInteraction = finder.search(searchDetails)\n  const signalArg = { interaction: foundInteraction, searchDetails }\n\n  scope.interactions.signals.fire('find', signalArg)\n\n  return signalArg.interaction || newInteraction({ pointerType }, scope)\n}\n\nexport function newInteraction (options, scope) {\n  const interaction = scope.interactions.new(options)\n\n  scope.interactions.list.push(interaction)\n  return interaction\n}\n\nfunction onDocSignal ({ doc, scope, options }, signalName) {\n  const { eventMap } = scope.interactions\n  const eventMethod = signalName.indexOf('add') === 0\n    ? events.add : events.remove\n\n  if (scope.browser.isIOS && !options.events) {\n    options.events = { passive: false }\n  }\n\n  // delegate event listener\n  for (const eventType in events.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener)\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\n  }\n\n  const eventOptions = options && options.events\n\n  for (const eventType in eventMap) {\n    eventMethod(doc, eventType, eventMap[eventType], eventOptions)\n  }\n}\n\nexport default {\n  install,\n  onDocSignal,\n  doOnInteractions,\n  newInteraction,\n  methodNames,\n}\n","import * as utils from '@interactjs/utils'\nimport domObjects from '@interactjs/utils/domObjects'\nimport defaults from './defaultOptions'\nimport Eventable from './Eventable'\nimport InteractableBase from './Interactable'\nimport InteractEvent from './InteractEvent'\nimport interactions from './interactions'\n\nconst {\n  win,\n  browser,\n  raf,\n  Signals,\n  events,\n} = utils\n\nexport type Defaults = typeof defaults\n\nexport function createScope () {\n  return new Scope()\n}\n\nexport class Scope {\n  // FIXME Signals\n  signals = new Signals()\n  browser = browser\n  events = events\n  utils = utils\n  defaults: Defaults = utils.clone(defaults) as Defaults\n  Eventable = Eventable\n  actions: Actions = {\n    names: [],\n    methodDict: {},\n    eventTypes: [],\n  }\n\n  InteractEvent = InteractEvent\n  Interactable!: typeof InteractableBase\n  interactables = new InteractableSet(this)\n\n  // main window\n  _win!: Window\n\n  // main document\n  document!: Document\n\n  // all documents being listened to\n  documents: Array<{ doc: Document, options: any }> = []\n\n  constructor () {\n    const scope = this as Scope;\n\n    (this as { Interactable: typeof InteractableBase }).Interactable = class Interactable extends InteractableBase implements InteractableBase {\n      get _defaults () { return scope.defaults }\n\n      set (options: any) {\n        super.set(options)\n\n        scope.interactables.signals.fire('set', {\n          options,\n          interactable: this,\n        })\n\n        return this\n      }\n\n      unset () {\n        super.unset()\n        scope.interactables.signals.fire('unset', { interactable: this })\n      }\n    }\n  }\n\n  init (window: Window) {\n    return initScope(this, window)\n  }\n\n  addDocument (doc: Document, options?: any): void | false {\n    // do nothing if document is already known\n    if (this.getDocIndex(doc) !== -1) { return false }\n\n    const window = win.getWindow(doc)\n\n    options = options ? utils.extend({}, options) : {}\n\n    this.documents.push({ doc, options })\n    events.documents.push(doc)\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== this.document) {\n      events.add(window, 'unload', this.onWindowUnload)\n    }\n\n    this.signals.fire('add-document', { doc, window, scope: this, options })\n  }\n\n  removeDocument (doc: Document) {\n    const index = this.getDocIndex(doc)\n\n    const window = win.getWindow(doc)\n    const options = this.documents[index].options\n\n    events.remove(window, 'unload', this.onWindowUnload)\n\n    this.documents.splice(index, 1)\n    events.documents.splice(index, 1)\n\n    this.signals.fire('remove-document', { doc, window, scope: this, options })\n  }\n\n  onWindowUnload (event: Event) {\n    this.removeDocument(event.target as Document)\n  }\n\n  getDocIndex (doc: Document) {\n    for (let i = 0; i < this.documents.length; i++) {\n      if (this.documents[i].doc === doc) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getDocOptions (doc: Document) {\n    const docIndex = this.getDocIndex(doc)\n\n    return docIndex === -1 ? null : this.documents[docIndex].options\n  }\n}\n\nclass InteractableSet {\n  signals = new utils.Signals()\n\n  // all set interactables\n  list: InteractableBase[] = []\n\n  constructor (protected scope: Scope) {}\n\n  new (target: Interact.Target, options: any): InteractableBase {\n    options = utils.extend(options || {}, {\n      actions: this.scope.actions,\n    })\n    const interactable = new this.scope.Interactable(target, options, this.scope.document)\n\n    this.scope.addDocument(interactable._doc)\n    this.list.push(interactable)\n\n    this.signals.fire('new', {\n      target,\n      options,\n      interactable,\n      win: this.scope._win,\n    })\n\n    return interactable\n  }\n\n  indexOfElement (target: Interact.Target, context: Document | Element) {\n    context = context || this.scope.document\n\n    const list = this.list\n\n    for (let i = 0; i < list.length; i++) {\n      const interactable = list[i]\n\n      if (interactable.target === target && interactable._context === context) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  get (element: Interact.Target, options, dontCheckInContext?: boolean) {\n    const ret = this.list[this.indexOfElement(element, options && options.context)]\n\n    return ret && (utils.is.string(element) || dontCheckInContext || ret.inContext(element)) ? ret : null\n  }\n\n  forEachMatch (element: Document | Element, callback: (interactable: any) => any) {\n    for (const interactable of this.list) {\n      let ret\n\n      if ((utils.is.string(interactable.target)\n      // target is a selector and the element matches\n        ? (utils.is.element(element) && utils.dom.matchesSelector(element, interactable.target))\n        // target is the element\n        : element === interactable.target) &&\n        // the element is in context\n        (interactable.inContext(element))) {\n        ret = callback(interactable)\n      }\n\n      if (ret !== undefined) {\n        return ret\n      }\n    }\n  }\n}\n\nexport function initScope (scope: Scope, window: Window) {\n  win.init(window)\n  domObjects.init(window)\n  browser.init(window)\n  raf.init(window)\n  events.init(window)\n\n  interactions.install(scope)\n  scope.document = window.document\n\n  return scope\n}\n","/** @module interact */\n\nimport { Options } from '@interactjs/core/defaultOptions'\nimport Interactable from '@interactjs/core/Interactable'\nimport { Scope } from '@interactjs/core/scope'\nimport * as utils from '@interactjs/utils'\nimport browser from '@interactjs/utils/browser'\nimport events from '@interactjs/utils/events'\n\nexport interface Plugin extends Partial<any> {\n  install (scope: Scope): void\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    interact: InteractStatic\n    _plugins: Plugin[]\n  }\n}\n\nexport interface InteractStatic {\n  (target: Interact.Target, options?: Options): Interactable\n  on: typeof on\n  pointerMoveTolerance: typeof pointerMoveTolerance\n  stop: typeof stop\n  supportsPointerEvent: typeof supportsPointerEvent\n  supportsTouch: typeof supportsTouch\n  debug: typeof debug\n  off: typeof off\n  isSet: typeof isSet\n  use: typeof use\n  getPointerAverage: typeof utils.pointer.pointerAverage\n  getTouchBBox: typeof utils.pointer.touchBBox\n  getTouchDistance: typeof utils.pointer.touchDistance\n  getTouchAngle: typeof utils.pointer.touchAngle\n  getElementRect: typeof utils.dom.getElementRect\n  getElementClientRect: typeof utils.dom.getElementClientRect\n  matchesSelector: typeof utils.dom.matchesSelector\n  closest: typeof utils.dom.closest\n  addDocument: typeof scope.addDocument\n  removeDocument: typeof scope.removeDocument\n  version: string\n}\n\nconst globalEvents: any = {}\nconst scope = new Scope()\n\n/**\n * ```js\n * interact('#draggable').draggable(true)\n *\n * var rectables = interact('rect')\n * rectables\n *   .gesturable(true)\n *   .on('gesturemove', function (event) {\n *       // ...\n *   })\n * ```\n *\n * The methods of this variable can be used to set elements as interactables\n * and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to configure\n * it.\n *\n * @global\n *\n * @param {Element | string} target The HTML or SVG Element to interact with\n * or CSS selector\n * @return {Interactable}\n */\nexport const interact: InteractStatic = function interact (target: Interact.Target, options?: any) {\n  let interactable = scope.interactables.get(target, options)\n\n  if (!interactable) {\n    interactable = scope.interactables.new(target, options)\n    interactable.events.global = globalEvents\n  }\n\n  return interactable\n} as InteractStatic\n\nscope._plugins = []\n\n/**\n * Use a plugin\n *\n * @alias module:interact.use\n *\n * @param {Object} plugin\n * @param {function} plugin.install\n * @return {interact}\n */\ninteract.use = use\nfunction use (plugin: Plugin) {\n  if (scope._plugins.indexOf(plugin) !== -1) {\n    return interact\n  }\n\n  plugin.install(scope)\n  scope._plugins.push(plugin)\n  return interact\n}\n\n/**\n * Check if an element or selector has been set with the {@link interact}\n * function\n *\n * @alias module:interact.isSet\n *\n * @param {Element} element The Element being searched for\n * @return {boolean} Indicates if the element or CSS selector was previously\n * passed to interact\n */\ninteract.isSet = isSet\nfunction isSet (element: Element, options?: any) {\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1\n}\n\n/**\n * Add a global listener for an InteractEvent or adds a DOM event to `document`\n *\n * @alias module:interact.on\n *\n * @param {string | array | object} type The types of events to listen for\n * @param {function} listener The function event (s)\n * @param {object | boolean} [options] object or useCapture flag for\n * addEventListener\n * @return {object} interact\n */\ninteract.on = on\nfunction on (type: string | Interact.EventTypes, listener: Interact.ListenersArg, options?) {\n  if (utils.is.string(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/)\n  }\n\n  if (utils.is.array(type)) {\n    for (const eventType of (type as any[])) {\n      interact.on(eventType, listener, options)\n    }\n\n    return interact\n  }\n\n  if (utils.is.object(type)) {\n    for (const prop in type) {\n      interact.on(prop, (type as Interact.EventTypes)[prop], listener)\n    }\n\n    return interact\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.arr.contains(scope.actions.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!globalEvents[type]) {\n      globalEvents[type] = [listener]\n    }\n    else {\n      globalEvents[type].push(listener)\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n    events.add(scope.document, type, listener as Interact.Listener, { options })\n  }\n\n  return interact\n}\n\n/**\n * Removes a global InteractEvent listener or DOM event from `document`\n *\n * @alias module:interact.off\n *\n * @param {string | array | object} type The types of events that were listened\n * for\n * @param {function} listener The listener function to be removed\n * @param {object | boolean} options [options] object or useCapture flag for\n * removeEventListener\n * @return {object} interact\n */\ninteract.off = off\nfunction off (type, listener, options) {\n  if (utils.is.string(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/)\n  }\n\n  if (utils.is.array(type)) {\n    for (const eventType of type) {\n      interact.off(eventType, listener, options)\n    }\n\n    return interact\n  }\n\n  if (utils.is.object(type)) {\n    for (const prop in type) {\n      interact.off(prop, type[prop], listener)\n    }\n\n    return interact\n  }\n\n  if (!utils.arr.contains(scope.actions.eventTypes, type)) {\n    events.remove(scope.document, type, listener, options)\n  }\n  else {\n    let index\n\n    if (type in globalEvents &&\n        (index = globalEvents[type].indexOf(listener)) !== -1) {\n      globalEvents[type].splice(index, 1)\n    }\n  }\n\n  return interact\n}\n\n/**\n * Returns an object which exposes internal data\n * @alias module:interact.debug\n *\n * @return {object} An object with properties that outline the current state\n * and expose internal functions and variables\n */\ninteract.debug = debug\nfunction debug () {\n  return scope\n}\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage  = utils.pointer.pointerAverage\ninteract.getTouchBBox       = utils.pointer.touchBBox\ninteract.getTouchDistance   = utils.pointer.touchDistance\ninteract.getTouchAngle      = utils.pointer.touchAngle\n\ninteract.getElementRect       = utils.dom.getElementRect\ninteract.getElementClientRect = utils.dom.getElementClientRect\ninteract.matchesSelector      = utils.dom.matchesSelector\ninteract.closest              = utils.dom.closest\n\n/**\n * @alias module:interact.supportsTouch\n *\n * @return {boolean} Whether or not the browser supports touch input\n */\ninteract.supportsTouch = supportsTouch\nfunction supportsTouch () {\n  return browser.supportsTouch\n}\n\n/**\n * @alias module:interact.supportsPointerEvent\n *\n * @return {boolean} Whether or not the browser supports PointerEvents\n */\ninteract.supportsPointerEvent = supportsPointerEvent\nfunction supportsPointerEvent () {\n  return browser.supportsPointerEvent\n}\n\n/**\n * Cancels all interactions (end events are not fired)\n *\n * @alias module:interact.stop\n *\n * @return {object} interact\n */\ninteract.stop = stop\nfunction stop () {\n  for (const interaction of scope.interactions.list) {\n    interaction.stop()\n  }\n\n  return interact\n}\n\n/**\n * Returns or sets the distance the pointer must be moved before an action\n * sequence occurs. This also affects tolerance for tap events.\n *\n * @alias module:interact.pointerMoveTolerance\n *\n * @param {number} [newValue] The movement from the start position must be greater than this value\n * @return {interact | number}\n */\ninteract.pointerMoveTolerance = pointerMoveTolerance\nfunction pointerMoveTolerance (newValue) {\n  if (utils.is.number(newValue)) {\n    scope.interactions.pointerMoveTolerance = newValue\n\n    return interact\n  }\n\n  return scope.interactions.pointerMoveTolerance\n}\n\nscope.interactables.signals.on('unset', ({ interactable }) => {\n  scope.interactables.list.splice(scope.interactables.list.indexOf(interactable), 1)\n\n  // Stop related interactions when an Interactable is unset\n  for (const interaction of scope.interactions.list) {\n    if (interaction.target === interactable && interaction.interacting() && interaction._ending) {\n      interaction.stop()\n    }\n  }\n})\n\ninteract.addDocument    = scope.addDocument\ninteract.removeDocument = scope.removeDocument\n\nscope.interact = interact\n\nexport { scope }\nexport default interact\n","import * as is from '@interactjs/utils/is'\nimport rectUtils from '@interactjs/utils/rect'\n\nfunction start ({ rect, startOffset, state }) {\n  const { options } = state\n  const { elementRect } = options\n  const offset = {} as { [key: string]: number }\n\n  if (rect && elementRect) {\n    offset.left = startOffset.left - (rect.width  * elementRect.left)\n    offset.top  = startOffset.top  - (rect.height * elementRect.top)\n\n    offset.right  = startOffset.right  - (rect.width  * (1 - elementRect.right))\n    offset.bottom = startOffset.bottom - (rect.height * (1 - elementRect.bottom))\n  }\n  else {\n    offset.left = offset.top = offset.right = offset.bottom = 0\n  }\n\n  state.offset = offset\n}\n\nfunction set ({ coords, interaction, state }) {\n  const { options, offset } = state\n\n  const restriction = getRestrictionRect(options.restriction, interaction, coords)\n\n  if (!restriction) { return state }\n\n  const rect = restriction\n\n  // object is assumed to have\n  // x, y, width, height or\n  // left, top, right, bottom\n  if ('x' in restriction && 'y' in restriction) {\n    coords.x = Math.max(Math.min(rect.x + rect.width  - offset.right, coords.x), rect.x + offset.left)\n    coords.y = Math.max(Math.min(rect.y + rect.height - offset.bottom, coords.y), rect.y + offset.top)\n  }\n  else {\n    coords.x = Math.max(Math.min(rect.right  - offset.right, coords.x), rect.left + offset.left)\n    coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top  + offset.top)\n  }\n}\n\nfunction getRestrictionRect (value, interaction, coords?: Interact.Point) {\n  if (is.func(value)) {\n    return rectUtils.resolveRectLike(value, interaction.target, interaction.element, [coords.x, coords.y, interaction])\n  } else {\n    return rectUtils.resolveRectLike(value, interaction.target, interaction.element)\n  }\n}\n\nconst restrict = {\n  start,\n  set,\n  getRestrictionRect,\n  defaults: {\n    enabled: false,\n    restriction: null,\n    elementRect: null,\n  },\n}\n\nexport default restrict\n","// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n//   },\n// });\n\nimport Interaction from '@interactjs/core/Interaction'\nimport extend from '@interactjs/utils/extend'\nimport rectUtils from '@interactjs/utils/rect'\nimport restrict from './pointer'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Action {\n    linkedEdges?: { [key: string]: boolean }\n  }\n}\n\nconst { getRestrictionRect } = restrict\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity }\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity }\n\nfunction start ({ interaction, state }: { interaction: Interaction, state: any }) {\n  const { options } = state\n  const startOffset = interaction.modifiers.startOffset\n  let offset\n\n  if (options) {\n    const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page)\n\n    offset = rectUtils.rectToXY(offsetRect)\n  }\n\n  offset = offset || { x: 0, y: 0 }\n\n  state.offset = {\n    top:    offset.y + startOffset.top,\n    left:   offset.x + startOffset.left,\n    bottom: offset.y - startOffset.bottom,\n    right:  offset.x - startOffset.right,\n  }\n}\n\nfunction set ({ coords, interaction, state }: {\n  coords: Interact.Point,\n  interaction: Interaction,\n  state: any\n}) {\n  const { offset, options } = state\n  const edges = interaction.prepared.linkedEdges || interaction.prepared.edges\n\n  if (!edges) {\n    return\n  }\n\n  const page = extend({}, coords)\n  const inner = getRestrictionRect(options.inner, interaction, page) || {}\n  const outer = getRestrictionRect(options.outer, interaction, page) || {}\n\n  fixRect(inner, noInner)\n  fixRect(outer, noOuter)\n\n  if (edges.top) {\n    coords.y = Math.min(Math.max(outer.top    + offset.top,    page.y), inner.top    + offset.top)\n  }\n  else if (edges.bottom) {\n    coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom)\n  }\n  if (edges.left) {\n    coords.x = Math.min(Math.max(outer.left   + offset.left,   page.x), inner.left   + offset.left)\n  }\n  else if (edges.right) {\n    coords.x = Math.max(Math.min(outer.right  + offset.right,  page.x), inner.right  + offset.right)\n  }\n}\n\nfunction fixRect (rect, defaults) {\n  for (const edge of ['top', 'left', 'bottom', 'right']) {\n    if (!(edge in rect)) {\n      rect[edge] = defaults[edge]\n    }\n  }\n\n  return rect\n}\n\nconst restrictEdges = {\n  noInner,\n  noOuter,\n  getRestrictionRect,\n  start,\n  set,\n  defaults: {\n    enabled: false,\n    inner: null,\n    outer: null,\n    offset: null,\n  },\n}\n\nexport default restrictEdges\n","// This module adds the options.resize.restrictSize setting which sets min and\n// max width and height for the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictSize: {\n//     min: { width: -600, height: -600 },\n//     max: { width:  600, height:  600 },\n//   },\n// });\n\nimport extend from '@interactjs/utils/extend'\nimport rectUtils from '@interactjs/utils/rect'\nimport restrictEdges from './edges'\n\nconst noMin = { width: -Infinity, height: -Infinity }\nconst noMax = { width: +Infinity, height: +Infinity }\n\nfunction start (arg) {\n  return restrictEdges.start(arg)\n}\n\nfunction set (arg) {\n  const { interaction, state } = arg\n  const { options } = state\n  const edges = interaction.prepared.linkedEdges || interaction.prepared.edges\n\n  if (!edges) {\n    return\n  }\n\n  const rect = rectUtils.xywhToTlbr(interaction.resizeRects.inverted)\n\n  const minSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.min, interaction)) || noMin\n  const maxSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.max, interaction)) || noMax\n\n  state.options = {\n    enabled: options.enabled,\n    endOnly: options.endOnly,\n    inner: extend({}, restrictEdges.noInner),\n    outer: extend({}, restrictEdges.noOuter),\n  }\n\n  if (edges.top) {\n    state.options.inner.top = rect.bottom - minSize.height\n    state.options.outer.top = rect.bottom - maxSize.height\n  }\n  else if (edges.bottom) {\n    state.options.inner.bottom = rect.top + minSize.height\n    state.options.outer.bottom = rect.top + maxSize.height\n  }\n  if (edges.left) {\n    state.options.inner.left = rect.right - minSize.width\n    state.options.outer.left = rect.right - maxSize.width\n  }\n  else if (edges.right) {\n    state.options.inner.right = rect.left + minSize.width\n    state.options.outer.right = rect.left + maxSize.width\n  }\n\n  restrictEdges.set(arg)\n\n  state.options = options\n}\n\nconst restrictSize = {\n  start,\n  set,\n  defaults: {\n    enabled: false,\n    min: null,\n    max: null,\n  },\n}\n\nexport default restrictSize\n","import * as utils from '@interactjs/utils'\n\nfunction start ({ interaction, interactable, element, rect, state, startOffset }) {\n  const { options } = state\n  const offsets = []\n  const optionsOrigin = utils.rect.rectToXY(utils.rect.resolveRectLike(options.origin))\n  const origin = optionsOrigin || utils.getOriginXY(interactable, element, interaction.prepared.name)\n\n  let snapOffset\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x - origin.x,\n      y: interaction.coords.start.page.y - origin.y,\n    }\n  }\n  else  {\n    const offsetRect = utils.rect.resolveRectLike(options.offset, interactable, element, [interaction])\n\n    snapOffset = utils.rect.rectToXY(offsetRect) || { x: 0, y: 0 }\n  }\n\n  const relativePoints = options.relativePoints || []\n\n  if (rect && options.relativePoints && options.relativePoints.length) {\n    for (let index = 0; index < relativePoints.length; index++) {\n      const relativePoint = relativePoints[index]\n\n      offsets.push({\n        index,\n        relativePoint,\n        x: startOffset.left - (rect.width  * relativePoint.x) + snapOffset.x,\n        y: startOffset.top  - (rect.height * relativePoint.y) + snapOffset.y,\n      })\n    }\n  }\n  else {\n    offsets.push(utils.extend({\n      index: 0,\n      relativePoint: null,\n    }, snapOffset))\n  }\n\n  state.offsets = offsets\n}\n\nfunction set ({ interaction, coords, state }) {\n  const { options, offsets } = state\n\n  const origin = utils.getOriginXY(interaction.target, interaction.element, interaction.prepared.name)\n  const page = utils.extend({}, coords)\n  const targets = []\n  let target\n  let i\n\n  page.x -= origin.x\n  page.y -= origin.y\n\n  state.realX = page.x\n  state.realY = page.y\n\n  let len = options.targets ? options.targets.length : 0\n\n  for (const offset of offsets) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0; index < options.targets.length; index++) {\n      const snapTarget = options.targets[index]\n      if (utils.is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction, offset, index)\n      }\n      else {\n        target = snapTarget\n      }\n\n      if (!target) { continue }\n\n      targets.push({\n        x: utils.is.number(target.x) ? (target.x + offset.x) : relativeX,\n        y: utils.is.number(target.y) ? (target.y + offset.y) : relativeY,\n\n        range: utils.is.number(target.range) ? target.range : options.range,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    dx: 0,\n    dy: 0,\n  }\n\n  for (i = 0, len = targets.length; i < len; i++) {\n    target = targets[i]\n\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = utils.hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (!closest.target || (inRange\n      // is the closest target in range?\n      ? (closest.inRange && range !== Infinity\n        // the pointer is relatively deeper in this target\n        ? distance / range < closest.distance / closest.range\n        // this target has Infinite range and the closest doesn't\n        : (range === Infinity && closest.range !== Infinity) ||\n          // OR this target is closer that the previous closest\n          distance < closest.distance)\n      // The other is not in range and the pointer is closer to this target\n      : (!closest.inRange && distance < closest.distance))) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.dx = dx\n      closest.dy = dy\n\n      state.range = range\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n}\n\nconst snap = {\n  start,\n  set,\n  defaults: {\n    enabled: false,\n    range  : Infinity,\n    targets: null,\n    offset: null,\n\n    relativePoints: null,\n  },\n}\n\nexport default snap\n","// This module allows snapping of the size of targets during resize\n// interactions.\n\nimport extend from '@interactjs/utils/extend'\nimport * as is from '@interactjs/utils/is'\nimport snap from './pointer'\n\nfunction start (arg) {\n  const { interaction, state } = arg\n  const { options } = state\n  const edges = interaction.prepared.edges\n\n  if (!edges) { return null }\n\n  arg.state = {\n    options: {\n      relativePoints: [{\n        x: edges.left ? 0 : 1,\n        y: edges.top ? 0 : 1,\n      }],\n      origin: { x: 0, y: 0 },\n      offset: options.offset || 'self',\n      range: options.range,\n    },\n  }\n\n  state.targetFields = state.targetFields || [\n    ['width', 'height'],\n    ['x', 'y'],\n  ]\n\n  snap.start(arg)\n  state.offsets = arg.state.offsets\n\n  arg.state = state\n}\n\nfunction set (arg) {\n  const { interaction, state, coords } = arg\n  const { options, offsets } = state\n  const relative = {\n    x: coords.x - offsets[0].x,\n    y: coords.y - offsets[0].y,\n  }\n\n  state.options = extend({}, options)\n  state.options.targets = []\n\n  for (const snapTarget of (options.targets || [])) {\n    let target\n\n    if (is.func(snapTarget)) {\n      target = snapTarget(relative.x, relative.y, interaction)\n    }\n    else {\n      target = snapTarget\n    }\n\n    if (!target) { continue }\n\n    for (const [xField, yField] of state.targetFields) {\n      if (xField in target || yField in target) {\n        target.x = target[xField]\n        target.y = target[yField]\n\n        break\n      }\n    }\n\n    state.options.targets.push(target)\n  }\n\n  snap.set(arg)\n\n  state.options = options\n}\n\nconst snapSize = {\n  start,\n  set,\n  defaults: {\n    enabled: false,\n    range  : Infinity,\n    targets: null,\n    offset: null,\n  },\n}\n\nexport default snapSize\n","/**\n * @module modifiers/snapEdges\n *\n * @description\n * This module allows snapping of the edges of targets during resize\n * interactions.\n *\n * @example\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [interact.snappers.grid({ x: 100, y: 50 })],\n *   },\n * });\n *\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [\n *       interact.snappers.grid({\n *        top: 50,\n *        left: 50,\n *        bottom: 100,\n *        right: 100,\n *       }),\n *     ],\n *   },\n * });\n */\n\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\nimport snapSize from './size'\n\nfunction start (arg) {\n  const edges = arg.interaction.prepared.edges\n\n  if (!edges) { return null }\n\n  arg.state.targetFields = arg.state.targetFields || [\n    [edges.left ? 'left' : 'right', edges.top ? 'top' : 'bottom'],\n  ]\n\n  return snapSize.start(arg)\n}\n\nfunction set (arg) {\n  return snapSize.set(arg)\n}\n\nconst snapEdges = {\n  start,\n  set,\n  defaults: extend(clone(snapSize.defaults), {\n    offset: { x: 0, y: 0 },\n  }),\n}\n\nexport default snapEdges\n","import Eventable from '@interactjs/core/Eventable'\nimport Interaction from '@interactjs/core/Interaction'\nimport { Scope } from '@interactjs/core/scope'\nimport * as utils from '@interactjs/utils'\nimport PointerEvent from './PointerEvent'\n\ntype EventTargetList = Array<{\n  eventable: Eventable,\n  element: Window | Document | Element,\n  props: { [key: string]: any },\n}>\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    pointerEvents: typeof pointerEvents\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    prevTap?: PointerEvent<string>\n    tapTime?: number\n  }\n}\n\ndeclare module '@interactjs/core/PointerInfo' {\n  interface PointerInfo {\n    hold: {\n      duration: number\n      timeout: any\n    }\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    pointerEvents?: any\n  }\n}\n\nconst signals       = new utils.Signals()\nconst simpleSignals = [ 'down', 'up', 'cancel' ]\nconst simpleEvents  = [ 'down', 'up', 'cancel' ]\n\nconst pointerEvents = {\n  install,\n  signals,\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  createSignalListener,\n  defaults: {\n    holdDuration: 600,\n    ignoreFrom  : null,\n    allowFrom   : null,\n    origin      : { x: 0, y: 0 },\n  },\n  types: [\n    'down',\n    'move',\n    'up',\n    'cancel',\n    'tap',\n    'doubletap',\n    'hold',\n  ],\n}\n\nfunction fire<T extends string> (arg: {\n  interaction: Interaction,\n  pointer: Interact.PointerType,\n  event: Interact.PointerEventType,\n  eventTarget: EventTarget,\n  targets?: EventTargetList,\n  pointerEvent?: PointerEvent<T>,\n  type: T\n}) {\n  const {\n    interaction, pointer, event, eventTarget,\n    type = (arg as any).pointerEvent.type,\n    targets = collectEventTargets(arg),\n  } = arg\n\n  const {\n    pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction),\n  } = arg\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  }\n\n  for (let i = 0; i < targets.length; i++) {\n    const target = targets[i]\n\n    for (const prop in target.props || {}) {\n      (pointerEvent as any)[prop] = target.props[prop]\n    }\n\n    const origin = utils.getOriginXY(target.eventable, target.element)\n\n    pointerEvent.subtractOrigin(origin)\n    pointerEvent.eventable = target.eventable\n    pointerEvent.currentTarget = target.element\n\n    target.eventable.fire(pointerEvent)\n\n    pointerEvent.addOrigin(origin)\n\n    if (pointerEvent.immediatePropagationStopped ||\n        (pointerEvent.propagationStopped &&\n            (i + 1) < targets.length && targets[i + 1].element !== pointerEvent.currentTarget)) {\n      break\n    }\n  }\n\n  signals.fire('fired', signalArg)\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire({\n        interaction,\n        pointer,\n        event,\n        eventTarget,\n        type: 'doubletap',\n      })\n      : pointerEvent\n\n    interaction.prevTap = prevTap\n    interaction.tapTime = prevTap.timeStamp\n  }\n\n  return pointerEvent\n}\n\nfunction collectEventTargets<T extends string> ({ interaction, pointer, event, eventTarget, type }: {\n  interaction: Interaction,\n  pointer: Interact.PointerType,\n  event: Interact.PointerEventType,\n  eventTarget: EventTarget,\n  type: T\n}) {\n  const pointerIndex = interaction.getPointerIndex(pointer)\n  const pointerInfo = interaction.pointers[pointerIndex]\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (type === 'tap' && (interaction.pointerWasMoved ||\n      // or if the pointerup target is different to the pointerdown target\n      !(pointerInfo && pointerInfo.downTarget === eventTarget))) {\n    return []\n  }\n\n  const path = utils.dom.getPath(eventTarget)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [] as EventTargetList,\n    element: null,\n  }\n\n  for (const element of path) {\n    signalArg.element = element\n\n    signals.fire('collect-targets', signalArg)\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter((target) =>\n      target.eventable.options.holdDuration === interaction.pointers[pointerIndex].hold.duration)\n  }\n\n  return signalArg.targets\n}\n\nfunction install (scope: Scope) {\n  const {\n    interactions,\n  } = scope\n\n  scope.pointerEvents = pointerEvents\n  scope.defaults.actions.pointerEvents = pointerEvents.defaults\n\n  interactions.signals.on('new', (interaction) => {\n    interaction.prevTap    = null  // the most recent tap event on this interaction\n    interaction.tapTime    = 0     // time of the most recent tap event\n  })\n\n  interactions.signals.on('update-pointer', ({ down, pointerInfo }) => {\n    if (!down && pointerInfo.hold) {\n      return\n    }\n\n    pointerInfo.hold = { duration: Infinity, timeout: null }\n  })\n\n  interactions.signals.on('move', ({ interaction, pointer, event, eventTarget, duplicateMove }) => {\n    const pointerIndex = interaction.getPointerIndex(pointer)\n\n    if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n      if (interaction.pointerIsDown) {\n        clearTimeout(interaction.pointers[pointerIndex].hold.timeout)\n      }\n\n      fire({\n        interaction,\n        pointer,\n        event,\n        eventTarget,\n        type: 'move',\n      })\n    }\n  })\n\n  interactions.signals.on('down', ({ interaction, pointer, event, eventTarget, pointerIndex }) => {\n    const timer = interaction.pointers[pointerIndex].hold\n    const path = utils.dom.getPath(eventTarget)\n    const signalArg = {\n      interaction,\n      pointer,\n      event,\n      eventTarget,\n      type: 'hold',\n      targets: [] as EventTargetList,\n      path,\n      element: null,\n    }\n\n    for (const element of path) {\n      signalArg.element = element\n\n      signals.fire('collect-targets', signalArg)\n    }\n\n    if (!signalArg.targets.length) { return }\n\n    let minDuration = Infinity\n\n    for (const target of signalArg.targets) {\n      const holdDuration = target.eventable.options.holdDuration\n\n      if (holdDuration < minDuration) {\n        minDuration = holdDuration\n      }\n    }\n\n    timer.duration = minDuration\n    timer.timeout = setTimeout(() => {\n      fire({\n        interaction,\n        eventTarget,\n        pointer,\n        event,\n        type: 'hold',\n      })\n    }, minDuration)\n  })\n\n  interactions.signals.on('up', ({ interaction, pointer, event, eventTarget }) => {\n    if (!interaction.pointerWasMoved) {\n      fire({ interaction, eventTarget, pointer, event, type: 'tap' })\n    }\n  })\n\n  for (const signalName of ['up', 'cancel']) {\n    interactions.signals.on(signalName, ({ interaction, pointerIndex }) => {\n      if (interaction.pointers[pointerIndex].hold) {\n        clearTimeout(interaction.pointers[pointerIndex].hold.timeout)\n      }\n    })\n  }\n\n  for (let i = 0; i < simpleSignals.length; i++) {\n    interactions.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]))\n  }\n}\n\nfunction createSignalListener (type: string) {\n  return function ({ interaction, pointer, event, eventTarget }: any) {\n    fire({ interaction, eventTarget, pointer, event, type })\n  }\n}\n\nexport default pointerEvents\n","function install (scope) {\n  const {\n    pointerEvents,\n    interactions,\n  } = scope\n\n  pointerEvents.signals.on('new', onNew)\n  pointerEvents.signals.on('fired', (arg) => onFired(arg, pointerEvents))\n\n  for (const signal of ['move', 'up', 'cancel', 'endall']) {\n    interactions.signals.on(signal, endHoldRepeat)\n  }\n\n  // don't repeat by default\n  pointerEvents.defaults.holdRepeatInterval = 0\n  pointerEvents.types.push('holdrepeat')\n}\n\nfunction onNew ({ pointerEvent }) {\n  if (pointerEvent.type !== 'hold') { return }\n\n  pointerEvent.count = (pointerEvent.count || 0) + 1\n}\n\nfunction onFired ({ interaction, pointerEvent, eventTarget, targets }, pointerEvents) {\n  if (pointerEvent.type !== 'hold' || !targets.length) { return }\n\n  // get the repeat interval from the first eventable\n  const interval = targets[0].eventable.options.holdRepeatInterval\n\n  // don't repeat if the interval is 0 or less\n  if (interval <= 0) { return }\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(() => {\n    pointerEvents.fire({\n      interaction,\n      eventTarget,\n      type: 'hold',\n      pointer: pointerEvent,\n      event: pointerEvent,\n    })\n  }, interval)\n}\n\nfunction endHoldRepeat ({ interaction }) {\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle)\n    interaction.holdIntervalHandle = null\n  }\n}\n\nexport default {\n  install,\n}\n","import { Scope } from '@interactjs/core/scope'\nimport { merge } from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport * as is from '@interactjs/utils/is'\ntype Interactable = import ('@interactjs/core/Interactable').default\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    pointerEvents: typeof pointerEventsMethod\n    __backCompatOption: (optionName: string, newValue: any) => any\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    pointerEvents,\n    actions,\n    Interactable,\n    interactables,\n  } = scope\n\n  pointerEvents.signals.on('collect-targets', ({ targets, element, type, eventTarget }: any) => {\n    scope.interactables.forEachMatch(element, (interactable: Interactable) => {\n      const eventable = interactable.events\n      const options = eventable.options\n\n      if (\n        eventable.types[type] &&\n        eventable.types[type].length &&\n        is.element(element) &&\n        interactable.testIgnoreAllow(options, element, eventTarget)) {\n        targets.push({\n          element,\n          eventable,\n          props: { interactable },\n        })\n      }\n    })\n  })\n\n  interactables.signals.on('new', ({ interactable }) => {\n    interactable.events.getRect = function (element: Element) {\n      return interactable.getRect(element)\n    }\n  })\n\n  interactables.signals.on('set', ({ interactable, options }) => {\n    extend(interactable.events.options, pointerEvents.defaults)\n    extend(interactable.events.options, options.pointerEvents || {})\n  })\n\n  merge(actions.eventTypes, pointerEvents.types)\n\n  Interactable.prototype.pointerEvents = pointerEventsMethod\n\n  const __backCompatOption = Interactable.prototype._backCompatOption\n\n  Interactable.prototype._backCompatOption = function (optionName, newValue) {\n    const ret = __backCompatOption.call(this, optionName, newValue)\n\n    if (ret === this) {\n      this.events.options[optionName] = newValue\n    }\n\n    return ret\n  }\n}\n\nfunction pointerEventsMethod (this: Interactable, options: any) {\n  extend(this.events.options, options)\n\n  return this\n}\n\nexport default {\n  install,\n}\n","import pointerEvents from './base'\nimport holdRepeat from './holdRepeat'\nimport interactableTargets from './interactableTargets'\n\nfunction install (scope) {\n  pointerEvents.install(scope)\n  holdRepeat.install(scope)\n  interactableTargets.install(scope)\n}\n\nexport { pointerEvents, holdRepeat, interactableTargets, install }\n","import { Action, Interaction } from '@interactjs/core/Interaction'\nimport { newInteraction } from '@interactjs/core/interactions'\nimport { Scope } from '@interactjs/core/scope'\nimport { arr, extend, is, pointer as pointerUtils, rect as rectUtils, win } from '@interactjs/utils'\ntype Interactable = import ('@interactjs/core/Interactable').default\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    reflow: (action: Action) => ReturnType<typeof reflow>\n  }\n}\n\nexport function install (scope: Scope) {\n  const {\n    actions,\n    interactions,\n    /** @lends Interactable */\n    Interactable,\n  } = scope\n\n  // add action reflow event types\n  for (const actionName of actions.names) {\n    actions.eventTypes.push(`${actionName}reflow`)\n  }\n\n  // remove completed reflow interactions\n  interactions.signals.on('stop', ({ interaction }) => {\n    if (interaction.pointerType === 'reflow') {\n      interaction._reflowResolve()\n      arr.remove(scope.interactions.list, interaction)\n    }\n  })\n\n  /**\n   * ```js\n   * const interactable = interact(target);\n   * const drag = { name: drag, axis: 'x' };\n   * const resize = { name: resize, edges: { left: true, bottom: true };\n   *\n   * interactable.reflow(drag);\n   * interactable.reflow(resize);\n   * ```\n   *\n   * Start an action sequence to re-apply modifiers, check drops, etc.\n   *\n   * @param { Object } action The action to begin\n   * @param { string } action.name The name of the action\n   * @returns { Promise<Interactable> }\n   */\n  Interactable.prototype.reflow = function (action) {\n    return reflow(this, action, scope)\n  }\n}\n\nfunction reflow (interactable: Interactable, action: Action, scope: Scope) {\n  const elements = is.string(interactable.target)\n    ? arr.from(interactable._context.querySelectorAll(interactable.target))\n    : [interactable.target]\n\n  // tslint:disable-next-line variable-name\n  const Promise = (win.window as any).Promise\n  const promises: Array<Promise<null>> | null = Promise ? [] : null\n\n  for (const element of elements) {\n    const rect = interactable.getRect(element)\n\n    if (!rect) { break }\n\n    const runningInteraction = arr.find(\n      scope.interactions.list,\n      (interaction: Interaction) => {\n        return interaction.interacting() &&\n          interaction.target === interactable &&\n          interaction.element === element &&\n          interaction.prepared.name === action.name\n      })\n    let reflowPromise: Promise<null>\n\n    if (runningInteraction) {\n      runningInteraction.move()\n\n      reflowPromise = runningInteraction._reflowPromise || new Promise((resolve: any) => {\n        runningInteraction._reflowResolve = resolve\n      })\n    }\n    else {\n      const xywh = rectUtils.tlbrToXywh(rect)\n      const coords = {\n        page     : { x: xywh.x, y: xywh.y },\n        client   : { x: xywh.x, y: xywh.y },\n        timeStamp: Date.now(),\n      }\n\n      const event = pointerUtils.coordsToEvent(coords)\n      reflowPromise = startReflow(scope, interactable, element, action, event)\n    }\n\n    if (promises) {\n      promises.push(reflowPromise)\n    }\n  }\n\n  return promises && Promise.all(promises).then(() => interactable)\n}\n\nfunction startReflow (scope: Scope, interactable: Interactable, element: Element, action: Action, event: any) {\n  const interaction = newInteraction({ pointerType: 'reflow' }, scope)\n  const signalArg = {\n    interaction,\n    event,\n    pointer: event,\n    eventTarget: element,\n    phase: 'reflow',\n  }\n\n  interaction.target = interactable\n  interaction.element = element\n  interaction.prepared = extend({}, action)\n  interaction.prevEvent = event\n  interaction.updatePointer(event, event, element, true)\n\n  interaction._doPhase(signalArg)\n\n  const reflowPromise = (win.window as unknown as any).Promise\n    ? new (win.window as unknown as any).Promise((resolve: any) => {\n      interaction._reflowResolve = resolve\n    })\n    : null\n\n  interaction._reflowPromise = reflowPromise\n  interaction.start(action, interactable, element)\n\n  if (interaction._interacting) {\n    interaction.move(signalArg)\n    interaction.end(event)\n  }\n  else {\n    interaction.stop()\n  }\n\n  interaction.removePointer(event, event)\n  interaction.pointerIsDown = false\n\n  return reflowPromise\n}\n\nexport default { install }\n","import * as actions from '@interactjs/actions'\nimport autoScroll from '@interactjs/auto-scroll'\nimport * as autoStart from '@interactjs/auto-start'\nimport interactablePreventDefault from '@interactjs/core/interactablePreventDefault'\nimport inertia from '@interactjs/inertia'\nimport * as modifiers from '@interactjs/modifiers'\nimport modifiersBase from '@interactjs/modifiers/base'\nimport * as pointerEvents from '@interactjs/pointer-events'\nimport reflow from '@interactjs/reflow'\nimport interact, { scope } from './interact'\n\nexport function init (window: Window): typeof interact {\n  scope.init(window)\n\n  interact.use(interactablePreventDefault)\n\n  // inertia\n  interact.use(inertia)\n\n  // pointerEvents\n  interact.use(pointerEvents)\n\n  // autoStart, hold\n  interact.use(autoStart)\n\n  // drag and drop, resize, gesture\n  interact.use(actions)\n\n  // snap, resize, etc.\n  interact.use(modifiersBase)\n\n  // for backwrads compatibility\n  for (const type in modifiers) {\n    const { _defaults, _methods } = modifiers[type]\n\n    _defaults._methods = _methods\n    scope.defaults.perAction[type] = _defaults\n  }\n\n  // autoScroll\n  interact.use(autoScroll)\n\n  // reflow\n  interact.use(reflow)\n\n  return interact\n}\n\n// eslint-disable-next-line no-undef\ninteract.version = init.version = process.env.npm_package_version\n\nexport default interact\nexport {\n  interact,\n  actions,\n  autoScroll,\n  interactablePreventDefault,\n  inertia,\n  modifiersBase as modifiers,\n  pointerEvents,\n  reflow,\n}\n","function createGrid (grid: (Interact.Rect | Interact.Point) & { range?: number, limits: Interact.Rect, offset: Interact.Point }) {\n  const coordFields = [\n    ['x', 'y'],\n    ['left', 'top'],\n    ['right', 'bottom'],\n    ['width', 'height'],\n  ].filter(([xField, yField]) => xField in grid || yField in grid)\n\n  return function (x, y) {\n    const {\n      range,\n      limits = {\n        left  : -Infinity,\n        right :  Infinity,\n        top   : -Infinity,\n        bottom:  Infinity,\n      },\n      offset = { x: 0, y: 0 },\n    } = grid\n\n    const result = { range }\n\n    for (const [xField, yField] of coordFields) {\n      const gridx = Math.round((x - offset.x) / grid[xField])\n      const gridy = Math.round((y - offset.y) / grid[yField])\n\n      result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * grid[xField] + offset.x))\n      result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * grid[yField] + offset.y))\n    }\n\n    return result\n  }\n}\n\nexport default createGrid\n","/// <reference path=\"./types.d.ts\" />\nimport interact, { init as initInteract } from '@interactjs/interact'\nimport * as modifiers from '@interactjs/modifiers'\nimport extend from '@interactjs/utils/extend'\nimport * as snappers from '@interactjs/utils/snappers'\n\ndeclare module '@interactjs/interact/interact' {\n    interface InteractStatic {\n        modifiers?: any\n        snappers?: typeof snappers\n        createSnapGrid?: typeof snappers.grid\n    }\n}\n\nif (typeof window === 'object' && !!window) {\n  init(window)\n}\n\nexport function init (win: Window) {\n  initInteract(win)\n\n  return interact.use({\n    install (scope) {\n      interact.modifiers = extend(scope.modifiers, modifiers)\n      interact.snappers = snappers\n      interact.createSnapGrid = interact.snappers.grid\n    },\n  })\n}\n\nexport default interact\n\nif (typeof module === 'object' && !!module) {\n  module.exports = interact\n}\n","export default (thing) => !!(thing && thing.Window) && (thing instanceof thing.Window)\n","// tslint:disable variable-name\n\nimport isWindow from './isWindow'\nimport win from './window'\n\nexport const window = (thing: any): thing is Window =>\n  thing === win.window || isWindow(thing)\n\nexport const docFrag = (thing: any): thing is DocumentFragment =>\n  object(thing) && thing.nodeType === 11\n\nexport const object = (thing: any): thing is { [index: string]: any } =>\n  !!thing && (typeof thing === 'object')\n\nexport const func = (thing: any): thing is (...args: any) => any =>\n  typeof thing === 'function'\n\nexport const number = (thing: any): thing is number =>\n  typeof thing === 'number'\n\nexport const bool = (thing: any): thing is boolean =>\n  typeof thing === 'boolean'\n\nexport const string = (thing: any): thing is string =>\n  typeof thing === 'string'\n\nexport const element = (thing: any): thing is Element => {\n  if (!thing || (typeof thing !== 'object')) { return false }\n\n  const _window = win.getWindow(thing) || win.window\n\n  return (/object|function/.test(typeof _window.Element)\n    ? thing instanceof _window.Element // DOM2\n    : thing.nodeType === 1 && typeof thing.nodeName === 'string')\n}\n\nexport const plainObject: typeof object = (thing: any): thing is { [index: string]: any } =>\n  object(thing) &&\n  !!thing.constructor &&\n  /function Object\\b/.test(thing.constructor.toString())\n\nexport const array = (thing: any): thing is any[] =>\n  (object(thing) &&\n  (typeof thing.length !== 'undefined') &&\n  func(thing.splice))\n","import Interactable from '@interactjs/core/Interactable'\nimport InteractEvent from '@interactjs/core/InteractEvent'\nimport Interaction from '@interactjs/core/Interaction'\nimport * as arr from '@interactjs/utils/arr'\n\nclass DropEvent {\n  type: string\n  target: Element\n  currentTarget: Element\n  dropzone: Interactable\n  dragEvent: InteractEvent\n  relatedTarget: Element\n  interaction: Interaction\n  draggable: Interactable\n  timeStamp: number\n  propagationStopped = false\n  immediatePropagationStopped = false\n\n  /**\n   * Class of events fired on dropzones during drags with acceptable targets.\n   */\n  constructor (dropStatus, dragEvent, type) {\n    const { element, dropzone } = type === 'dragleave'\n      ? dropStatus.prev\n      : dropStatus.cur\n\n    this.type          = type\n    this.target        = element\n    this.currentTarget = element\n    this.dropzone      = dropzone\n    this.dragEvent     = dragEvent\n    this.relatedTarget = dragEvent.target\n    this.interaction   = dragEvent.interaction\n    this.draggable     = dragEvent.interactable\n    this.timeStamp     = dragEvent.timeStamp\n  }\n\n  /**\n   * If this is a `dropactivate` event, the dropzone element will be\n   * deactivated.\n   *\n   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the\n   * dropzone element and more.\n   */\n  reject () {\n    const { dropStatus } = this.interaction\n\n    if (\n      (this.type !== 'dropactivate') && (\n        !this.dropzone ||\n        dropStatus.cur.dropzone !== this.dropzone ||\n        dropStatus.cur.element !== this.target)) {\n      return\n    }\n\n    dropStatus.prev.dropzone = this.dropzone\n    dropStatus.prev.element = this.target\n\n    dropStatus.rejected = true\n    dropStatus.events.enter = null\n\n    this.stopImmediatePropagation()\n\n    if (this.type === 'dropactivate') {\n      const activeDrops = dropStatus.activeDrops\n      const index = arr.findIndex(activeDrops, ({ dropzone, element }) =>\n        dropzone === this.dropzone && element === this.target)\n\n      dropStatus.activeDrops = [\n        ...activeDrops.slice(0, index),\n        ...activeDrops.slice(index + 1),\n      ]\n\n      const deactivateEvent = new DropEvent(dropStatus, this.dragEvent, 'dropdeactivate')\n\n      deactivateEvent.dropzone = this.dropzone\n      deactivateEvent.target = this.target\n\n      this.dropzone.fire(deactivateEvent)\n    }\n    else {\n      this.dropzone.fire(new DropEvent(dropStatus, this.dragEvent, 'dragleave'))\n    }\n  }\n\n  preventDefault () {}\n\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n\nexport default DropEvent\n","type SignalListener = (signalArg: any, sinalName: string) => (void | boolean)\n\nclass Signals {\n  listeners: {\n    [signalName: string]: SignalListener[],\n  } = {}\n\n  on (name: string, listener: SignalListener) {\n    if (!this.listeners[name]) {\n      this.listeners[name] = [listener]\n      return\n    }\n\n    this.listeners[name].push(listener)\n  }\n\n  off (name: string, listener: SignalListener) {\n    if (!this.listeners[name]) { return }\n\n    const index = this.listeners[name].indexOf(listener)\n\n    if (index !== -1) {\n      this.listeners[name].splice(index, 1)\n    }\n  }\n\n  fire (name: string, arg: any): void | false {\n    const targetListeners = this.listeners[name]\n\n    if (!targetListeners) { return }\n\n    for (const listener of targetListeners) {\n      if (listener(arg, name) === false) {\n        return false\n      }\n    }\n  }\n}\n\nexport default Signals\n","export default (x, y) =>  Math.sqrt(x * x + y * y)\n","import browser from './browser'\nimport dom from './domObjects'\nimport * as domUtils from './domUtils'\nimport hypot from './hypot'\nimport * as is from './is'\nimport pointerExtend from './pointerExtend'\n\nconst pointerUtils = {\n  copyCoords (dest, src) {\n    dest.page = dest.page || {}\n    dest.page.x = src.page.x\n    dest.page.y = src.page.y\n\n    dest.client = dest.client || {}\n    dest.client.x = src.client.x\n    dest.client.y = src.client.y\n\n    dest.timeStamp = src.timeStamp\n  },\n\n  setCoordDeltas (targetObj, prev, cur) {\n    targetObj.page.x    = cur.page.x    - prev.page.x\n    targetObj.page.y    = cur.page.y    - prev.page.y\n    targetObj.client.x  = cur.client.x  - prev.client.x\n    targetObj.client.y  = cur.client.y  - prev.client.y\n    targetObj.timeStamp = cur.timeStamp - prev.timeStamp\n  },\n\n  setCoordVelocity (targetObj, delta) {\n    const dt = Math.max(delta.timeStamp / 1000, 0.001)\n\n    targetObj.page.x   = delta.page.x / dt\n    targetObj.page.y   = delta.page.y / dt\n    targetObj.client.x = delta.client.x / dt\n    targetObj.client.y = delta.client.y / dt\n    targetObj.timeStamp = dt\n  },\n\n  isNativePointer  (pointer) {\n    return (pointer instanceof dom.Event || pointer instanceof dom.Touch)\n  },\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  getXY (type, pointer, xy) {\n    xy = xy || {}\n    type = type || 'page'\n\n    xy.x = pointer[type + 'X']\n    xy.y = pointer[type + 'Y']\n\n    return xy\n  },\n\n  getPageXY (pointer: Interact.PointerType | Interact.InteractEvent, page?: Interact.Point) {\n    page = page || { x: 0, y: 0 }\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      pointerUtils.getXY('screen', pointer, page)\n\n      page.x += window.scrollX\n      page.y += window.scrollY\n    }\n    else {\n      pointerUtils.getXY('page', pointer, page)\n    }\n\n    return page\n  },\n\n  getClientXY (pointer, client) {\n    client = client || {}\n\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      pointerUtils.getXY('screen', pointer, client)\n    }\n    else {\n      pointerUtils.getXY('client', pointer, client)\n    }\n\n    return client\n  },\n\n  getPointerId (pointer) {\n    return is.number(pointer.pointerId) ? pointer.pointerId : pointer.identifier\n  },\n\n  setCoords (targetObj, pointers: any[], timeStamp?: number) {\n    const pointer = (pointers.length > 1\n      ? pointerUtils.pointerAverage(pointers)\n      : pointers[0])\n\n    const tmpXY = {} as { x: number, y: number }\n\n    pointerUtils.getPageXY(pointer, tmpXY)\n    targetObj.page.x = tmpXY.x\n    targetObj.page.y = tmpXY.y\n\n    pointerUtils.getClientXY(pointer, tmpXY)\n    targetObj.client.x = tmpXY.x\n    targetObj.client.y = tmpXY.y\n\n    targetObj.timeStamp = is.number(timeStamp) ? timeStamp : new Date().getTime()\n  },\n\n  pointerExtend,\n\n  getTouchPair (event) {\n    const touches = []\n\n    // array of touches is supplied\n    if (is.array(event)) {\n      touches[0] = event[0]\n      touches[1] = event[1]\n    }\n    // an event\n    else {\n      if (event.type === 'touchend') {\n        if (event.touches.length === 1) {\n          touches[0] = event.touches[0]\n          touches[1] = event.changedTouches[0]\n        }\n        else if (event.touches.length === 0) {\n          touches[0] = event.changedTouches[0]\n          touches[1] = event.changedTouches[1]\n        }\n      }\n      else {\n        touches[0] = event.touches[0]\n        touches[1] = event.touches[1]\n      }\n    }\n\n    return touches\n  },\n\n  pointerAverage (pointers: PointerEvent[] | Event[]) {\n    const average = {\n      pageX  : 0,\n      pageY  : 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0,\n    }\n\n    for (const pointer of pointers) {\n      for (const prop in average) {\n        average[prop] += pointer[prop]\n      }\n    }\n    for (const prop in average) {\n      average[prop] /= pointers.length\n    }\n\n    return average\n  },\n\n  touchBBox (event: Event | PointerEvent[]) {\n    if (!(event as any).length &&\n        !((event as TouchEvent).touches &&\n          (event as TouchEvent).touches.length > 1)) {\n      return null\n    }\n\n    const touches = pointerUtils.getTouchPair(event)\n    const minX = Math.min(touches[0].pageX, touches[1].pageX)\n    const minY = Math.min(touches[0].pageY, touches[1].pageY)\n    const maxX = Math.max(touches[0].pageX, touches[1].pageX)\n    const maxY = Math.max(touches[0].pageY, touches[1].pageY)\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    }\n  },\n\n  touchDistance (event, deltaSource) {\n    const sourceX = deltaSource + 'X'\n    const sourceY = deltaSource + 'Y'\n    const touches = pointerUtils.getTouchPair(event)\n\n    const dx = touches[0][sourceX] - touches[1][sourceX]\n    const dy = touches[0][sourceY] - touches[1][sourceY]\n\n    return hypot(dx, dy)\n  },\n\n  touchAngle (event, deltaSource) {\n    const sourceX = deltaSource + 'X'\n    const sourceY = deltaSource + 'Y'\n    const touches = pointerUtils.getTouchPair(event)\n    const dx = touches[1][sourceX] - touches[0][sourceX]\n    const dy = touches[1][sourceY] - touches[0][sourceY]\n    const angle = 180 * Math.atan2(dy, dx) / Math.PI\n\n    return  angle\n  },\n\n  getPointerType (pointer) {\n    return is.string(pointer.pointerType)\n      ? pointer.pointerType\n      : is.number(pointer.pointerType)\n        ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]\n        // if the PointerEvent API isn't available, then the \"pointer\" must\n        // be either a MouseEvent, TouchEvent, or Touch object\n        : /touch/.test(pointer.type) || pointer instanceof dom.Touch\n          ? 'touch'\n          : 'mouse'\n  },\n\n  // [ event.target, event.currentTarget ]\n  getEventTargets (event) {\n    const path = is.func(event.composedPath) ? event.composedPath() : event.path\n\n    return [\n      domUtils.getActualElement(path ? path[0] : event.target),\n      domUtils.getActualElement(event.currentTarget),\n    ]\n  },\n\n  newCoords () {\n    return {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    }\n  },\n\n  coordsToEvent ({ page, client, timeStamp }) {\n    return {\n      page,\n      client,\n      timeStamp,\n      get pageX () { return page.x },\n      get pageY () { return page.y },\n      get clientX () { return client.x },\n      get clientY () { return client.y },\n    }\n  },\n}\n\nexport default pointerUtils\n","export interface Defaults {\n  base: BaseDefaults\n  perAction: PerActionDefaults\n  actions: ActionDefaults\n}\n\nexport interface ActionDefaults {\n  [key: string]: Options\n}\n\nexport interface BaseDefaults {\n  preventDefault?: 'auto' | 'never' | string\n  deltaSource?: 'page' | 'client'\n  [key: string]: any\n}\n\nexport interface PerActionDefaults {\n  enabled?: boolean\n  origin?: Interact.Point | string | Element\n  listeners?: Interact.Listeners\n}\n\nexport interface Options extends BaseDefaults, PerActionDefaults {}\nexport interface OptionsArg extends BaseDefaults, Interact.OrBoolean<PerActionDefaults> {}\n\nexport const defaults: Defaults = {\n  base: {\n    preventDefault: 'auto',\n    deltaSource: 'page',\n  },\n\n  perAction: {\n    enabled: false,\n    origin: { x: 0, y: 0 },\n  },\n\n  actions: {},\n}\n\nexport default defaults\n","import extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport defaults from './defaultOptions'\nimport Interactable from './Interactable'\nimport Interaction from './Interaction'\n\nexport class InteractEvent {\n  type: string\n  target: Element\n  relatedTarget: Element | null\n  currentTarget: Element\n  screenX?: number\n  screenY?: number\n  button: number\n  buttons: number\n  ctrlKey: boolean\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  // added by interact.js\n  interactable: Interactable\n  interaction: any\n  page: Interact.Point\n  client: Interact.Point\n  delta: Interact.Point\n  x0: number\n  y0: number\n  t0: number\n  dt: number\n  duration: number\n  clientX0: number\n  clientY0: number\n  velocity: Interact.Point\n  speed: number\n  swipe: ReturnType<InteractEvent['getSwipe']>\n  timeStamp: any\n  // drag\n  dragEnter?: Element\n  dragLeave?: Element\n  // resize\n  axes?: Interact.Point\n  // gestureend\n  distance?: number\n  angle?: number\n  da?: number // angle change\n  scale?: number // ratio of distance start to current event\n  ds?: number // scale change\n  box?: Interact.Rect // enclosing box of all points\n  preEnd?: boolean\n  immediatePropagationStopped = false\n  propagationStopped = false\n\n  /** */\n  constructor (interaction: Interaction, event: Interact.PointerEventType, actionName: string, phase: string, element: Element, related?: Element, preEnd?: boolean, type?: string) {\n    element = element || interaction.element as Element\n\n    const target      = interaction.target\n    // FIXME: add deltaSource to defaults\n    const deltaSource = (((target && target.options) || defaults) as any).deltaSource as 'page' | 'client'\n    const origin      = getOriginXY(target, element, actionName)\n    const starting    = phase === 'start'\n    const ending      = phase === 'end'\n    const prevEvent   = starting ? this : interaction.prevEvent\n    const coords      = starting\n      ? interaction.coords.start\n      : ending\n        ? { page: prevEvent.page, client: prevEvent.client, timeStamp: interaction.coords.cur.timeStamp }\n        : interaction.coords.cur\n\n    this.page      = extend({}, coords.page)\n    this.client    = extend({}, coords.client)\n    this.timeStamp = coords.timeStamp\n\n    if (!ending) {\n      this.page.x -= origin.x\n      this.page.y -= origin.y\n\n      this.client.x -= origin.x\n      this.client.y -= origin.y\n    }\n\n    this.ctrlKey       = event.ctrlKey\n    this.altKey        = event.altKey\n    this.shiftKey      = event.shiftKey\n    this.metaKey       = event.metaKey\n    this.button        = (event as MouseEvent).button\n    this.buttons       = (event as MouseEvent).buttons\n    this.target        = element\n    this.currentTarget = element\n    this.relatedTarget = related || null\n    this.preEnd        = preEnd\n    this.type          = type || (actionName + (phase || ''))\n    this.interaction   = interaction\n    this.interactable  = target\n\n    this.t0 = starting\n      ? interaction.pointers[interaction.pointers.length - 1].downTime\n      : prevEvent.t0\n\n    this.x0       = interaction.coords.start.page.x - origin.x\n    this.y0       = interaction.coords.start.page.y - origin.y\n    this.clientX0 = interaction.coords.start.client.x - origin.x\n    this.clientY0 = interaction.coords.start.client.y - origin.y\n\n    if (starting || ending) {\n      this.delta = { x: 0, y: 0 }\n    }\n    else {\n      this.delta = {\n        x: this[deltaSource].x - prevEvent[deltaSource].x,\n        y: this[deltaSource].y - prevEvent[deltaSource].y,\n      }\n    }\n\n    this.dt        = interaction.coords.delta.timeStamp\n    this.duration  = this.timeStamp - this.t0\n\n    // velocity and speed in pixels per second\n    this.velocity = extend({}, interaction.coords.velocity[deltaSource])\n    this.speed = hypot(this.velocity.x, this.velocity.y)\n\n    this.swipe = (ending || phase === 'inertiastart') ? this.getSwipe() : null\n  }\n\n  get pageX () { return this.page.x }\n  set pageX (value) { this.page.x = value }\n  get pageY () { return this.page.y }\n  set pageY (value) { this.page.y = value }\n\n  get clientX () { return this.client.x }\n  set clientX (value) { this.client.x = value }\n  get clientY () { return this.client.y }\n  set clientY (value) { this.client.y = value }\n\n  get dx () { return this.delta.x }\n  set dx (value) { this.delta.x = value }\n  get dy () { return this.delta.y }\n  set dy (value) { this.delta.y = value }\n\n  get velocityX () { return this.velocity.x }\n  set velocityX (value) { this.velocity.x = value }\n  get velocityY () { return this.velocity.y }\n  set velocityY (value) { this.velocity.y = value }\n\n  getSwipe () {\n    const interaction = this.interaction\n\n    if (interaction.prevEvent.speed < 600 ||\n        this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null\n    }\n\n    let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI\n    const overlap = 22.5\n\n    if (angle < 0) {\n      angle += 360\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap\n    const up   = 225 - overlap <= angle && angle < 315 + overlap\n\n    const right = !left && (315 - overlap <= angle || angle <  45 + overlap)\n    const down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    }\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n}\n\nexport default InteractEvent\n","import * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport events from '@interactjs/utils/events'\nimport extend from '@interactjs/utils/extend'\nimport * as is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\nimport { Defaults, Options } from './defaultOptions'\nimport Eventable from './Eventable'\nimport { Actions } from './scope'\n\n/** */\nexport class Interactable implements Partial<Eventable> {\n  protected get _defaults (): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {},\n    }\n  }\n\n  options!: Required<Options>\n  readonly _actions: Actions\n  readonly target: Interact.Target\n  readonly events = new Eventable()\n  readonly _context: Element\n  readonly _win: Window\n  readonly _doc: Document\n\n  /** */\n  constructor (target: Interact.Target, options: any, defaultContext: Element | Node) {\n    this._actions = options.actions\n    this.target   = target\n    this._context = options.context || defaultContext\n    this._win     = getWindow(trySelector(target) ? this._context : target)\n    this._doc     = this._win.document\n\n    this.set(options)\n  }\n\n  setOnEvents (actionName: string, phases: { [phase: string]: Interact.ListenersArg }) {\n    if (is.func(phases.onstart)) { this.on(`${actionName}start`, phases.onstart) }\n    if (is.func(phases.onmove)) { this.on(`${actionName}move`, phases.onmove) }\n    if (is.func(phases.onend)) { this.on(`${actionName}end`, phases.onend) }\n    if (is.func(phases.oninertiastart)) { this.on(`${actionName}inertiastart`, phases.oninertiastart) }\n\n    return this\n  }\n\n  updatePerActionListeners (actionName, prev, cur) {\n    if (is.array(prev)) {\n      this.off(actionName, prev)\n    }\n\n    if (is.array(cur)) {\n      this.on(actionName, cur)\n    }\n  }\n\n  setPerAction (actionName, options: Interact.OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName in options) {\n      const actionOptions = this.options[actionName]\n      const optionValue = options[optionName]\n      const isArray = is.array(optionValue)\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue)\n      }\n\n      // if the option value is an array\n      if (isArray) {\n        actionOptions[optionName] = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (!isArray && is.plainObject(optionValue)) {\n        // copy the object\n        actionOptions[optionName] = extend(\n          actionOptions[optionName] || {},\n          clone(optionValue))\n\n        // set anabled field to true if it exists in the defaults\n        if (is.object(defaults.perAction[optionName]) && 'enabled' in defaults.perAction[optionName]) {\n          actionOptions[optionName].enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        actionOptions[optionName].enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        actionOptions[optionName] = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {object} The object's bounding rectangle.\n   */\n  getRect (element: Element) {\n    element = element || (is.element(this.target)\n      ? this.target\n      : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker (checker: (element: Element) => any) {\n    if (is.func(checker)) {\n      this.getRect = checker\n\n      return this\n    }\n\n    if (checker === null) {\n      delete this.options.getRect\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  _backCompatOption (optionName, newValue) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      this.options[optionName] = newValue\n\n      for (const action of this._actions.names) {\n        this.options[action][optionName] = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource (newValue) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context\n  }\n\n  inContext (element) {\n    return (this._context === element.ownerDocument ||\n            nodeContains(this._context, element))\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire (iEvent) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  _onOff (method: 'on' | 'off', typeArg: Interact.EventTypes, listenerArg?: Interact.ListenersArg | null, options?: any) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const addRemove = method === 'on' ? 'add' : 'remove'\n    const listeners = normalizeListeners(typeArg, listenerArg)\n\n    for (let type in listeners) {\n      if (type === 'wheel') { type = browser.wheelEvent }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (arr.contains(this._actions.eventTypes, type)) {\n          this.events[method](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          events[`${addRemove}Delegate`](this.target, this._context, type, listener, options)\n        }\n        // remove listener from this Interatable's element\n        else {\n          (events[addRemove] as typeof events.remove)(this.target as Element, type, listener, options)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on (types: Interact.EventTypes, listener?: Interact.ListenersArg, options?: any) {\n    return this._onOff('on', types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off (types: string | string[] | Interact.EventTypes, listener?: Interact.ListenersArg, options?: any) {\n    return this._onOff('off', types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options: Interact.OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    this.options = clone(defaults.base) as Required<Options>\n\n    for (const actionName in this._actions.methodDict) {\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n\n      this[methodName](options[actionName])\n    }\n\n    for (const setting in options) {\n      if (is.func(this[setting])) {\n        this[setting](options[setting])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   *\n   * @return {interact}\n   */\n  unset () {\n    events.remove(this.target as Node, 'all')\n\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in events.delegatedEvents) {\n        const delegated = events.delegatedEvents[type]\n\n        if (delegated.selectors[0] === this.target &&\n            delegated.contexts[0] === this._context) {\n          delegated.selectors.splice(0, 1)\n          delegated.contexts.splice(0, 1)\n          delegated.listeners.splice(0, 1)\n\n          // remove the arrays if they are empty\n          if (!delegated.selectors.length) {\n            delegated[type] = null\n          }\n        }\n\n        events.remove(this._context, type, events.delegateListener)\n        events.remove(this._context, type, events.delegateUseCapture, true)\n      }\n    }\n    else {\n      events.remove(this.target as Node, 'all')\n    }\n  }\n}\n\nexport default Interactable\n","export class PointerInfo {\n  constructor (\n    public id: number,\n    public pointer: Interact.PointerType,\n    public event: Interact.PointerEventType,\n    public downTime: number,\n    public downTarget: Node,\n  ) {}\n}\n\nexport default PointerInfo\n","import * as utils from '@interactjs/utils'\nimport Interactable from './Interactable'\nimport InteractEvent from './InteractEvent'\nimport PointerInfo from './PointerInfo'\n\nexport interface Action {\n  name: 'drag' | 'resize' | 'gesture'\n  axis?: 'x' | 'y' | 'xy'\n  edges?: Partial<Interact.Rect>\n}\n\nexport class Interaction {\n  // current interactable being interacted with\n  target: Interactable = null as any\n\n  // the target element of the interactable\n  element: Node = null as any\n\n  _signals: utils.Signals\n\n  // action that's ready to be fired on next move event\n  prepared: Action = {\n    name : null as any,\n    axis : null as any,\n    edges: null as any,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: Interact.PointerEventType = null as any\n\n  downPointer: Interact.PointerType = {} as Interact.PointerType\n\n  _latestPointer: {\n    pointer: EventTarget\n    event: Interact.PointerEventType\n    eventTarget: Node,\n  } = {\n    pointer: null as any,\n    event: null as any,\n    eventTarget: null as any,\n  }\n\n  // previous action event\n  prevEvent: InteractEvent = null as any\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n\n  simulation = null\n\n  get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = utils.warnOnce(\n    function (this: Interaction, signalArg: any) {\n      this.move(signalArg)\n    },\n    'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords = {\n    // Starting InteractEvent pointer coordinates\n    start: utils.pointer.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: utils.pointer.newCoords(),\n    // current native pointer move event coordinates\n    cur: utils.pointer.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: utils.pointer.newCoords(),\n    // pointer velocity\n    velocity: utils.pointer.newCoords(),\n  }\n\n  /** */\n  constructor ({ pointerType, signals }: { pointerType: string, signals: utils.Signals }) {\n    this._signals = signals\n    this.pointerType = pointerType\n\n    this._signals.fire('new', this)\n  }\n\n  pointerDown (pointer, event, eventTarget) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n\n    this._signals.fire('down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      interaction: this,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction;\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget);\n   *     }\n   * });\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {object} interact\n   */\n  start (action, target, element) {\n    if (this.interacting() ||\n        !this.pointerIsDown ||\n        this.pointers.length < (action.name === 'gesture' ? 2 : 1)) {\n      return\n    }\n\n    utils.copyAction(this.prepared, action)\n\n    this.target       = target\n    this.element      = element\n    this._interacting = this._doPhase({\n      interaction: this,\n      event: this.downEvent,\n      phase: 'start',\n    })\n  }\n\n  pointerMove (pointer, event, eventTarget) {\n    if (!this.simulation) {\n      this.updatePointer(pointer, event, eventTarget, false)\n      utils.pointer.setCoords(this.coords.cur, this.pointers.map((p) => p.pointer))\n    }\n\n    const duplicateMove = (this.coords.cur.page.x === this.coords.prev.page.x &&\n                           this.coords.cur.page.y === this.coords.prev.page.y &&\n                           this.coords.cur.client.x === this.coords.prev.client.x &&\n                           this.coords.cur.client.y === this.coords.prev.client.y)\n\n    let dx\n    let dy\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const signalArg = {\n      pointer,\n      pointerIndex: this.getPointerIndex(pointer),\n      event,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      utils.pointer.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n      utils.pointer.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._signals.fire('move', signalArg)\n\n    if (!duplicateMove) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        utils.pointer.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }});\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move();\n   *     }\n   *   });\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg) {\n    signalArg = utils.extend({\n      pointer: this._latestPointer.pointer,\n      event: this._latestPointer.event,\n      eventTarget: this._latestPointer.eventTarget,\n      interaction: this,\n      noBefore: false,\n    }, signalArg || {})\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer, event, eventTarget, curEventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    this._signals.fire(/cancel$/i.test(event.type) ? 'cancel' : 'up', {\n      pointer,\n      pointerIndex,\n      event,\n      eventTarget,\n      curEventTarget,\n      interaction: this,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.pointerIsDown = false\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event) {\n    this.end(event)\n    this._signals.fire('blur', { event, interaction: this })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end();\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation();\n   *     }\n   *   });\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._signals.fire('stop', { interaction: this })\n\n    this.target = this.element = null\n\n    this._interacting = false\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer) {\n    const pointerId = utils.pointer.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return (this.pointerType === 'mouse' || this.pointerType === 'pen')\n      ? this.pointers.length - 1\n      : utils.arr.findIndex(this.pointers, (curPointer) => curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer, event, eventTarget, down) {\n    const id = utils.pointer.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false\n      ? false\n      : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(\n        id,\n        pointer,\n        event,\n        null,\n        null,\n      )\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    }\n    else {\n      pointerInfo.pointer = pointer\n    }\n\n    if (down) {\n      this.pointerIsDown = true\n\n      if (!this.interacting()) {\n        utils.pointer.setCoords(this.coords.start, this.pointers.map((p) => p.pointer))\n\n        utils.pointer.copyCoords(this.coords.cur, this.coords.start)\n        utils.pointer.copyCoords(this.coords.prev, this.coords.start)\n        utils.pointer.pointerExtend(this.downPointer, pointer)\n\n        this.downEvent = event\n        pointerInfo.downTime = this.coords.cur.timeStamp\n        pointerInfo.downTarget = eventTarget\n\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._signals.fire('update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: this,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer, event) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) { return }\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._signals.fire('remove-pointer', {\n      pointer,\n      event,\n      pointerIndex,\n      pointerInfo,\n      interaction: this,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n  }\n\n  _updateLatestPointer (pointer, event, eventTarget) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  _createPreparedEvent (event, phase, preEnd, type) {\n    const actionName = this.prepared.name\n\n    return new InteractEvent(this, event, actionName, phase, this.element as Element, null, preEnd, type)\n  }\n\n  _fireEvent (iEvent) {\n    this.target.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase (signalArg) {\n    const { event, phase, preEnd, type } = signalArg\n\n    if (!signalArg.noBefore) {\n      const beforeResult = this._signals.fire(`before-action-${phase}`, signalArg)\n\n      if (beforeResult === false) {\n        return false\n      }\n    }\n\n    const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type)\n\n    this._signals.fire(`action-${phase}`, signalArg)\n\n    this._fireEvent(iEvent)\n\n    this._signals.fire(`after-action-${phase}`, signalArg)\n\n    return true\n  }\n}\n\nexport default Interaction\nexport { PointerInfo }\n","import base from './base'\nimport restrictEdgesModule from './restrict/edges'\nimport restrictModule from './restrict/pointer'\nimport restrictSizeModule from './restrict/size'\nimport snapEdgesModule from './snap/edges'\nimport snapModule from './snap/pointer'\nimport snapSizeModule from './snap/size'\n\nconst { makeModifier } = base\n\nexport const snap = makeModifier(snapModule, 'snap')\nexport const snapSize = makeModifier(snapSizeModule, 'snapSize')\nexport const snapEdges = makeModifier(snapEdgesModule, 'snapEdges')\nexport const restrict = makeModifier(restrictModule, 'restrict')\nexport const restrictEdges = makeModifier(restrictEdgesModule, 'restrictEdges')\nexport const restrictSize = makeModifier(restrictSizeModule, 'restrictSize')\n","import Interaction from '@interactjs/core/Interaction'\nimport pointerUtils from '@interactjs/utils/pointerUtils'\n\n/** */\nexport default class PointerEvent<T extends string> {\n  interaction: Interaction\n  timeStamp: number\n  originalEvent: Interact.PointerEventType\n  type: T\n  pointerId: number\n  pointerType: string\n  target: Node | Window\n  currentTarget: Node | Window\n  double: boolean\n  pageX: number\n  pageY: number\n  clientX: number\n  clientY: number\n  dt: number\n  eventable: any\n  propagationStopped = false\n  immediatePropagationStopped = false\n\n  /** */\n  constructor (type, pointer, event, eventTarget, interaction) {\n    pointerUtils.pointerExtend(this, event)\n\n    if (event !== pointer) {\n      pointerUtils.pointerExtend(this, pointer)\n    }\n\n    this.interaction = interaction\n\n    this.timeStamp     = new Date().getTime()\n    this.originalEvent = event\n    this.type          = type\n    this.pointerId     = pointerUtils.getPointerId(pointer)\n    this.pointerType   = pointerUtils.getPointerType(pointer)\n    this.target        = eventTarget\n    this.currentTarget = null\n\n    if (type === 'tap') {\n      const pointerIndex = interaction.getPointerIndex(pointer)\n      this.dt = this.timeStamp - interaction.pointers[pointerIndex].downTime\n\n      const interval = this.timeStamp - interaction.tapTime\n\n      this.double = !!(interaction.prevTap &&\n        interaction.prevTap.type !== 'doubletap' &&\n        interaction.prevTap.target === this.target &&\n        interval < 500)\n    }\n    else if (type === 'doubletap') {\n      this.dt = pointer.timeStamp - interaction.tapTime\n    }\n  }\n\n  subtractOrigin ({ x: originX, y: originY }) {\n    this.pageX   -= originX\n    this.pageY   -= originY\n    this.clientX -= originX\n    this.clientY -= originY\n\n    return this\n  }\n\n  addOrigin ({ x: originX, y: originY }) {\n    this.pageX   += originX\n    this.pageY   += originY\n    this.clientX += originX\n    this.clientY += originY\n\n    return this\n  }\n\n  /**\n   * Prevent the default behaviour of the original Event\n   */\n  preventDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n","import grid from './grid'\n\nexport { grid }\n","\nreturn _$index_25;\n\n});\n"]}